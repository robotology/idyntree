<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classiDynTree_1_1TransformDerivative" kind="class" language="C++" prot="public">
    <compoundname>iDynTree::TransformDerivative</compoundname>
    <includes local="no">iDynTree/TransformDerivative.h</includes>
      <sectiondef kind="user-defined">
      <header>Raw data accessors.</header>
      <description><para>For several applications it may be useful to access the fransform contents in the raw form of homogeneous matrix or an adjoint matrix. </para>
</description>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a38890e0b6e1c6a6e65b220cf2ae598ae" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix4x4</ref></type>
        <definition>Matrix4x4 iDynTree::TransformDerivative::asHomogeneousTransformDerivative</definition>
        <argsstring>() const</argsstring>
        <name>asHomogeneousTransformDerivative</name>
        <briefdescription>
<para>Return the derivative of the 4x4 homogeneous matrix representing the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned matrix is the one with this structure:</para>
<para><formula id="108">\[ {}^{\texttt{refFrame}} \dot{H}_{\texttt{frame}} = \begin{bmatrix} {}^{\texttt{refOrient}} \dot{R}_{\texttt{orient}} &amp; {}^{\texttt{refOrient}} \dot{p}_{\texttt{refPoint},\texttt{point}} \\ 0_{1\times3} &amp; 1 \end{bmatrix} \]</formula></para>
<para>For details on this notation, check the <ref refid="classiDynTree_1_1Transform_1a8db2358dc66b742a7dcc19e5e43f4e39" kindref="member">Transform::asHomogeneousTransform()</ref> method . </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="121" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a49312f51f1958233deaeabc6338f503e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x6</ref></type>
        <definition>Matrix6x6 iDynTree::TransformDerivative::asAdjointTransformDerivative</definition>
        <argsstring>(const Transform &amp;transform) const</argsstring>
        <name>asAdjointTransformDerivative</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>transform</declname>
        </param>
        <briefdescription>
<para>Return the derivative of the 6x6 adjoint matrix representing this transform. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned matrix is the one with this structure:</para>
<para><formula id="109">\[ {}^{\texttt{refFrame}} X_{\texttt{frame}} = \begin{bmatrix} \dot{R} &amp; \dot{p} \times R + p \times \dot{R} \\ 0_{3\times3} &amp; \dot{R} \end{bmatrix} \]</formula></para>
<para>Where <formula id="103">$R = {}^{\texttt{refOrient}} R_{\texttt{orient}} \in \mathbb{R}^{3\times3}$</formula> is the rotation matrix that takes a 3d vector expressed in the orientationFrame and transform it in a 3d vector expressed in the reference orientation frame.</para>
<para><formula id="104">$p = p_{\texttt{refPoint},\texttt{point}} \in \mathbb{R}^3$</formula> is the vector between the point and the reference point, pointing toward the point and expressed in the reference orientation frame <formula id="105">$p \times$</formula> is the skew simmetric matrix such that <formula id="106">$(p \times) v = p \times v$</formula> .</para>
<para>Given that the <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref> object contains only <formula id="110">$ \dot{R} $</formula> and <formula id="111">$ \dot{p} $</formula>, you need to provide <formula id="14">$ R $</formula> and <formula id="112">$ p $</formula> to this method by passing the relative <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> object.</para>
<para><simplesect kind="warning"><para>Note that in iDynTree the matrix are stored in row major order, and the 6d quantites are serialized in linear/angular order. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="158" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1ab27febf007aa54fa3c88e74b37a3293c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x6</ref></type>
        <definition>Matrix6x6 iDynTree::TransformDerivative::asAdjointTransformWrenchDerivative</definition>
        <argsstring>(const Transform &amp;transform) const</argsstring>
        <name>asAdjointTransformWrenchDerivative</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>transform</declname>
        </param>
        <briefdescription>
<para>Return the 6x6 adjoint matrix (for wrench) representing this transform. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned matrix is the one with this structure:</para>
<para><formula id="113">\[ {}_{\texttt{refFrame}} X^{\texttt{frame}} = \begin{bmatrix} \dot{R} &amp; 0_{3\times3} \\ \dot{p} \times R + p \times \dot{R} &amp; \dot{R} \end{bmatrix} \]</formula></para>
<para>Where <formula id="103">$R = {}^{\texttt{refOrient}} R_{\texttt{orient}} \in \mathbb{R}^{3\times3}$</formula> is the rotation matrix that takes a 3d vector expressed in the orientationFrame and transform it in a 3d vector expressed in the reference orientation frame.</para>
<para><formula id="104">$p = p_{\texttt{refPoint},\texttt{point}} \in \mathbb{R}^3$</formula> is the vector between the point and the reference point, pointing toward the point and expressed in the reference orientation frame <formula id="105">$p \times$</formula> is the skew simmetric matrix such that <formula id="106">$(p \times) v = p \times v$</formula> .</para>
<para>Given that the <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref> object contains only <formula id="110">$ \dot{R} $</formula> and <formula id="111">$ \dot{p} $</formula>, you need to provide <formula id="14">$ R $</formula> and <formula id="112">$ p $</formula> to this method by passing the relative <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> object.</para>
<para><simplesect kind="warning"><para>Note that in iDynTree the matrix are stored in row major order, and the 6d quantites are serialized in linear/angular order. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="195" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a1233fc928abded3318a8d34cdd6762ae" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref></type>
        <definition>TransformDerivative iDynTree::TransformDerivative::operator*</definition>
        <argsstring>(const Transform &amp;otherTransform) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>otherTransform</declname>
        </param>
        <briefdescription>
<para>Multiply a transform derivative for a transform. </para>
        </briefdescription>
        <detaileddescription>
<para>This operation is useful to compose the derivative of a transform for a constant transform.</para>
<para>If this transform derivative represent the derivative of a transform with respect to time <formula id="114">$ ~^a \dot{H}_b $</formula>, and we have a constant transform <formula id="115">$ ~^b H_c $</formula>, then this operation returns the derivative of the transform <formula id="116">$ ~^a H_c $</formula> : <formula id="117">\[ ~^a \dot{H}_c = ~^a \dot{H}_b ~^b H_c \]</formula></para>
<para><simplesect kind="warning"><para>the otherTransform must be a quantity that does not depend on the derivation variable. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="214" column="29"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1afadded161ac37c2ace8c182817ec3c3e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref></type>
        <definition>TransformDerivative iDynTree::TransformDerivative::derivativeOfInverse</definition>
        <argsstring>(const Transform &amp;transform) const</argsstring>
        <name>derivativeOfInverse</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>transform</declname>
        </param>
        <briefdescription>
<para>Get the derivative of the inverse of the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>If this <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref> is <formula id="114">$ ~^a \dot{H}_b $</formula> and the transform argument is <formula id="118">$ ~^a H_b $</formula>, returns the derivative of the inverse transform <formula id="119">$ ~^b {H}_a $</formula> computed as: <formula id="120">\[ ~^b \dot{H}_a = - ~^b {H}_a ~^a \dot{H}_b ~^b H_a \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="227" column="29"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a27c594f59804d305f3fbb3e5edaff273" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1ArticulatedBodyInertia" kindref="compound">ArticulatedBodyInertia</ref></type>
        <definition>ArticulatedBodyInertia iDynTree::TransformDerivative::transform</definition>
        <argsstring>(const Transform &amp;transform, ArticulatedBodyInertia &amp;other)</argsstring>
        <name>transform</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>transform</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1ArticulatedBodyInertia" kindref="compound">ArticulatedBodyInertia</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Given a articulated inertia <formula id="121">$I$</formula> (other argument), this <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref> <formula id="122">$ ~^a\dot{X}_b $</formula> and a transform <formula id="123">$ ~^a{X}_b $</formula> return the articulated body inertia: </para>
        </briefdescription>
        <detaileddescription>
<para><formula id="124">\[ ~_a \dot{X}^b Ia ~^a X_b + ~_a {X}^b Ia ~^a \dot{X}_b \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="236" column="32"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a250449a4ca6bbae36481e15bb883c5aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref></type>
        <definition>SpatialForceVector iDynTree::TransformDerivative::transform</definition>
        <argsstring>(const Transform &amp;transform, SpatialForceVector &amp;other)</argsstring>
        <name>transform</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>transform</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Given a <ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> <formula id="125">$F$</formula> (other argument), this <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref> <formula id="122">$ ~^a\dot{X}_b $</formula> and a transform <formula id="123">$ ~^a{X}_b $</formula> return the spatial force vector: </para>
        </briefdescription>
        <detaileddescription>
<para><formula id="126">\[ ~_a \dot{X}^b F \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="245" column="28"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a7b8b4747e5511931668ec4f1ef6159ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref></type>
        <definition>SpatialMotionVector iDynTree::TransformDerivative::transform</definition>
        <argsstring>(const Transform &amp;transform, SpatialMotionVector &amp;other)</argsstring>
        <name>transform</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>transform</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Given a <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> <formula id="127">$V$</formula> (other argument), this <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref> <formula id="122">$ ~^a\dot{X}_b $</formula> and a transform <formula id="123">$ ~^a{X}_b $</formula> return the spatial force vector: </para>
        </briefdescription>
        <detaileddescription>
<para><formula id="128">\[ ~^a \dot{X}_b F \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="254" column="29"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classiDynTree_1_1TransformDerivative_1a1cec24a352476d31501a6fc9a8f4715e" prot="protected" static="no" mutable="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref></type>
        <definition>Vector3 iDynTree::TransformDerivative::posDerivative</definition>
        <argsstring></argsstring>
        <name>posDerivative</name>
        <briefdescription>
<para>The derivative of the translation part of a <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="34" column="17" bodyfile="iDynTree/TransformDerivative.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classiDynTree_1_1TransformDerivative_1aae1bddabe0940d98e03251361e766570" prot="protected" static="no" mutable="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix3x3</ref></type>
        <definition>Matrix3x3 iDynTree::TransformDerivative::rotDerivative</definition>
        <argsstring></argsstring>
        <name>rotDerivative</name>
        <briefdescription>
<para>The derivative of the rotation part of a <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="39" column="19" bodyfile="iDynTree/TransformDerivative.h" bodystart="39" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1adf92c041cf5c91f7a56ddac14a9f30bc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>iDynTree::TransformDerivative::TransformDerivative</definition>
        <argsstring>()</argsstring>
        <name>TransformDerivative</name>
        <briefdescription>
<para>Default constructor. </para>
        </briefdescription>
        <detaileddescription>
<para>The data is not reset to the default for perfomance reasons. Please initialize the data in the class before any use. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="47" column="9" bodyfile="iDynTree/TransformDerivative.h" bodystart="47" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a86d92c6237183c73b300a3d748eda395" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::TransformDerivative::TransformDerivative</definition>
        <argsstring>(const Matrix3x3 &amp;_rotDeriv, const Vector3 &amp;posDeriv)</argsstring>
        <name>TransformDerivative</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix3x3</ref> &amp;</type>
          <declname>_rotDeriv</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref> &amp;</type>
          <declname>posDeriv</declname>
        </param>
        <briefdescription>
<para>Constructor from a Matrix3x3 and a Vector3 . </para>
        </briefdescription>
        <detaileddescription>
<para>The matrix represent the derivative of a rotation matrix, while the vector the derivative of the position part of the tranform. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="54" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a9ce3f86db8990c49d8dd2c68db4a68f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::TransformDerivative::TransformDerivative</definition>
        <argsstring>(const TransformDerivative &amp;other)</argsstring>
        <name>TransformDerivative</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Copy constructor: create a <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref> from another <ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="59" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1aa7c10eaa9a3898fc9fb67fe6c8188e0e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>iDynTree::TransformDerivative::~TransformDerivative</definition>
        <argsstring>()</argsstring>
        <name>~TransformDerivative</name>
        <briefdescription>
<para>Default destructor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="64" column="9" bodyfile="iDynTree/TransformDerivative.h" bodystart="64" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a7e62b9e5318fda029f0bb1d14ae766fb" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix3x3</ref> &amp;</type>
        <definition>const Matrix3x3&amp; iDynTree::TransformDerivative::getRotationDerivative</definition>
        <argsstring>() const</argsstring>
        <name>getRotationDerivative</name>
        <briefdescription>
<para>Get the derivative of the rotation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="70" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a156f7b6ec1df03a6bdc3344e41aee40c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref> &amp;</type>
        <definition>const Vector3&amp; iDynTree::TransformDerivative::getPositionDerivative</definition>
        <argsstring>() const</argsstring>
        <name>getPositionDerivative</name>
        <briefdescription>
<para>Get the derivative of the translation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="76" column="24"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a5cc3d9ce991a42f19d8858c19fd1573e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::TransformDerivative::setRotationDerivative</definition>
        <argsstring>(const Matrix3x3 &amp;rotationDerivative)</argsstring>
        <name>setRotationDerivative</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix3x3</ref> &amp;</type>
          <declname>rotationDerivative</declname>
        </param>
        <briefdescription>
<para>Set the derivative of the rotation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="82" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1a1da48139b879178dcefae4abf004ec15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::TransformDerivative::setPositionDerivative</definition>
        <argsstring>(const Vector3 &amp;positionDerivative)</argsstring>
        <name>setPositionDerivative</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref> &amp;</type>
          <declname>positionDerivative</declname>
        </param>
        <briefdescription>
<para>Set the derivative of translation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="88" column="14"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classiDynTree_1_1TransformDerivative_1ad2a6c65d670801c051620087debd6f3c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1TransformDerivative" kindref="compound">TransformDerivative</ref></type>
        <definition>static TransformDerivative iDynTree::TransformDerivative::Zero</definition>
        <argsstring>()</argsstring>
        <name>Zero</name>
        <briefdescription>
<para>Return a zero transfom derivative. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>an zero transform derivative. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TransformDerivative.h" line="95" column="36"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Class representing the derivative of <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> object. </para>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="note"><para>Even if most methods documentation are written assuming that this class represents the derivative of a <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> with respect to time, it can be used to represent a derivative with respect to an arbitrary variable. </para>
</simplesect>
</para>
    </detaileddescription>
    <collaborationgraph>
      <node id="3">
        <label>iDynTree::VectorFixSize&lt; VecSize &gt;</label>
        <link refid="classiDynTree_1_1VectorFixSize"/>
      </node>
      <node id="5">
        <label>iDynTree::MatrixFixSize&lt; nRows, nCols &gt;</label>
        <link refid="classiDynTree_1_1MatrixFixSize"/>
      </node>
      <node id="1">
        <label>iDynTree::TransformDerivative</label>
        <link refid="classiDynTree_1_1TransformDerivative"/>
        <childnode refid="2" relation="usage">
          <edgelabel>posDerivative</edgelabel>
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>rotDerivative</edgelabel>
        </childnode>
      </node>
      <node id="2">
        <label>iDynTree::VectorFixSize&lt; 3 &gt;</label>
        <link refid="classiDynTree_1_1VectorFixSize"/>
        <childnode refid="3" relation="template-instance">
          <edgelabel>&lt; 3 &gt;</edgelabel>
        </childnode>
      </node>
      <node id="4">
        <label>iDynTree::MatrixFixSize&lt; 3, 3 &gt;</label>
        <link refid="classiDynTree_1_1MatrixFixSize"/>
        <childnode refid="5" relation="template-instance">
          <edgelabel>&lt; 3, 3 &gt;</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="iDynTree/TransformDerivative.h" line="28" column="5" bodyfile="iDynTree/TransformDerivative.h" bodystart="29" bodyend="255"/>
    <listofallmembers>
      <member refid="classiDynTree_1_1TransformDerivative_1a49312f51f1958233deaeabc6338f503e" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>asAdjointTransformDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1ab27febf007aa54fa3c88e74b37a3293c" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>asAdjointTransformWrenchDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a38890e0b6e1c6a6e65b220cf2ae598ae" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>asHomogeneousTransformDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1afadded161ac37c2ace8c182817ec3c3e" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>derivativeOfInverse</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a156f7b6ec1df03a6bdc3344e41aee40c" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>getPositionDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a7e62b9e5318fda029f0bb1d14ae766fb" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>getRotationDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a1233fc928abded3318a8d34cdd6762ae" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a1cec24a352476d31501a6fc9a8f4715e" prot="protected" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>posDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1aae1bddabe0940d98e03251361e766570" prot="protected" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>rotDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a1da48139b879178dcefae4abf004ec15" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>setPositionDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a5cc3d9ce991a42f19d8858c19fd1573e" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>setRotationDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a27c594f59804d305f3fbb3e5edaff273" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>transform</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a250449a4ca6bbae36481e15bb883c5aa" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>transform</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a7b8b4747e5511931668ec4f1ef6159ab" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>transform</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1adf92c041cf5c91f7a56ddac14a9f30bc" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>TransformDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a86d92c6237183c73b300a3d748eda395" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>TransformDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1a9ce3f86db8990c49d8dd2c68db4a68f2" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>TransformDerivative</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1ad2a6c65d670801c051620087debd6f3c" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>Zero</name></member>
      <member refid="classiDynTree_1_1TransformDerivative_1aa7c10eaa9a3898fc9fb67fe6c8188e0e" prot="public" virt="non-virtual"><scope>iDynTree::TransformDerivative</scope><name>~TransformDerivative</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
