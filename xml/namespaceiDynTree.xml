<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespaceiDynTree" kind="namespace" language="C++">
    <compoundname>iDynTree</compoundname>
    <innerclass refid="classiDynTree_1_1AccelerometerSensor" prot="public">iDynTree::AccelerometerSensor</innerclass>
    <innerclass refid="classiDynTree_1_1ContactWrench" prot="public">iDynTree::ContactWrench</innerclass>
    <innerclass refid="classiDynTree_1_1LinkContactWrenches" prot="public">iDynTree::LinkContactWrenches</innerclass>
    <innerclass refid="structiDynTree_1_1DHLink" prot="public">iDynTree::DHLink</innerclass>
    <innerclass refid="classiDynTree_1_1DHChain" prot="public">iDynTree::DHChain</innerclass>
    <innerclass refid="structiDynTree_1_1ArticulatedBodyAlgorithmInternalBuffers" prot="public">iDynTree::ArticulatedBodyAlgorithmInternalBuffers</innerclass>
    <innerclass refid="structiDynTree_1_1ForwardDynamicsLinearizationInternalBuffers" prot="public">iDynTree::ForwardDynamicsLinearizationInternalBuffers</innerclass>
    <innerclass refid="classiDynTree_1_1FreeFloatingStateLinearization" prot="public">iDynTree::FreeFloatingStateLinearization</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialMotionWrtMotionDerivative" prot="public">iDynTree::SpatialMotionWrtMotionDerivative</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialForceWrtMotionDerivative" prot="public">iDynTree::SpatialForceWrtMotionDerivative</innerclass>
    <innerclass refid="classiDynTree_1_1FixedJoint" prot="public">iDynTree::FixedJoint</innerclass>
    <innerclass refid="classiDynTree_1_1FrameFreeFloatingJacobian" prot="public">iDynTree::FrameFreeFloatingJacobian</innerclass>
    <innerclass refid="classiDynTree_1_1MomentumFreeFloatingJacobian" prot="public">iDynTree::MomentumFreeFloatingJacobian</innerclass>
    <innerclass refid="classiDynTree_1_1FreeFloatingMassMatrix" prot="public">iDynTree::FreeFloatingMassMatrix</innerclass>
    <innerclass refid="classiDynTree_1_1FreeFloatingPos" prot="public">iDynTree::FreeFloatingPos</innerclass>
    <innerclass refid="classiDynTree_1_1FreeFloatingGeneralizedTorques" prot="public">iDynTree::FreeFloatingGeneralizedTorques</innerclass>
    <innerclass refid="classiDynTree_1_1FreeFloatingVel" prot="public">iDynTree::FreeFloatingVel</innerclass>
    <innerclass refid="classiDynTree_1_1FreeFloatingAcc" prot="public">iDynTree::FreeFloatingAcc</innerclass>
    <innerclass refid="classiDynTree_1_1GyroscopeSensor" prot="public">iDynTree::GyroscopeSensor</innerclass>
    <innerclass refid="classiDynTree_1_1IJoint" prot="public">iDynTree::IJoint</innerclass>
    <innerclass refid="classiDynTree_1_1MatrixView" prot="public">iDynTree::MatrixView</innerclass>
    <innerclass refid="classiDynTree_1_1JointPosDoubleArray" prot="public">iDynTree::JointPosDoubleArray</innerclass>
    <innerclass refid="classiDynTree_1_1JointDOFsDoubleArray" prot="public">iDynTree::JointDOFsDoubleArray</innerclass>
    <innerclass refid="classiDynTree_1_1DOFSpatialForceArray" prot="public">iDynTree::DOFSpatialForceArray</innerclass>
    <innerclass refid="classiDynTree_1_1DOFSpatialMotionArray" prot="public">iDynTree::DOFSpatialMotionArray</innerclass>
    <innerclass refid="classiDynTree_1_1Link" prot="public">iDynTree::Link</innerclass>
    <innerclass refid="classiDynTree_1_1LinkPositions" prot="public">iDynTree::LinkPositions</innerclass>
    <innerclass refid="classiDynTree_1_1LinkWrenches" prot="public">iDynTree::LinkWrenches</innerclass>
    <innerclass refid="classiDynTree_1_1LinkInertias" prot="public">iDynTree::LinkInertias</innerclass>
    <innerclass refid="classiDynTree_1_1LinkArticulatedBodyInertias" prot="public">iDynTree::LinkArticulatedBodyInertias</innerclass>
    <innerclass refid="classiDynTree_1_1LinkVelArray" prot="public">iDynTree::LinkVelArray</innerclass>
    <innerclass refid="classiDynTree_1_1LinkAccArray" prot="public">iDynTree::LinkAccArray</innerclass>
    <innerclass refid="classiDynTree_1_1LinkTraversalsCache" prot="public">iDynTree::LinkTraversalsCache</innerclass>
    <innerclass refid="structiDynTree_1_1Neighbor" prot="public">iDynTree::Neighbor</innerclass>
    <innerclass refid="classiDynTree_1_1Model" prot="public">iDynTree::Model</innerclass>
    <innerclass refid="classiDynTree_1_1MovableJointImpl" prot="public">iDynTree::MovableJointImpl</innerclass>
    <innerclass refid="classiDynTree_1_1PrismaticJoint" prot="public">iDynTree::PrismaticJoint</innerclass>
    <innerclass refid="classiDynTree_1_1RevoluteJoint" prot="public">iDynTree::RevoluteJoint</innerclass>
    <innerclass refid="classiDynTree_1_1Sensor" prot="public">iDynTree::Sensor</innerclass>
    <innerclass refid="classiDynTree_1_1JointSensor" prot="public">iDynTree::JointSensor</innerclass>
    <innerclass refid="classiDynTree_1_1LinkSensor" prot="public">iDynTree::LinkSensor</innerclass>
    <innerclass refid="classiDynTree_1_1SensorsList" prot="public">iDynTree::SensorsList</innerclass>
    <innerclass refid="classiDynTree_1_1SensorsMeasurements" prot="public">iDynTree::SensorsMeasurements</innerclass>
    <innerclass refid="classiDynTree_1_1SixAxisForceTorqueSensor" prot="public">iDynTree::SixAxisForceTorqueSensor</innerclass>
    <innerclass refid="classiDynTree_1_1Material" prot="public">iDynTree::Material</innerclass>
    <innerclass refid="classiDynTree_1_1SolidShape" prot="public">iDynTree::SolidShape</innerclass>
    <innerclass refid="classiDynTree_1_1Sphere" prot="public">iDynTree::Sphere</innerclass>
    <innerclass refid="classiDynTree_1_1Box" prot="public">iDynTree::Box</innerclass>
    <innerclass refid="classiDynTree_1_1Cylinder" prot="public">iDynTree::Cylinder</innerclass>
    <innerclass refid="classiDynTree_1_1ExternalMesh" prot="public">iDynTree::ExternalMesh</innerclass>
    <innerclass refid="classiDynTree_1_1ModelSolidShapes" prot="public">iDynTree::ModelSolidShapes</innerclass>
    <innerclass refid="classiDynTree_1_1SubModelDecomposition" prot="public">iDynTree::SubModelDecomposition</innerclass>
    <innerclass refid="classiDynTree_1_1ThreeAxisAngularAccelerometerSensor" prot="public">iDynTree::ThreeAxisAngularAccelerometerSensor</innerclass>
    <innerclass refid="classiDynTree_1_1ThreeAxisForceTorqueContactSensor" prot="public">iDynTree::ThreeAxisForceTorqueContactSensor</innerclass>
    <innerclass refid="classiDynTree_1_1Traversal" prot="public">iDynTree::Traversal</innerclass>
    <innerclass refid="classiDynTree_1_1iKinLimbImported" prot="public">iDynTree::iKinLimbImported</innerclass>
    <innerclass refid="classiDynTree_1_1skinDynLibLinkID" prot="public">iDynTree::skinDynLibLinkID</innerclass>
    <innerclass refid="classiDynTree_1_1iDynTreeLinkAndFrame" prot="public">iDynTree::iDynTreeLinkAndFrame</innerclass>
    <innerclass refid="classiDynTree_1_1skinDynLibConversionsHelper" prot="public">iDynTree::skinDynLibConversionsHelper</innerclass>
    <innerclass refid="classiDynTree_1_1ArticulatedBodyInertia" prot="public">iDynTree::ArticulatedBodyInertia</innerclass>
    <innerclass refid="classiDynTree_1_1Axis" prot="public">iDynTree::Axis</innerclass>
    <innerclass refid="classiDynTree_1_1ClassicalAcc" prot="public">iDynTree::ClassicalAcc</innerclass>
    <innerclass refid="classiDynTree_1_1CubicSpline" prot="public">iDynTree::CubicSpline</innerclass>
    <innerclass refid="classiDynTree_1_1Direction" prot="public">iDynTree::Direction</innerclass>
    <innerclass refid="structiDynTree_1_1is__sparsematrix" prot="public">iDynTree::is_sparsematrix</innerclass>
    <innerclass refid="structiDynTree_1_1is__sparsematrix_3_01iDynTree_1_1SparseMatrix_3_01ordering_01_4_01_4" prot="public">iDynTree::is_sparsematrix&lt; iDynTree::SparseMatrix&lt; ordering &gt; &gt;</innerclass>
    <innerclass refid="classiDynTree_1_1GeomVector3" prot="public">iDynTree::GeomVector3</innerclass>
    <innerclass refid="classiDynTree_1_1RigidBodyInertiaNonLinearParametrization" prot="public">iDynTree::RigidBodyInertiaNonLinearParametrization</innerclass>
    <innerclass refid="classiDynTree_1_1MatrixDynSize" prot="public">iDynTree::MatrixDynSize</innerclass>
    <innerclass refid="classiDynTree_1_1MatrixFixSize" prot="public">iDynTree::MatrixFixSize</innerclass>
    <innerclass refid="classiDynTree_1_1Position" prot="public">iDynTree::Position</innerclass>
    <innerclass refid="classiDynTree_1_1Rotation" prot="public">iDynTree::Rotation</innerclass>
    <innerclass refid="classiDynTree_1_1RotationalInertia" prot="public">iDynTree::RotationalInertia</innerclass>
    <innerclass refid="structiDynTree_1_1GeodesicL2MeanOptions" prot="public">iDynTree::GeodesicL2MeanOptions</innerclass>
    <innerclass refid="classiDynTree_1_1Span" prot="public">iDynTree::Span</innerclass>
    <innerclass refid="classiDynTree_1_1SparseMatrix" prot="public">iDynTree::SparseMatrix</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialAcc" prot="public">iDynTree::SpatialAcc</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialForceVector" prot="public">iDynTree::SpatialForceVector</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialInertia" prot="public">iDynTree::SpatialInertia</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialMomentum" prot="public">iDynTree::SpatialMomentum</innerclass>
    <innerclass refid="classiDynTree_1_1Dummy" prot="public">iDynTree::Dummy</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialMotionVector" prot="public">iDynTree::SpatialMotionVector</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialMotionForceVectorT__traits" prot="public">iDynTree::SpatialMotionForceVectorT_traits</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialMotionForceVectorT__traits_3_01SpatialMotionVector_01_4" prot="public">iDynTree::SpatialMotionForceVectorT_traits&lt; SpatialMotionVector &gt;</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialMotionForceVectorT__traits_3_01SpatialForceVector_01_4" prot="public">iDynTree::SpatialMotionForceVectorT_traits&lt; SpatialForceVector &gt;</innerclass>
    <innerclass refid="structiDynTree_1_1DualSpace" prot="public">iDynTree::DualSpace</innerclass>
    <innerclass refid="structiDynTree_1_1DualSpace_3_01SpatialMotionVector_01_4" prot="public">iDynTree::DualSpace&lt; SpatialMotionVector &gt;</innerclass>
    <innerclass refid="structiDynTree_1_1DualSpace_3_01SpatialForceVector_01_4" prot="public">iDynTree::DualSpace&lt; SpatialForceVector &gt;</innerclass>
    <innerclass refid="classiDynTree_1_1SpatialVector" prot="public">iDynTree::SpatialVector</innerclass>
    <innerclass refid="structiDynTree_1_1TestMatrixMismatch" prot="public">iDynTree::TestMatrixMismatch</innerclass>
    <innerclass refid="classiDynTree_1_1Transform" prot="public">iDynTree::Transform</innerclass>
    <innerclass refid="classiDynTree_1_1TransformDerivative" prot="public">iDynTree::TransformDerivative</innerclass>
    <innerclass refid="classiDynTree_1_1Triplet" prot="public">iDynTree::Triplet</innerclass>
    <innerclass refid="classiDynTree_1_1Triplets" prot="public">iDynTree::Triplets</innerclass>
    <innerclass refid="classiDynTree_1_1Twist" prot="public">iDynTree::Twist</innerclass>
    <innerclass refid="structiDynTree_1_1IndexRange" prot="public">iDynTree::IndexRange</innerclass>
    <innerclass refid="classiDynTree_1_1VectorDynSize" prot="public">iDynTree::VectorDynSize</innerclass>
    <innerclass refid="classiDynTree_1_1VectorFixSize" prot="public">iDynTree::VectorFixSize</innerclass>
    <innerclass refid="classiDynTree_1_1Wrench" prot="public">iDynTree::Wrench</innerclass>
    <innerclass refid="classiDynTree_1_1BoundingBoxProjectionConstraint" prot="public">iDynTree::BoundingBoxProjectionConstraint</innerclass>
    <innerclass refid="classiDynTree_1_1Polygon" prot="public">iDynTree::Polygon</innerclass>
    <innerclass refid="classiDynTree_1_1Polygon2D" prot="public">iDynTree::Polygon2D</innerclass>
    <innerclass refid="classiDynTree_1_1ConvexHullProjectionConstraint" prot="public">iDynTree::ConvexHullProjectionConstraint</innerclass>
    <innerclass refid="classiDynTree_1_1InverseKinematics" prot="public">iDynTree::InverseKinematics</innerclass>
    <innerclass refid="structiDynTree_1_1AttitudeEstimatorState" prot="public">iDynTree::AttitudeEstimatorState</innerclass>
    <innerclass refid="classiDynTree_1_1IAttitudeEstimator" prot="public">iDynTree::IAttitudeEstimator</innerclass>
    <innerclass refid="structiDynTree_1_1AttitudeMahonyFilterParameters" prot="public">iDynTree::AttitudeMahonyFilterParameters</innerclass>
    <innerclass refid="classiDynTree_1_1AttitudeMahonyFilter" prot="public">iDynTree::AttitudeMahonyFilter</innerclass>
    <innerclass refid="structiDynTree_1_1AttitudeQuaternionEKFParameters" prot="public">iDynTree::AttitudeQuaternionEKFParameters</innerclass>
    <innerclass refid="classiDynTree_1_1AttitudeQuaternionEKF" prot="public">iDynTree::AttitudeQuaternionEKF</innerclass>
    <innerclass refid="structiDynTree_1_1BerdyOptions" prot="public">iDynTree::BerdyOptions</innerclass>
    <innerclass refid="structiDynTree_1_1BerdySensor" prot="public">iDynTree::BerdySensor</innerclass>
    <innerclass refid="structiDynTree_1_1BerdyDynamicVariable" prot="public">iDynTree::BerdyDynamicVariable</innerclass>
    <innerclass refid="classiDynTree_1_1BerdyHelper" prot="public">iDynTree::BerdyHelper</innerclass>
    <innerclass refid="classiDynTree_1_1BerdySparseMAPSolver" prot="public">iDynTree::BerdySparseMAPSolver</innerclass>
    <innerclass refid="classiDynTree_1_1BipedFootContactClassifier" prot="public">iDynTree::BipedFootContactClassifier</innerclass>
    <innerclass refid="structiDynTree_1_1SchmittParams" prot="public">iDynTree::SchmittParams</innerclass>
    <innerclass refid="classiDynTree_1_1ContactStateMachine" prot="public">iDynTree::ContactStateMachine</innerclass>
    <innerclass refid="classiDynTree_1_1DiscreteExtendedKalmanFilterHelper" prot="public">iDynTree::DiscreteExtendedKalmanFilterHelper</innerclass>
    <innerclass refid="structiDynTree_1_1UnknownWrenchContact" prot="public">iDynTree::UnknownWrenchContact</innerclass>
    <innerclass refid="classiDynTree_1_1LinkUnknownWrenchContacts" prot="public">iDynTree::LinkUnknownWrenchContacts</innerclass>
    <innerclass refid="structiDynTree_1_1estimateExternalWrenchesBuffers" prot="public">iDynTree::estimateExternalWrenchesBuffers</innerclass>
    <innerclass refid="classiDynTree_1_1ExtWrenchesAndJointTorquesEstimator" prot="public">iDynTree::ExtWrenchesAndJointTorquesEstimator</innerclass>
    <innerclass refid="classiDynTree_1_1GravityCompensationHelper" prot="public">iDynTree::GravityCompensationHelper</innerclass>
    <innerclass refid="classiDynTree_1_1DiscreteKalmanFilterHelper" prot="public">iDynTree::DiscreteKalmanFilterHelper</innerclass>
    <innerclass refid="classiDynTree_1_1SchmittTrigger" prot="public">iDynTree::SchmittTrigger</innerclass>
    <innerclass refid="classiDynTree_1_1SimpleLeggedOdometry" prot="public">iDynTree::SimpleLeggedOdometry</innerclass>
    <innerclass refid="classiDynTree_1_1KinDynComputations" prot="public">iDynTree::KinDynComputations</innerclass>
    <innerclass refid="structiDynTree_1_1ApproximateSolidShapesWithPrimitiveShapeOptions" prot="public">iDynTree::ApproximateSolidShapesWithPrimitiveShapeOptions</innerclass>
    <innerclass refid="classiDynTree_1_1MeshcatVisualizer" prot="public">iDynTree::MeshcatVisualizer</innerclass>
    <innerclass refid="classiDynTree_1_1ICameraAnimator" prot="public">iDynTree::ICameraAnimator</innerclass>
    <innerclass refid="classiDynTree_1_1ICamera" prot="public">iDynTree::ICamera</innerclass>
    <innerclass refid="classiDynTree_1_1ColorViz" prot="public">iDynTree::ColorViz</innerclass>
    <innerclass refid="classiDynTree_1_1PixelViz" prot="public">iDynTree::PixelViz</innerclass>
    <innerclass refid="classiDynTree_1_1ILight" prot="public">iDynTree::ILight</innerclass>
    <innerclass refid="classiDynTree_1_1IEnvironment" prot="public">iDynTree::IEnvironment</innerclass>
    <innerclass refid="classiDynTree_1_1IJetsVisualization" prot="public">iDynTree::IJetsVisualization</innerclass>
    <innerclass refid="classiDynTree_1_1ILabel" prot="public">iDynTree::ILabel</innerclass>
    <innerclass refid="classiDynTree_1_1IVectorsVisualization" prot="public">iDynTree::IVectorsVisualization</innerclass>
    <innerclass refid="classiDynTree_1_1IFrameVisualization" prot="public">iDynTree::IFrameVisualization</innerclass>
    <innerclass refid="classiDynTree_1_1IShapeVisualization" prot="public">iDynTree::IShapeVisualization</innerclass>
    <innerclass refid="classiDynTree_1_1IModelVisualization" prot="public">iDynTree::IModelVisualization</innerclass>
    <innerclass refid="classiDynTree_1_1ITexture" prot="public">iDynTree::ITexture</innerclass>
    <innerclass refid="structiDynTree_1_1VisualizerOptions" prot="public">iDynTree::VisualizerOptions</innerclass>
    <innerclass refid="classiDynTree_1_1ITexturesHandler" prot="public">iDynTree::ITexturesHandler</innerclass>
    <innerclass refid="classiDynTree_1_1Visualizer" prot="public">iDynTree::Visualizer</innerclass>
    <innerclass refid="classiDynTree_1_1ModelCalibrationHelper" prot="public">iDynTree::ModelCalibrationHelper</innerclass>
    <innerclass refid="structiDynTree_1_1ModelExporterOptions" prot="public">iDynTree::ModelExporterOptions</innerclass>
    <innerclass refid="classiDynTree_1_1ModelExporter" prot="public">iDynTree::ModelExporter</innerclass>
    <innerclass refid="structiDynTree_1_1ModelParserOptions" prot="public">iDynTree::ModelParserOptions</innerclass>
    <innerclass refid="classiDynTree_1_1ModelLoader" prot="public">iDynTree::ModelLoader</innerclass>
    <innerclass refid="classiDynTree_1_1ForceTorqueSensorElement" prot="public">iDynTree::ForceTorqueSensorElement</innerclass>
    <innerclass refid="classiDynTree_1_1ForceTorqueSensorHelper" prot="public">iDynTree::ForceTorqueSensorHelper</innerclass>
    <innerclass refid="classiDynTree_1_1GeometryElement" prot="public">iDynTree::GeometryElement</innerclass>
    <innerclass refid="classiDynTree_1_1InertialElement" prot="public">iDynTree::InertialElement</innerclass>
    <innerclass refid="classiDynTree_1_1JointElement" prot="public">iDynTree::JointElement</innerclass>
    <innerclass refid="classiDynTree_1_1LinkElement" prot="public">iDynTree::LinkElement</innerclass>
    <innerclass refid="classiDynTree_1_1MaterialElement" prot="public">iDynTree::MaterialElement</innerclass>
    <innerclass refid="classiDynTree_1_1OriginElement" prot="public">iDynTree::OriginElement</innerclass>
    <innerclass refid="classiDynTree_1_1RobotElement" prot="public">iDynTree::RobotElement</innerclass>
    <innerclass refid="classiDynTree_1_1SensorElement" prot="public">iDynTree::SensorElement</innerclass>
    <innerclass refid="classiDynTree_1_1SensorHelper" prot="public">iDynTree::SensorHelper</innerclass>
    <innerclass refid="classiDynTree_1_1AccelerometerSensorHelper" prot="public">iDynTree::AccelerometerSensorHelper</innerclass>
    <innerclass refid="classiDynTree_1_1GyroscopeSensorHelper" prot="public">iDynTree::GyroscopeSensorHelper</innerclass>
    <innerclass refid="classiDynTree_1_1URDFDocument" prot="public">iDynTree::URDFDocument</innerclass>
    <innerclass refid="classiDynTree_1_1VisualElement" prot="public">iDynTree::VisualElement</innerclass>
    <innerclass refid="classiDynTree_1_1XMLAttribute" prot="public">iDynTree::XMLAttribute</innerclass>
    <innerclass refid="classiDynTree_1_1XMLDocument" prot="public">iDynTree::XMLDocument</innerclass>
    <innerclass refid="classiDynTree_1_1XMLElement" prot="public">iDynTree::XMLElement</innerclass>
    <innerclass refid="classiDynTree_1_1XMLParser" prot="public">iDynTree::XMLParser</innerclass>
    <innerclass refid="classiDynTree_1_1XMLParserState" prot="public">iDynTree::XMLParserState</innerclass>
    <innernamespace refid="namespaceiDynTree_1_1details">iDynTree::details</innernamespace>
    <innernamespace refid="namespaceiDynTree_1_1MatrixViewInternal">iDynTree::MatrixViewInternal</innernamespace>
    <innernamespace refid="namespaceiDynTree_1_1optimalcontrol">iDynTree::optimalcontrol</innernamespace>
    <innernamespace refid="namespaceiDynTree_1_1optimization">iDynTree::optimization</innernamespace>
    <innernamespace refid="namespaceiDynTree_1_1SpanUtils">iDynTree::SpanUtils</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="FreeFloatingMatrices_8h_1a0089c6dac34bc6a4f623d9e9e565375a" prot="public" static="no" strong="no">
        <type></type>
        <name>FrameVelocityRepresentation</name>
        <enumvalue id="FreeFloatingMatrices_8h_1a0089c6dac34bc6a4f623d9e9e565375aaf9e6abb240a3f5f6f3eb386c21277eeb" prot="public">
          <name>INERTIAL_FIXED_REPRESENTATION</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="FreeFloatingMatrices_8h_1a0089c6dac34bc6a4f623d9e9e565375aad3aa0f715d4709ae83c826d14ffb1dad" prot="public">
          <name>BODY_FIXED_REPRESENTATION</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="FreeFloatingMatrices_8h_1a0089c6dac34bc6a4f623d9e9e565375aacfd8cfdeac3248d26f145bd0998f93b8" prot="public">
          <name>MIXED_REPRESENTATION</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Possible frame velocity representation convention. </para>
        </briefdescription>
        <detaileddescription>
<para>Given a link <formula id="0">$L$</formula> and an absolute frame <formula id="4">$A$</formula>, the the possible frame velocity representation are the following:<itemizedlist>
<listitem><para><computeroutput>INERTIAL_FIXED_REPRESENTATION</computeroutput> : Velocity representation is <formula id="16">${}^{A} \mathrm{v}_{A,B}$</formula>,</para>
</listitem><listitem><para><computeroutput>BODY_FIXED_REPRESENTATION</computeroutput> : Velocity representation is <formula id="17">${}^{B} \mathrm{v}_{A,B}$</formula>,</para>
</listitem><listitem><para><computeroutput>MIXED_REPRESENTATION</computeroutput> : Velocity representation is <formula id="18">${}^{B[A]} \mathrm{v}_{A,B}$</formula>.</para>
</listitem></itemizedlist>
</para>
<para>See <ref refid="classiDynTree_1_1KinDynComputations" kindref="compound">iDynTree::KinDynComputations</ref> documentation for more details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/FreeFloatingMatrices.h" line="25" column="1" bodyfile="iDynTree/FreeFloatingMatrices.h" bodystart="26" bodyend="30"/>
      </memberdef>
      <memberdef kind="enum" id="IJoint_8h_1aaf7a7f242cce355fb311a53b2df40515" prot="public" static="no" strong="no">
        <type></type>
        <name>JointDynamicsType</name>
        <enumvalue id="IJoint_8h_1aaf7a7f242cce355fb311a53b2df40515a20857d4b69f0d31ae45d631abb786fdb" prot="public">
          <name>NoJointDynamics</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>NoDynamics: No joint dynamics is assumed for the joint. </para>
          </briefdescription>
          <detaileddescription>
<para>This joint dynamics type does not consider any parameter. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="IJoint_8h_1aaf7a7f242cce355fb311a53b2df40515a64acee9e0dd4fc665bab44e12c10917a" prot="public">
          <name>URDFJointDynamics</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>URDFJointDynamics: Dynamics described by the URDF 1.0 specification. </para>
          </briefdescription>
          <detaileddescription>
<para>This joint dynamics type consider the following parameters:<itemizedlist>
<listitem><para><computeroutput>Damping</computeroutput></para>
</listitem><listitem><para><computeroutput>StaticFriction</computeroutput> </para>
</listitem></itemizedlist>
</para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/IJoint.h" line="21" column="5" bodyfile="iDynTree/IJoint.h" bodystart="22" bodyend="37"/>
      </memberdef>
      <memberdef kind="enum" id="Sensors_8h_1ad291b88efdf5262d744d33f642daf8b9" prot="public" static="no" strong="no">
        <type></type>
        <name>SensorType</name>
        <enumvalue id="Sensors_8h_1ad291b88efdf5262d744d33f642daf8b9a7006069f3fbbdb2dfdd42a73646eb0c2" prot="public">
          <name>SIX_AXIS_FORCE_TORQUE</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="Sensors_8h_1ad291b88efdf5262d744d33f642daf8b9acaffc97afec9d7a74f00e940a440e27c" prot="public">
          <name>ACCELEROMETER</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="Sensors_8h_1ad291b88efdf5262d744d33f642daf8b9af18877b600b6d3bb9828709115fc0f7d" prot="public">
          <name>GYROSCOPE</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="Sensors_8h_1ad291b88efdf5262d744d33f642daf8b9a442e40fb46ceb1796cb5d6b7d7e7e167" prot="public">
          <name>THREE_AXIS_ANGULAR_ACCELEROMETER</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="Sensors_8h_1ad291b88efdf5262d744d33f642daf8b9a92de2e46732f84e720c99cd5a3588190" prot="public">
          <name>THREE_AXIS_FORCE_TORQUE_CONTACT</name>
          <initializer>= 4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Sensors.h" line="28" column="5" bodyfile="iDynTree/Sensors.h" bodystart="29" bodyend="35"/>
      </memberdef>
      <memberdef kind="enum" id="Utils_8h_1a1d9848852f7effdff0a7206e361759dc" prot="public" static="no" strong="no">
        <type></type>
        <name>MatrixStorageOrdering</name>
        <enumvalue id="Utils_8h_1a1d9848852f7effdff0a7206e361759dca2b26025c525aa73dc7d5a8ab6b75c277" prot="public">
          <name>RowMajor</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Row Major ordering, i.e. matrix is serialized row by row </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="Utils_8h_1a1d9848852f7effdff0a7206e361759dcaa2d6963e41f11651763298147696f0dc" prot="public">
          <name>ColumnMajor</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Column Major ordering, i.e. matrix is serialized row by column </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enum describing the possible matrix storage ordering. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="117" column="5" bodyfile="iDynTree/Utils.h" bodystart="117" bodyend="120"/>
      </memberdef>
      <memberdef kind="enum" id="InverseKinematics_8h_1a04da5add9479687cf4c7eb873e717c6c" prot="public" static="no" strong="no">
        <type></type>
        <name>InverseKinematicsRotationParametrization</name>
        <enumvalue id="InverseKinematics_8h_1a04da5add9479687cf4c7eb873e717c6ca6bbd58481084418979b449c46aff99a8" prot="public">
          <name>InverseKinematicsRotationParametrizationQuaternion</name>
          <briefdescription>
<para>Quaternion parametrization. </para>
          </briefdescription>
          <detaileddescription>
<para>In theory this parametrization does not suffer from discontinuity like the, InverseKinematicsRotationParametrizationRollPitchYaw one, but the existing implementation does not work as expected, and so its use is discouraged. See <ulink url="https://github.com/robotology/idyntree/issues/1059">https://github.com/robotology/idyntree/issues/1059</ulink> for more details. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="InverseKinematics_8h_1a04da5add9479687cf4c7eb873e717c6caad8ec2efa81330efbf416e7550113ca5" prot="public">
          <name>InverseKinematicsRotationParametrizationRollPitchYaw</name>
          <briefdescription>
<para>Roll Pitch Yaw parametrization. </para>
          </briefdescription>
          <detaileddescription>
<para>This parametrization is the one used by default, but it may not work properly near the points in which the parametrization has discontinuities. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>type of parametrization for the rotation (SO3) element </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/InverseKinematics.h" line="31" column="5" bodyfile="iDynTree/InverseKinematics.h" bodystart="31" bodyend="46"/>
      </memberdef>
      <memberdef kind="enum" id="InverseKinematics_8h_1a5cb905194c9ee61c0a23b32d603b2df2" prot="public" static="no" strong="no">
        <type></type>
        <name>InverseKinematicsTreatTargetAsConstraint</name>
        <enumvalue id="InverseKinematics_8h_1a5cb905194c9ee61c0a23b32d603b2df2aa3f7c6e0138052de9bc8a0d3dcd9d712" prot="public">
          <name>InverseKinematicsTreatTargetAsConstraintNone</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="InverseKinematics_8h_1a5cb905194c9ee61c0a23b32d603b2df2a786b8aeaff64c77f025cec462c47206b" prot="public">
          <name>InverseKinematicsTreatTargetAsConstraintPositionOnly</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="InverseKinematics_8h_1a5cb905194c9ee61c0a23b32d603b2df2aad1cbbc20ef9d02ff21364a90f781681" prot="public">
          <name>InverseKinematicsTreatTargetAsConstraintRotationOnly</name>
          <initializer>= 1 &lt;&lt; 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="InverseKinematics_8h_1a5cb905194c9ee61c0a23b32d603b2df2a90e54d63819ec0bff0f8eec68beff50b" prot="public">
          <name>InverseKinematicsTreatTargetAsConstraintFull</name>
          <initializer>= InverseKinematicsTreatTargetAsConstraintPositionOnly | InverseKinematicsTreatTargetAsConstraintRotationOnly</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Specify how to solve for the desired target. </para>
        </briefdescription>
        <detaileddescription>
<para>A target frame can be solved as a constraints (i.e. if it cannot be obtained the problem is unfeasible) or as a cost (best-effort to reach the target) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/InverseKinematics.h" line="67" column="5" bodyfile="iDynTree/InverseKinematics.h" bodystart="67" bodyend="72"/>
      </memberdef>
      <memberdef kind="enum" id="group__iDynTreeExperimental_1ga62aff3167b9df327b4b1db6affadd21f" prot="public" static="no" strong="no">
        <type></type>
        <name>BerdyVariants</name>
        <enumvalue id="group__iDynTreeExperimental_1gga62aff3167b9df327b4b1db6affadd21faf59c4a22cd72d6e001dbba40910e9c32" prot="public">
          <name>ORIGINAL_BERDY_FIXED_BASE</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Original version of Berdy, as described in: </para>
          </briefdescription>
          <detaileddescription>
<para>Latella, C.; Kuppuswamy, N.; Romano, F.; Traversaro, S.; Nori, F. Whole-Body Human Inverse Dynamics with Distributed Micro-Accelerometers, Gyros and Force Sensing. Sensors 2016, 16, 727. <ulink url="http://www.mdpi.com/1424-8220/16/5/727">http://www.mdpi.com/1424-8220/16/5/727</ulink></para>
<para>The original version of Berdy is assuming that the joint numbering is a regular ordering of links and joints. For this reason the serialization of link/joints quantities follows the one defined in the traversal.</para>
<para>Furthremore, this version assumes that all joints have 1 Degree of freedom, so it does not work for models with fixed joints. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1gga62aff3167b9df327b4b1db6affadd21fa1ca580068ec7f491800abeadf68185e5" prot="public">
          <name>BERDY_FLOATING_BASE</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Modified version of Berdy for accounting for free floating dynamics and removing the NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV from the dynamic variables. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1gga62aff3167b9df327b4b1db6affadd21fa02a303d789d6ebc0a5c3829cd72d4b4d" prot="public">
          <name>BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Modified version of floating base Berdy for accounting centroidal dynamics constraints towards estimating the external link wrench independently of the internal joint torque estimates. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration of the Berdy variants implemented in this class. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>This class is still in active development, and so API interface can change between iDynTree versions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/BerdyHelper.h" line="37" column="1" bodyfile="iDynTree/BerdyHelper.h" bodystart="38" bodyend="67"/>
      </memberdef>
      <memberdef kind="enum" id="group__iDynTreeExperimental_1ga83d8f828969dabc7dc82904d8de15312" prot="public" static="no" strong="no">
        <type></type>
        <name>BerdyDynamicVariablesTypes</name>
        <enumvalue id="group__iDynTreeExperimental_1gga83d8f828969dabc7dc82904d8de15312a48b4b26b9b1780cc55a5cbc89c6f0d15" prot="public">
          <name>LINK_BODY_PROPER_ACCELERATION</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><formula id="232">$ a_i $</formula> Note that is is the <bold>spatial</bold> proper acceleration expressed, i.e. the time derivative of the left-trivialized velocity minus the gravity expressed in body frame. <formula id="233">$ f^B_i $</formula> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1gga83d8f828969dabc7dc82904d8de15312a4d8110167e729b4fd3a17147bcd1252e" prot="public">
          <name>NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><formula id="234">$ f_i $</formula> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1gga83d8f828969dabc7dc82904d8de15312adaecc7fb3d43b48487ae03dfec685fb8" prot="public">
          <name>JOINT_WRENCH</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><formula id="235">$ \tau_i $</formula> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1gga83d8f828969dabc7dc82904d8de15312a80199996cf9e8b7d5171d762533f6c0c" prot="public">
          <name>DOF_TORQUE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><formula id="236">$ f^x_i $</formula> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1gga83d8f828969dabc7dc82904d8de15312aa13efb04f5c05ca865f2aee0fd03fe68" prot="public">
          <name>NET_EXT_WRENCH</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para><formula id="237">$ \ddot{q}_i $</formula> </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1gga83d8f828969dabc7dc82904d8de15312a9a69ec4d25d83b00175dc3adb8edce00" prot="public">
          <name>DOF_ACCELERATION</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>This is the classical proper acceleration, i.e. the time derivative of the mixed velocity of the body frame minus the gravity expressed in body frame. In Traversaro&apos;s PhD thesis this is called sensor proper acceleration. This is the necessary for avoiding dependencies on the linear velocity of the base in the floating variant of Berdy. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1gga83d8f828969dabc7dc82904d8de15312ac2cfd7190c466bb19a532054700478dc" prot="public">
          <name>LINK_BODY_PROPER_CLASSICAL_ACCELERATION</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration describing the dynamic variables types (link acceleration, net wrenches, joint wrenches, joint torques, joint acceleration) used in Berdy. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>This class is still in active development, and so API interface can change between iDynTree versions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/BerdyHelper.h" line="76" column="1" bodyfile="iDynTree/BerdyHelper.h" bodystart="77" bodyend="101"/>
      </memberdef>
      <memberdef kind="enum" id="group__iDynTreeExperimental_1gab629c8d25391838124595ba8961654e4" prot="public" static="no" strong="no">
        <type></type>
        <name>BerdySensorTypes</name>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4aeb713f0bede28acb44bffd71c4c8b7c5" prot="public">
          <name>SIX_AXIS_FORCE_TORQUE_SENSOR</name>
          <initializer>= SIX_AXIS_FORCE_TORQUE</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4a7735d104e1d0a81cd5cf6b4d4c6e280c" prot="public">
          <name>ACCELEROMETER_SENSOR</name>
          <initializer>= ACCELEROMETER</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4a0057121dd88c26066f6ea316f78f7e97" prot="public">
          <name>GYROSCOPE_SENSOR</name>
          <initializer>= GYROSCOPE</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4a959f2e93bc56ff32d8dc98a75bdaa0a8" prot="public">
          <name>THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR</name>
          <initializer>= THREE_AXIS_ANGULAR_ACCELEROMETER</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4a5bcadad8e7702de8f0dbcdbd5108d893" prot="public">
          <name>THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR</name>
          <initializer>= THREE_AXIS_FORCE_TORQUE_CONTACT</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4a3b05b1fa0daf40ead3bb45631fc1b425" prot="public">
          <name>DOF_ACCELERATION_SENSOR</name>
          <initializer>= 1000</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4afe52ea6ba4b27e76e1fd986700941151" prot="public">
          <name>DOF_TORQUE_SENSOR</name>
          <initializer>= 1001</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4aa295b9c16be05c81c215270381d2b648" prot="public">
          <name>NET_EXT_WRENCH_SENSOR</name>
          <initializer>= 1002</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4a207d61f7e8d81f6729f6dd080ba8a06c" prot="public">
          <name>JOINT_WRENCH_SENSOR</name>
          <initializer>= 1003</initializer>
          <briefdescription>
<para>Non-physical sensor that measures the wrench trasmitted by a joint. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__iDynTreeExperimental_1ggab629c8d25391838124595ba8961654e4a86f8f9556695317ef66bb0adef6cd978" prot="public">
          <name>RCM_SENSOR</name>
          <initializer>= 1004</initializer>
          <briefdescription>
<para>Non-physical sensor that holds the value of Rate of Change of Momentum (RCM) of the system for centroidal dynamics constraint. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration describing the possible sensor types implemented in Berdy. </para>
        </briefdescription>
        <detaileddescription>
<para>Note that the concept of &quot;sensor&quot; in Berdy estimation is more general that just a physical sensor mounted on the robot: for example it can include the information that a link is fixed to the ground (i.e. its angular velocity, angular and linear acceleration are zero) even if this information is not coming from an actual physical sensors. For this reason we do not use directly the iDynTree::SensorTypes enum, even if we reserve the first 1000 elements o of this enum to be compatibile with the iDynTree::SensorTypes enum. Enum values duplicates between BerdySensorTypes and SensorTypes are append a _SENSOR suffix to avoid problems when wrapping such enum wit SWIG.</para>
<para><simplesect kind="warning"><para>This class is still in active development, and so API interface can change between iDynTree versions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/BerdyHelper.h" line="119" column="1" bodyfile="iDynTree/BerdyHelper.h" bodystart="120" bodyend="139"/>
      </memberdef>
      <memberdef kind="enum" id="BipedFootContactClassifier_8h_1a87e9224ed19ef268687c0d2522048946" prot="public" static="no" strong="no">
        <type></type>
        <name>SwitchingPattern</name>
        <enumvalue id="BipedFootContactClassifier_8h_1a87e9224ed19ef268687c0d2522048946a524b0c6a15e4d5b55f396a39e42ab305" prot="public">
          <name>ALTERNATE_CONTACT</name>
          <briefdescription>
<para>Switching active foot between left and right at every double stance. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="BipedFootContactClassifier_8h_1a87e9224ed19ef268687c0d2522048946ad1645067b3ead8a700e7551ff0af01d9" prot="public">
          <name>LATEST_ACTIVE_CONTACT</name>
          <briefdescription>
<para>Setting active foot to the one that made contact most recently <linebreak/>
 </para>
          </briefdescription>
          <detaileddescription>
<para><simplesect kind="warning"><para>this pattern remains unimplemented in the current version of this class using this pattern will always return left foot as the active foot </para>
</simplesect>
</para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="BipedFootContactClassifier_8h_1a87e9224ed19ef268687c0d2522048946aa6e9a49639f39ee24e3fbafc4cee78f0" prot="public">
          <name>DEFAULT_CONTACT</name>
          <briefdescription>
<para>Fixing active foot to the default foot defined by the user <linebreak/>
 </para>
          </briefdescription>
          <detaileddescription>
<para><simplesect kind="warning"><para>this pattern remains unimplemented in the current version of this class using this pattern will always return left foot as the active foot </para>
</simplesect>
</para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enumeration of switching pattern. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/BipedFootContactClassifier.h" line="15" column="5" bodyfile="iDynTree/BipedFootContactClassifier.h" bodystart="16" bodyend="35"/>
      </memberdef>
      <memberdef kind="enum" id="ExternalWrenchesEstimation_8h_1a3af0bfcd7989e409b610847e3b397b26" prot="public" static="no" strong="no">
        <type></type>
        <name>UnknownWrenchContactType</name>
        <enumvalue id="ExternalWrenchesEstimation_8h_1a3af0bfcd7989e409b610847e3b397b26a6abd6bcbc638153015ff2229a4cc6c3f" prot="public">
          <name>FULL_WRENCH</name>
          <briefdescription>
<para>Contact for which the complete wrench is unknown. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ExternalWrenchesEstimation_8h_1a3af0bfcd7989e409b610847e3b397b26aeb51903155017085b84cc6aac2e2bba6" prot="public">
          <name>PURE_FORCE</name>
          <briefdescription>
<para>Contact assumed to be a pure force excerted on the contact point. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ExternalWrenchesEstimation_8h_1a3af0bfcd7989e409b610847e3b397b26a7e0e568e396d7cd82bf2fa23ca525a3a" prot="public">
          <name>PURE_FORCE_WITH_KNOWN_DIRECTION</name>
          <briefdescription>
<para>Contact assumed to be a pure force with a known direction excerted on the contact point. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ExternalWrenchesEstimation_8h_1a3af0bfcd7989e409b610847e3b397b26a40b36711643e2573ff0f03773c0555e2" prot="public">
          <name>NO_UNKNOWNS</name>
          <briefdescription>
<para>The contact forces is assumed to be known. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Type of a <ref refid="structiDynTree_1_1UnknownWrenchContact" kindref="compound">UnknownWrenchContact</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ExternalWrenchesEstimation.h" line="34" column="1" bodyfile="iDynTree/ExternalWrenchesEstimation.h" bodystart="35" bodyend="55"/>
      </memberdef>
      <memberdef kind="enum" id="ModelTransformersSolidShapes_8h_1a6760312b6c7a94affa286e93e5181357" prot="public" static="no" strong="yes">
        <type></type>
        <name>ApproximateSolidShapesWithPrimitiveShapeConversionType</name>
        <enumvalue id="ModelTransformersSolidShapes_8h_1a6760312b6c7a94affa286e93e5181357aefb5cb99d45dcda9ffe319455772cc74" prot="public">
          <name>ConvertSolidShapesWithEnclosingAxisAlignedBoundingBoxes</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformersSolidShapes.h" line="21" column="1" bodyfile="iDynTree/ModelTransformersSolidShapes.h" bodystart="21" bodyend="23"/>
      </memberdef>
      <memberdef kind="enum" id="ModelTransformersSolidShapes_8h_1a406a37da4e2a7b314679f42210e17496" prot="public" static="no" strong="yes">
        <type></type>
        <name>ApproximateSolidShapesWithPrimitiveShapeShapesToApproximate</name>
        <enumvalue id="ModelTransformersSolidShapes_8h_1a406a37da4e2a7b314679f42210e17496af8627c06e14c7be7e55266f664e41df1" prot="public">
          <name>VisualShapes</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ModelTransformersSolidShapes_8h_1a406a37da4e2a7b314679f42210e17496a36b6a35779ae883db4d5eae25858bc62" prot="public">
          <name>CollisionShapes</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="ModelTransformersSolidShapes_8h_1a406a37da4e2a7b314679f42210e17496a1a96a1824b9b2103e329a71d173cabbf" prot="public">
          <name>BothShapes</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Enum class representing which shape should be approximated. </para>
        </briefdescription>
        <detaileddescription>
<para>Namely teh visual, collision or both shapes. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformersSolidShapes.h" line="29" column="1" bodyfile="iDynTree/ModelTransformersSolidShapes.h" bodystart="29" bodyend="33"/>
      </memberdef>
      <memberdef kind="enum" id="Visualizer_8h_1aad6844bb3e20ca63bfe9e3ee6e26515a" prot="public" static="no" strong="no">
        <type></type>
        <name>LightType</name>
        <enumvalue id="Visualizer_8h_1aad6844bb3e20ca63bfe9e3ee6e26515aa7552ee08212d810760cfcca2c9e26976" prot="public">
          <name>POINT_LIGHT</name>
          <briefdescription>
<para>point light, it has a position in space and radiates light in all directions </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="Visualizer_8h_1aad6844bb3e20ca63bfe9e3ee6e26515aac19ca7f555771da916a01ed3fa781d21" prot="public">
          <name>DIRECTIONAL_LIGHT</name>
          <briefdescription>
<para>directional light, coming from a direction from an infinite distance </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Visualizer.h" line="181" column="1" bodyfile="iDynTree/Visualizer.h" bodystart="182" bodyend="187"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="AccelerometerSensor_8h_1ae032ae81e0b23b33446033eefb13e629" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">LinearMotionVector3</ref></type>
        <definition>typedef LinearMotionVector3 iDynTree::LinAcceleration</definition>
        <argsstring></argsstring>
        <name>LinAcceleration</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AccelerometerSensor.h" line="13" column="33" bodyfile="iDynTree/AccelerometerSensor.h" bodystart="12" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GyroscopeSensor_8h_1a303a7b672a9817d74c5a6279fbfe5e34" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">AngularMotionVector3</ref></type>
        <definition>typedef AngularMotionVector3 iDynTree::AngVelocity</definition>
        <argsstring></argsstring>
        <name>AngVelocity</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GyroscopeSensor.h" line="13" column="34" bodyfile="iDynTree/GyroscopeSensor.h" bodystart="12" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="IJoint_8h_1ade0c4658492d5288102a323d704a2a1c" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1IJoint" kindref="compound">IJoint</ref> *</type>
        <definition>typedef IJoint* iDynTree::IJointPtr</definition>
        <argsstring></argsstring>
        <name>IJointPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/IJoint.h" line="457" column="21" bodyfile="iDynTree/IJoint.h" bodystart="457" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="IJoint_8h_1ac8fef24361e5d31b7bb1c5e468ea9513" prot="public" static="no">
        <type>const <ref refid="classiDynTree_1_1IJoint" kindref="compound">IJoint</ref> *</type>
        <definition>typedef const IJoint* iDynTree::IJointConstPtr</definition>
        <argsstring></argsstring>
        <name>IJointConstPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/IJoint.h" line="458" column="27" bodyfile="iDynTree/IJoint.h" bodystart="458" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="Indices_8h_1a7b1bbb834d5bf0d3c64cdf91ab3d6e72" prot="public" static="no">
        <type>std::ptrdiff_t</type>
        <definition>typedef std::ptrdiff_t iDynTree::LinkIndex</definition>
        <argsstring></argsstring>
        <name>LinkIndex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="19" column="28" bodyfile="iDynTree/Indices.h" bodystart="19" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="Indices_8h_1a52bed44082992c37ef913adaa76e6c3c" prot="public" static="no">
        <type>std::ptrdiff_t</type>
        <definition>typedef std::ptrdiff_t iDynTree::JointIndex</definition>
        <argsstring></argsstring>
        <name>JointIndex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="23" column="28" bodyfile="iDynTree/Indices.h" bodystart="23" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="Indices_8h_1ae732811edba33ac282fd0834dc0bdfd5" prot="public" static="no">
        <type>std::ptrdiff_t</type>
        <definition>typedef std::ptrdiff_t iDynTree::DOFIndex</definition>
        <argsstring></argsstring>
        <name>DOFIndex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="27" column="28" bodyfile="iDynTree/Indices.h" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="Indices_8h_1aa29f3a0bcb161b96b72e593c2bdf0419" prot="public" static="no">
        <type>std::ptrdiff_t</type>
        <definition>typedef std::ptrdiff_t iDynTree::FrameIndex</definition>
        <argsstring></argsstring>
        <name>FrameIndex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="31" column="28" bodyfile="iDynTree/Indices.h" bodystart="31" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="Indices_8h_1a5d98b515bfdfd0764e5dc7c27e65de23" prot="public" static="no">
        <type>std::ptrdiff_t</type>
        <definition>typedef std::ptrdiff_t iDynTree::TraversalIndex</definition>
        <argsstring></argsstring>
        <name>TraversalIndex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="35" column="28" bodyfile="iDynTree/Indices.h" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="Link_8h_1a39bc17f697110e44c09c2e6e1aa7fa57" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1Link" kindref="compound">Link</ref> *</type>
        <definition>typedef Link* iDynTree::LinkPtr</definition>
        <argsstring></argsstring>
        <name>LinkPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Link.h" line="75" column="19" bodyfile="iDynTree/Link.h" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="Link_8h_1a34779dc4741f85944c0e2f736dc7def2" prot="public" static="no">
        <type>const <ref refid="classiDynTree_1_1Link" kindref="compound">Link</ref> *</type>
        <definition>typedef const Link* iDynTree::LinkConstPtr</definition>
        <argsstring></argsstring>
        <name>LinkConstPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Link.h" line="76" column="25" bodyfile="iDynTree/Link.h" bodystart="76" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="LinkState_8h_1ac93f1a5870ffbdb40436a8ab17b4df5a" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkWrenches</ref></type>
        <definition>typedef LinkWrenches iDynTree::LinkNetExternalWrenches</definition>
        <argsstring></argsstring>
        <name>LinkNetExternalWrenches</name>
        <briefdescription>
<para>Vector of the sum of all the external wrenches excerted on each link. </para>
        </briefdescription>
        <detaileddescription>
<para>The wrench returned by operator(i) is the sum of all external wrenches (thus excluding the wrench applied on the link by other links in the model) that the environment applies on the link $i$, expressed ( both orientation and point) with respect to the reference frame of link i. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/LinkState.h" line="104" column="26" bodyfile="iDynTree/LinkState.h" bodystart="104" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="LinkState_8h_1ab0304c1c94e9d9f0bbd646fceaad6e40" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkWrenches</ref></type>
        <definition>typedef LinkWrenches iDynTree::LinkInternalWrenches</definition>
        <argsstring></argsstring>
        <name>LinkInternalWrenches</name>
        <briefdescription>
<para>Vector of the wrenches acting that a link excert on his parent, given a <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Given a <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> with base link b, the wrench returned by operator(i) is the wrench the parent of link i excerts on link i, expressed (both orientation and point) with respect to the reference frame of link i. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/LinkState.h" line="114" column="26" bodyfile="iDynTree/LinkState.h" bodystart="114" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="LinkState_8h_1a8467b5079b622cd683df2fcdfd16b07c" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkWrenches</ref></type>
        <definition>typedef LinkWrenches iDynTree::LinkNetTotalWrenchesWithoutGravity</definition>
        <argsstring></argsstring>
        <name>LinkNetTotalWrenchesWithoutGravity</name>
        <briefdescription>
<para>Vector of the sum of all the wrenches (both internal and external, excluding gravity) acting on link i, expressed (both orientation and point) with respect to the reference frame of link i. </para>
        </briefdescription>
        <detaileddescription>
<para>This is tipically computed as I*a+v*(I*v) , where a is the proper acceleration. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/LinkState.h" line="123" column="26" bodyfile="iDynTree/LinkState.h" bodystart="123" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="LinkState_8h_1a4eebfd4c3b5feb2154a1de101578fb4a" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1LinkInertias" kindref="compound">LinkInertias</ref></type>
        <definition>typedef LinkInertias iDynTree::LinkCompositeRigidBodyInertias</definition>
        <argsstring></argsstring>
        <name>LinkCompositeRigidBodyInertias</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/LinkState.h" line="148" column="26" bodyfile="iDynTree/LinkState.h" bodystart="148" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="LinkState_8h_1a104b2ec0864d4c37b58b808b43630171" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref></type>
        <definition>typedef LinkAccArray iDynTree::LinkProperAccArray</definition>
        <argsstring></argsstring>
        <name>LinkProperAccArray</name>
        <briefdescription>
<para>Typedef used when the vector is meant to be a vector of link proper accelerations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/LinkState.h" line="231" column="26" bodyfile="iDynTree/LinkState.h" bodystart="231" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MovableJointImpl_8h_1ac4ab72af9658e6e1503c06a97786db7f" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MovableJointImpl" kindref="compound">MovableJointImpl</ref>&lt; 1, 1 &gt;</type>
        <definition>typedef MovableJointImpl&lt;1,1&gt; iDynTree::MovableJointImpl1</definition>
        <argsstring></argsstring>
        <name>MovableJointImpl1</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MovableJointImpl.h" line="157" column="30" bodyfile="iDynTree/MovableJointImpl.h" bodystart="157" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MovableJointImpl_8h_1a24b411fa2a181857fd60881b7a1fa644" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MovableJointImpl" kindref="compound">MovableJointImpl</ref>&lt; 2, 2 &gt;</type>
        <definition>typedef MovableJointImpl&lt;2,2&gt; iDynTree::MovableJointImpl2</definition>
        <argsstring></argsstring>
        <name>MovableJointImpl2</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MovableJointImpl.h" line="158" column="30" bodyfile="iDynTree/MovableJointImpl.h" bodystart="158" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MovableJointImpl_8h_1ae4671e7929209092bc1d6a72f460872a" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MovableJointImpl" kindref="compound">MovableJointImpl</ref>&lt; 3, 3 &gt;</type>
        <definition>typedef MovableJointImpl&lt;3,3&gt; iDynTree::MovableJointImpl3</definition>
        <argsstring></argsstring>
        <name>MovableJointImpl3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MovableJointImpl.h" line="159" column="30" bodyfile="iDynTree/MovableJointImpl.h" bodystart="159" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MovableJointImpl_8h_1a66158274373829ef7c8694995a9d6929" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MovableJointImpl" kindref="compound">MovableJointImpl</ref>&lt; 4, 4 &gt;</type>
        <definition>typedef MovableJointImpl&lt;4,4&gt; iDynTree::MovableJointImpl4</definition>
        <argsstring></argsstring>
        <name>MovableJointImpl4</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MovableJointImpl.h" line="160" column="30" bodyfile="iDynTree/MovableJointImpl.h" bodystart="160" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MovableJointImpl_8h_1a5b8dfe13ce097fa3e505f492b7906c63" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MovableJointImpl" kindref="compound">MovableJointImpl</ref>&lt; 5, 5 &gt;</type>
        <definition>typedef MovableJointImpl&lt;5,5&gt; iDynTree::MovableJointImpl5</definition>
        <argsstring></argsstring>
        <name>MovableJointImpl5</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MovableJointImpl.h" line="161" column="30" bodyfile="iDynTree/MovableJointImpl.h" bodystart="161" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MovableJointImpl_8h_1af1c9c077a2177994db5ee45257af1d48" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MovableJointImpl" kindref="compound">MovableJointImpl</ref>&lt; 6, 6 &gt;</type>
        <definition>typedef MovableJointImpl&lt;6,6&gt; iDynTree::MovableJointImpl6</definition>
        <argsstring></argsstring>
        <name>MovableJointImpl6</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MovableJointImpl.h" line="162" column="30" bodyfile="iDynTree/MovableJointImpl.h" bodystart="162" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="EigenHelpers_8h_1acad81b92d9885b5eec826b3066af8960" prot="public" static="no">
        <type>Eigen::Map&lt; Eigen::VectorXd &gt;</type>
        <definition>typedef Eigen::Map&lt;Eigen::VectorXd&gt; iDynTree::iDynTreeEigenVector</definition>
        <argsstring></argsstring>
        <name>iDynTreeEigenVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="28" column="24" bodyfile="iDynTree/EigenHelpers.h" bodystart="28" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="EigenHelpers_8h_1a60faf8b72189d4496f7b7920d5ea3b01" prot="public" static="no">
        <type>Eigen::Map&lt; const Eigen::VectorXd &gt;</type>
        <definition>typedef Eigen::Map&lt;const Eigen::VectorXd&gt; iDynTree::iDynTreeEigenConstVector</definition>
        <argsstring></argsstring>
        <name>iDynTreeEigenConstVector</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="29" column="24" bodyfile="iDynTree/EigenHelpers.h" bodystart="29" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="EigenHelpers_8h_1a8dd9b043a4e3ceaa1b9a173e826020aa" prot="public" static="no">
        <type>Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</type>
        <definition>typedef Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt; iDynTree::iDynTreeEigenMatrix</definition>
        <argsstring></argsstring>
        <name>iDynTreeEigenMatrix</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="30" column="27" bodyfile="iDynTree/EigenHelpers.h" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="EigenHelpers_8h_1a2d3ea8f566b9d5684e3b008a1f8c8d6f" prot="public" static="no">
        <type>const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</type>
        <definition>typedef const Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt; iDynTree::iDynTreeEigenConstMatrix</definition>
        <argsstring></argsstring>
        <name>iDynTreeEigenConstMatrix</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="31" column="33" bodyfile="iDynTree/EigenHelpers.h" bodystart="31" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="EigenHelpers_8h_1a26eec6588ddf3f8a8546b9f7899590eb" prot="public" static="no">
        <type>Eigen::Map&lt; iDynTreeEigenMatrix &gt;</type>
        <definition>typedef Eigen::Map&lt;iDynTreeEigenMatrix&gt; iDynTree::iDynTreeEigenMatrixMap</definition>
        <argsstring></argsstring>
        <name>iDynTreeEigenMatrixMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="32" column="24" bodyfile="iDynTree/EigenHelpers.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="EigenHelpers_8h_1a2b2522205c120424f4e8740b30bad6aa" prot="public" static="no">
        <type>Eigen::Map&lt; iDynTreeEigenConstMatrix &gt;</type>
        <definition>typedef Eigen::Map&lt;iDynTreeEigenConstMatrix&gt; iDynTree::iDynTreeEigenConstMatrixMap</definition>
        <argsstring></argsstring>
        <name>iDynTreeEigenConstMatrixMap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="33" column="24" bodyfile="iDynTree/EigenHelpers.h" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1ad00786c331484214ec14e850f805602f" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">GeomVector3</ref></type>
        <definition>typedef GeomVector3 iDynTree::LinearMotionVector3</definition>
        <argsstring></argsstring>
        <name>LinearMotionVector3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="31" column="21" bodyfile="iDynTree/GeomVector3.h" bodystart="31" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1a408c1ac9b6f50b7425becd9b7b20f351" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">LinearMotionVector3</ref></type>
        <definition>typedef LinearMotionVector3 iDynTree::LinVelocity</definition>
        <argsstring></argsstring>
        <name>LinVelocity</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="32" column="29" bodyfile="iDynTree/GeomVector3.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1aff2ac4b45bb6926622fcfbf47dbe82b1" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">GeomVector3</ref></type>
        <definition>typedef GeomVector3 iDynTree::AngularMotionVector3</definition>
        <argsstring></argsstring>
        <name>AngularMotionVector3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="34" column="21" bodyfile="iDynTree/GeomVector3.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1adb7dac766ffa576a0213970d650eda15" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">AngularMotionVector3</ref></type>
        <definition>typedef AngularMotionVector3 iDynTree::AngAcceleration</definition>
        <argsstring></argsstring>
        <name>AngAcceleration</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="36" column="30" bodyfile="iDynTree/GeomVector3.h" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1a220a484dfbd1e54951ef1aaf24ecd80c" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">GeomVector3</ref></type>
        <definition>typedef GeomVector3 iDynTree::LinearForceVector3</definition>
        <argsstring></argsstring>
        <name>LinearForceVector3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="37" column="21" bodyfile="iDynTree/GeomVector3.h" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1ac0ebd34fab318a785581c07d73cdffc4" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">LinearForceVector3</ref></type>
        <definition>typedef LinearForceVector3 iDynTree::LinMomentum</definition>
        <argsstring></argsstring>
        <name>LinMomentum</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="38" column="28" bodyfile="iDynTree/GeomVector3.h" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1a4c842c5e7d2f44d3352ffd8b59203d77" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">LinearForceVector3</ref></type>
        <definition>typedef LinearForceVector3 iDynTree::Force</definition>
        <argsstring></argsstring>
        <name>Force</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="39" column="28" bodyfile="iDynTree/GeomVector3.h" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1a3338ebb24d8da845c73135e66d6c6b78" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">GeomVector3</ref></type>
        <definition>typedef GeomVector3 iDynTree::AngularForceVector3</definition>
        <argsstring></argsstring>
        <name>AngularForceVector3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="40" column="21" bodyfile="iDynTree/GeomVector3.h" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1a55b4eeede0026f5a9ff630bf0e185f1a" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">AngularForceVector3</ref></type>
        <definition>typedef AngularForceVector3 iDynTree::AngMomentum</definition>
        <argsstring></argsstring>
        <name>AngMomentum</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="41" column="29" bodyfile="iDynTree/GeomVector3.h" bodystart="41" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1a6201e5c8d3cc72533773d11302674f5c" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">AngularForceVector3</ref></type>
        <definition>typedef AngularForceVector3 iDynTree::Torque</definition>
        <argsstring></argsstring>
        <name>Torque</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="42" column="29" bodyfile="iDynTree/GeomVector3.h" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="GeomVector3_8h_1aaaf9fe3261e02ce6de58a3e752e6f891" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1GeomVector3" kindref="compound">GeomVector3</ref></type>
        <definition>typedef GeomVector3 iDynTree::MotionVector3</definition>
        <argsstring></argsstring>
        <name>MotionVector3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/GeomVector3.h" line="43" column="21" bodyfile="iDynTree/GeomVector3.h" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MatrixFixSize_8h_1a3f95b4a0200fda604f7717bcb0781b89" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 1, 6 &gt;</type>
        <definition>typedef MatrixFixSize&lt;1,6&gt; iDynTree::Matrix1x6</definition>
        <argsstring></argsstring>
        <name>Matrix1x6</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixFixSize.h" line="367" column="27" bodyfile="iDynTree/MatrixFixSize.h" bodystart="367" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MatrixFixSize_8h_1a2502487a002cb2aec7b06190dfd1e787" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 2, 3 &gt;</type>
        <definition>typedef MatrixFixSize&lt;2,3&gt; iDynTree::Matrix2x3</definition>
        <argsstring></argsstring>
        <name>Matrix2x3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixFixSize.h" line="368" column="27" bodyfile="iDynTree/MatrixFixSize.h" bodystart="368" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MatrixFixSize_8h_1a1ab8ab0012e12e66db217bb4845881cf" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 3, 3 &gt;</type>
        <definition>typedef MatrixFixSize&lt;3,3&gt; iDynTree::Matrix3x3</definition>
        <argsstring></argsstring>
        <name>Matrix3x3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixFixSize.h" line="369" column="27" bodyfile="iDynTree/MatrixFixSize.h" bodystart="369" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MatrixFixSize_8h_1a739bd7039fa167036447689c29104cb4" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 4, 4 &gt;</type>
        <definition>typedef MatrixFixSize&lt;4,4&gt; iDynTree::Matrix4x4</definition>
        <argsstring></argsstring>
        <name>Matrix4x4</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixFixSize.h" line="370" column="27" bodyfile="iDynTree/MatrixFixSize.h" bodystart="370" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MatrixFixSize_8h_1aa8530f3c198c90d18ec29e68f4d5e5fc" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 6, 1 &gt;</type>
        <definition>typedef MatrixFixSize&lt;6,1&gt; iDynTree::Matrix6x1</definition>
        <argsstring></argsstring>
        <name>Matrix6x1</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixFixSize.h" line="371" column="27" bodyfile="iDynTree/MatrixFixSize.h" bodystart="371" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MatrixFixSize_8h_1ad298b89bf01794a5de35a255dd269d52" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 6, 6 &gt;</type>
        <definition>typedef MatrixFixSize&lt;6,6&gt; iDynTree::Matrix6x6</definition>
        <argsstring></argsstring>
        <name>Matrix6x6</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixFixSize.h" line="372" column="27" bodyfile="iDynTree/MatrixFixSize.h" bodystart="372" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MatrixFixSize_8h_1a6d63b01d7d6de76185f849d32b9fbd29" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 6, 10 &gt;</type>
        <definition>typedef MatrixFixSize&lt;6,10&gt; iDynTree::Matrix6x10</definition>
        <argsstring></argsstring>
        <name>Matrix6x10</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixFixSize.h" line="373" column="27" bodyfile="iDynTree/MatrixFixSize.h" bodystart="373" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="MatrixFixSize_8h_1ad7bb9ef7fdaadb16f95a6e42cf32d622" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 10, 16 &gt;</type>
        <definition>typedef MatrixFixSize&lt;10,16&gt; iDynTree::Matrix10x16</definition>
        <argsstring></argsstring>
        <name>Matrix10x16</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixFixSize.h" line="374" column="27" bodyfile="iDynTree/MatrixFixSize.h" bodystart="374" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="VectorFixSize_8h_1a60f2b9c49979e66bbc9fd83dba192e07" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; 2 &gt;</type>
        <definition>typedef VectorFixSize&lt;2&gt; iDynTree::Vector2</definition>
        <argsstring></argsstring>
        <name>Vector2</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/VectorFixSize.h" line="391" column="28" bodyfile="iDynTree/VectorFixSize.h" bodystart="391" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="VectorFixSize_8h_1a6ba91315448cf1d275f460097e36d134" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; 3 &gt;</type>
        <definition>typedef VectorFixSize&lt;3&gt; iDynTree::Vector3</definition>
        <argsstring></argsstring>
        <name>Vector3</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/VectorFixSize.h" line="392" column="28" bodyfile="iDynTree/VectorFixSize.h" bodystart="392" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="VectorFixSize_8h_1a9827b82ba400214bc1c3f0a2714aee0a" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; 4 &gt;</type>
        <definition>typedef VectorFixSize&lt;4&gt; iDynTree::Vector4</definition>
        <argsstring></argsstring>
        <name>Vector4</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/VectorFixSize.h" line="393" column="28" bodyfile="iDynTree/VectorFixSize.h" bodystart="393" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="VectorFixSize_8h_1aacbdf066949a170899a2e43ad52987d8" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; 6 &gt;</type>
        <definition>typedef VectorFixSize&lt;6&gt; iDynTree::Vector6</definition>
        <argsstring></argsstring>
        <name>Vector6</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/VectorFixSize.h" line="394" column="28" bodyfile="iDynTree/VectorFixSize.h" bodystart="394" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="VectorFixSize_8h_1a658ee3743c3ccf3d61c38e4fa1c81ec9" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; 10 &gt;</type>
        <definition>typedef VectorFixSize&lt;10&gt; iDynTree::Vector10</definition>
        <argsstring></argsstring>
        <name>Vector10</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/VectorFixSize.h" line="395" column="27" bodyfile="iDynTree/VectorFixSize.h" bodystart="395" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="VectorFixSize_8h_1a68b87219f8e66c52f9d5de9d84aef7c9" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; 16 &gt;</type>
        <definition>typedef VectorFixSize&lt;16&gt; iDynTree::Vector16</definition>
        <argsstring></argsstring>
        <name>Vector16</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/VectorFixSize.h" line="396" column="27" bodyfile="iDynTree/VectorFixSize.h" bodystart="396" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="AttitudeEstimator_8h_1adcfa60b3d3580f517fd47c8864534b36" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::Vector3</ref></type>
        <definition>typedef iDynTree::Vector3 iDynTree::LinearAccelerometerMeasurements</definition>
        <argsstring></argsstring>
        <name>LinearAccelerometerMeasurements</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AttitudeEstimator.h" line="14" column="31" bodyfile="iDynTree/AttitudeEstimator.h" bodystart="14" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="AttitudeEstimator_8h_1a94dcb1f9c90a22269981469e229ed6ce" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::Vector3</ref></type>
        <definition>typedef iDynTree::Vector3 iDynTree::GyroscopeMeasurements</definition>
        <argsstring></argsstring>
        <name>GyroscopeMeasurements</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AttitudeEstimator.h" line="15" column="31" bodyfile="iDynTree/AttitudeEstimator.h" bodystart="15" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="AttitudeEstimator_8h_1ad170eb4fd0bd13bfb0bdbdb6460d28bc" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::Vector3</ref></type>
        <definition>typedef iDynTree::Vector3 iDynTree::MagnetometerMeasurements</definition>
        <argsstring></argsstring>
        <name>MagnetometerMeasurements</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AttitudeEstimator.h" line="16" column="31" bodyfile="iDynTree/AttitudeEstimator.h" bodystart="16" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="AttitudeEstimator_8h_1a8953e202971beb38867767ab9f002c42" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::Vector4</ref></type>
        <definition>typedef iDynTree::Vector4 iDynTree::UnitQuaternion</definition>
        <argsstring></argsstring>
        <name>UnitQuaternion</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AttitudeEstimator.h" line="18" column="31" bodyfile="iDynTree/AttitudeEstimator.h" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="AttitudeEstimator_8h_1a48e2955e462d28103d57a10634d0654d" prot="public" static="no">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::Vector3</ref></type>
        <definition>typedef iDynTree::Vector3 iDynTree::RPY</definition>
        <argsstring></argsstring>
        <name>RPY</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AttitudeEstimator.h" line="19" column="31" bodyfile="iDynTree/AttitudeEstimator.h" bodystart="19" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="Indices_8h_1abb454ae2b12be8622ba842c70450352d" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT LinkIndex</type>
        <definition>IDYNTREE_MODEL_EXPORT LinkIndex iDynTree::LINK_INVALID_INDEX</definition>
        <argsstring></argsstring>
        <name>LINK_INVALID_INDEX</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="20" column="44" declfile="iDynTree/Indices.h" declline="20" declcolumn="44"/>
      </memberdef>
      <memberdef kind="variable" id="Indices_8h_1a159509c5b039dff9c6d63dd349e5b11b" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT std::string</type>
        <definition>IDYNTREE_MODEL_EXPORT std::string iDynTree::LINK_INVALID_NAME</definition>
        <argsstring></argsstring>
        <name>LINK_INVALID_NAME</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="21" column="46" declfile="iDynTree/Indices.h" declline="21" declcolumn="46"/>
      </memberdef>
      <memberdef kind="variable" id="Indices_8h_1a00a66679a08e686adb0ee06a7bd1aabc" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT std::ptrdiff_t</type>
        <definition>IDYNTREE_MODEL_EXPORT std::ptrdiff_t iDynTree::JOINT_INVALID_INDEX</definition>
        <argsstring></argsstring>
        <name>JOINT_INVALID_INDEX</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="24" column="49" declfile="iDynTree/Indices.h" declline="24" declcolumn="49"/>
      </memberdef>
      <memberdef kind="variable" id="Indices_8h_1aeead77d4aba2563231da9fcda8ffa415" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT std::string</type>
        <definition>IDYNTREE_MODEL_EXPORT std::string iDynTree::JOINT_INVALID_NAME</definition>
        <argsstring></argsstring>
        <name>JOINT_INVALID_NAME</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="25" column="46" declfile="iDynTree/Indices.h" declline="25" declcolumn="46"/>
      </memberdef>
      <memberdef kind="variable" id="Indices_8h_1ab7a1cc7b2d03127963a3d2661c8ccdcc" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT std::ptrdiff_t</type>
        <definition>IDYNTREE_MODEL_EXPORT std::ptrdiff_t iDynTree::DOF_INVALID_INDEX</definition>
        <argsstring></argsstring>
        <name>DOF_INVALID_INDEX</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="28" column="49" declfile="iDynTree/Indices.h" declline="28" declcolumn="49"/>
      </memberdef>
      <memberdef kind="variable" id="Indices_8h_1ab0ace312f6cbe8ee7fd51549a9caf79f" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT std::string</type>
        <definition>IDYNTREE_MODEL_EXPORT std::string iDynTree::DOF_INVALID_NAME</definition>
        <argsstring></argsstring>
        <name>DOF_INVALID_NAME</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="29" column="46" declfile="iDynTree/Indices.h" declline="29" declcolumn="46"/>
      </memberdef>
      <memberdef kind="variable" id="Indices_8h_1a1a81b3c4ae6873a80debbb71bdc43218" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT std::ptrdiff_t</type>
        <definition>IDYNTREE_MODEL_EXPORT std::ptrdiff_t iDynTree::FRAME_INVALID_INDEX</definition>
        <argsstring></argsstring>
        <name>FRAME_INVALID_INDEX</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="32" column="49" declfile="iDynTree/Indices.h" declline="32" declcolumn="49"/>
      </memberdef>
      <memberdef kind="variable" id="Indices_8h_1a6d57d4391d58c8fd9470846d4a72118f" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT std::string</type>
        <definition>IDYNTREE_MODEL_EXPORT std::string iDynTree::FRAME_INVALID_NAME</definition>
        <argsstring></argsstring>
        <name>FRAME_INVALID_NAME</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="33" column="46" declfile="iDynTree/Indices.h" declline="33" declcolumn="46"/>
      </memberdef>
      <memberdef kind="variable" id="Indices_8h_1a1ceb2215b00eb2c21af358eb9b7d88f4" prot="public" static="no" mutable="no">
        <type>IDYNTREE_MODEL_EXPORT TraversalIndex</type>
        <definition>IDYNTREE_MODEL_EXPORT TraversalIndex iDynTree::TRAVERSAL_INVALID_INDEX</definition>
        <argsstring></argsstring>
        <name>TRAVERSAL_INVALID_INDEX</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Indices.h" line="36" column="49" declfile="iDynTree/Indices.h" declline="36" declcolumn="49"/>
      </memberdef>
      <memberdef kind="variable" id="Sensors_8h_1a27f6da1749325b5fabe94ceb7278f0df" prot="public" static="no" mutable="no">
        <type>const int</type>
        <definition>const int iDynTree::NR_OF_SENSOR_TYPES</definition>
        <argsstring></argsstring>
        <name>NR_OF_SENSOR_TYPES</name>
        <initializer>= 5</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Sensors.h" line="39" column="15" bodyfile="iDynTree/Sensors.h" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="Span_8h_1a10c045523612bc8183a496020fecf982" prot="public" static="no" mutable="no">
        <type>IDYNTREE_CONSTEXPR const std::ptrdiff_t</type>
        <definition>IDYNTREE_CONSTEXPR const std::ptrdiff_t iDynTree::dynamic_extent</definition>
        <argsstring></argsstring>
        <name>dynamic_extent</name>
        <initializer>= -1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="123" column="41" bodyfile="iDynTree/Span.h" bodystart="123" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="Utils_8h_1a09f55e26767f7112939284cfcea999f7" prot="public" static="no" mutable="no">
        <type>IDYNTREE_CORE_EXPORT int</type>
        <definition>IDYNTREE_CORE_EXPORT int iDynTree::UNKNOWN</definition>
        <argsstring></argsstring>
        <name>UNKNOWN</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="39" column="37" declfile="iDynTree/Utils.h" declline="39" declcolumn="37"/>
      </memberdef>
      <memberdef kind="variable" id="Utils_8h_1abe71efaac97b8e18f842ccc49d07026a" prot="public" static="no" mutable="no">
        <type>IDYNTREE_CORE_EXPORT double</type>
        <definition>IDYNTREE_CORE_EXPORT double iDynTree::DEFAULT_TOL</definition>
        <argsstring></argsstring>
        <name>DEFAULT_TOL</name>
        <briefdescription>
<para>Default tolerance for methods with a tolerance, setted to 1e-10. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="42" column="40" declfile="iDynTree/Utils.h" declline="42" declcolumn="40"/>
      </memberdef>
      <memberdef kind="variable" id="AttitudeQuaternionEKF_8h_1a0dd93cfe8edb7763d1f57d6454c1c25f" prot="public" static="no" mutable="no">
        <type>const unsigned int</type>
        <definition>const unsigned int iDynTree::output_dimensions_with_magnetometer</definition>
        <argsstring></argsstring>
        <name>output_dimensions_with_magnetometer</name>
        <initializer>= 4</initializer>
        <briefdescription>
<para>dimension of <formula id="203">$ \mathbb{R}^3 \times \mathbb{R} $</formula> accelerometer measurements and magnetometer yaw measurement </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AttitudeQuaternionEKF.h" line="13" column="24" bodyfile="iDynTree/AttitudeQuaternionEKF.h" bodystart="13" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="AttitudeQuaternionEKF_8h_1a8772fb8ad891bd276db791f2e815de11" prot="public" static="no" mutable="no">
        <type>const unsigned int</type>
        <definition>const unsigned int iDynTree::output_dimensions_without_magnetometer</definition>
        <argsstring></argsstring>
        <name>output_dimensions_without_magnetometer</name>
        <initializer>= 3</initializer>
        <briefdescription>
<para>dimension of <formula id="169">$ \mathbb{R}^3 $</formula> accelerometer measurements </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AttitudeQuaternionEKF.h" line="14" column="24" bodyfile="iDynTree/AttitudeQuaternionEKF.h" bodystart="14" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="AttitudeQuaternionEKF_8h_1ae4a3a4ece8b00835bf57f387795ba015" prot="public" static="no" mutable="no">
        <type>const unsigned int</type>
        <definition>const unsigned int iDynTree::input_dimensions</definition>
        <argsstring></argsstring>
        <name>input_dimensions</name>
        <initializer>= 3</initializer>
        <briefdescription>
<para>dimension of <formula id="169">$ \mathbb{R}^3 $</formula> gyroscope measurements </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/AttitudeQuaternionEKF.h" line="15" column="24" bodyfile="iDynTree/AttitudeQuaternionEKF.h" bodystart="15" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="DenavitHartenberg_8h_1a9f5fda0dc8377f9fad3f8b60d73f1c7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref></type>
        <definition>Transform iDynTree::TransformFromDHCraig1989</definition>
        <argsstring>(double a, double alpha, double d, double theta)</argsstring>
        <name>TransformFromDHCraig1989</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>double</type>
          <declname>d</declname>
        </param>
        <param>
          <type>double</type>
          <declname>theta</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/DenavitHartenberg.h" line="138" column="11" declfile="iDynTree/DenavitHartenberg.h" declline="138" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="DenavitHartenberg_8h_1a259b4c68b0f4b9ae9ce389ed14f4c712" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref></type>
        <definition>Transform iDynTree::TransformFromDH</definition>
        <argsstring>(double a, double alpha, double d, double theta)</argsstring>
        <name>TransformFromDH</name>
        <param>
          <type>double</type>
          <declname>a</declname>
        </param>
        <param>
          <type>double</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>double</type>
          <declname>d</declname>
        </param>
        <param>
          <type>double</type>
          <declname>theta</declname>
        </param>
        <briefdescription>
<para>DH : constructs a transformationmatrix T_link(i-1)_link(i) with the Denavit-Hartenberg convention as described in the original publictation: Denavit, J. </para>
        </briefdescription>
        <detaileddescription>
<para>and Hartenberg, R. S., A kinematic notation for lower-pair mechanisms based on matrices, ASME Journal of Applied Mechanics, 23:215-221, 1955.</para>
<para>Function compatible on KDL&apos;s Frame::DH method. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/DenavitHartenberg.h" line="149" column="11" declfile="iDynTree/DenavitHartenberg.h" declline="149" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="DenavitHartenberg_8h_1ada11245ee6d17f4d64ccf59eeead8f07" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ExtractDHChainFromModel</definition>
        <argsstring>(const iDynTree::Model &amp;model, const std::string baseFrame, const std::string eeFrame, DHChain &amp;outputChain, double tolerance=1e-5)</argsstring>
        <name>ExtractDHChainFromModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const std::string</type>
          <declname>baseFrame</declname>
        </param>
        <param>
          <type>const std::string</type>
          <declname>eeFrame</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1DHChain" kindref="compound">DHChain</ref> &amp;</type>
          <declname>outputChain</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tolerance</declname>
          <defval>1e-5</defval>
        </param>
        <briefdescription>
<para>Extract a Denavit Hartenberg Chain from a <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>In particular you can specify the base frame and the end effector frame of the chain. The chain is then extracted using the algorithm found in: Chapter 3, Spong, Mark W., Seth Hutchinson, and M. Vidyasagar. &quot;Robot modeling and control&quot;. 2006. (section 3.2.3 of <ulink url="http://www.cs.duke.edu/brd/Teaching/Bio/asmb/current/Papers/chap3-forward-kinematics.pdf">http://www.cs.duke.edu/brd/Teaching/Bio/asmb/current/Papers/chap3-forward-kinematics.pdf</ulink>)</para>
<para><simplesect kind="note"><para>The DH representation supports only revolute and translational 1-DOF joints. In this implementation only revolute joints are supported. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/DenavitHartenberg.h" line="162" column="6" declfile="iDynTree/DenavitHartenberg.h" declline="162" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="DenavitHartenberg_8h_1ac94534b93496e2703a218b38774c64a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::CreateModelFromDHChain</definition>
        <argsstring>(const DHChain &amp;inputChain, Model &amp;outputModel)</argsstring>
        <name>CreateModelFromDHChain</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1DHChain" kindref="compound">DHChain</ref> &amp;</type>
          <declname>inputChain</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>outputModel</declname>
        </param>
        <briefdescription>
<para>Create an <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> from a <ref refid="classiDynTree_1_1DHChain" kindref="compound">DHChain</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>The names of the links will be link0, link1, ... linkN, furthermore there are two additional frame for the base and endEffector frames, named baseFrame and distalFrame . </para>
</simplesect>
<simplesect kind="note"><para>The inertia of the links will be set to 1 kg in the origin of the link.</para>
</simplesect>
<simplesect kind="return"><para>true if all went ok, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/DenavitHartenberg.h" line="178" column="6" declfile="iDynTree/DenavitHartenberg.h" declline="178" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModel_1ga1f433a6725585332945762ed4e6b5fe5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ComputeLinearAndAngularMomentum</definition>
        <argsstring>(const Model &amp;model, const LinkPositions &amp;linkPositions, const LinkVelArray &amp;linkVels, SpatialMomentum &amp;totalMomentum)</argsstring>
        <name>ComputeLinearAndAngularMomentum</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>linkPositions</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVels</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SpatialMomentum" kindref="compound">SpatialMomentum</ref> &amp;</type>
          <declname>totalMomentum</declname>
        </param>
        <briefdescription>
<para>Compute the total linear and angular momentum of a robot, expressed in the world frame. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the used model, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkPositions</parametername>
</parameternamelist>
<parameterdescription>
<para>linkPositions(l) contains the world_H_link transform. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkVels</parametername>
</parameternamelist>
<parameterdescription>
<para>linkVels(l) contains the link l velocity expressed in l frame. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">totalMomentum</parametername>
</parameternamelist>
<parameterdescription>
<para>total momentum, expressed in world frame. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went well, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Dynamics.h" line="38" column="10" declfile="iDynTree/Dynamics.h" declline="38" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Dynamics_8h_1ae214683bf9d037ee89a0c070ed9ed78d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ComputeLinearAndAngularMomentumDerivativeBias</definition>
        <argsstring>(const Model &amp;model, const LinkPositions &amp;linkPositions, const LinkVelArray &amp;linkVel, const LinkAccArray &amp;linkBiasAcc, Wrench &amp;totalMomentumBias)</argsstring>
        <name>ComputeLinearAndAngularMomentumDerivativeBias</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>linkPositions</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>linkBiasAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Wrench" kindref="compound">Wrench</ref> &amp;</type>
          <declname>totalMomentumBias</declname>
        </param>
        <briefdescription>
<para>Compute the total momentum derivatitive bias, i.e. </para>
        </briefdescription>
        <detaileddescription>
<para>the part of the total momentum derivative that does not depend on robot acceleration.</para>
<para>The linear and angular momentum derivative depends on the robot position, velocity and acceleration. This function computes the part that do not depend on the robot accelearation.</para>
<para>This function returns the bias of the derivative of the ComputeLinearAndAngularMomentum function. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Dynamics.h" line="51" column="10" declfile="iDynTree/Dynamics.h" declline="51" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModel_1ga18613d41830aef7430e7a8a09fef98e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::RNEADynamicPhase</definition>
        <argsstring>(const iDynTree::Model &amp;model, const iDynTree::Traversal &amp;traversal, const iDynTree::JointPosDoubleArray &amp;jointPos, const iDynTree::LinkVelArray &amp;linksVel, const iDynTree::LinkAccArray &amp;linksProperAcc, const iDynTree::LinkNetExternalWrenches &amp;linkExtForces, iDynTree::LinkInternalWrenches &amp;linkIntWrenches, iDynTree::FreeFloatingGeneralizedTorques &amp;baseForceAndJointTorques)</argsstring>
        <name>RNEADynamicPhase</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">iDynTree::Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">iDynTree::JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">iDynTree::LinkVelArray</ref> &amp;</type>
          <declname>linksVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">iDynTree::LinkAccArray</ref> &amp;</type>
          <declname>linksProperAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">iDynTree::LinkNetExternalWrenches</ref> &amp;</type>
          <declname>linkExtForces</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">iDynTree::LinkInternalWrenches</ref> &amp;</type>
          <declname>linkIntWrenches</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingGeneralizedTorques" kindref="compound">iDynTree::FreeFloatingGeneralizedTorques</ref> &amp;</type>
          <declname>baseForceAndJointTorques</declname>
        </param>
        <briefdescription>
<para>Compute the inverse dynamics, i.e. </para>
        </briefdescription>
        <detaileddescription>
<para>the generalized torques corresponding to a given set of robot accelerations and external force/torques.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>The model used for the computation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>The traversal used for the computation, it defines the used base link. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointPos</parametername>
</parameternamelist>
<parameterdescription>
<para>The (internal) joint position of the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linksVel</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of left-trivialized velocities for each link of the model (for each link <formula id="0">$L$</formula>, the corresponding velocity is <formula id="1">${}^L \mathrm{v}_{A, L}$</formula>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linksProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of left-trivialized proper acceleration for each link of the model (for each link <formula id="0">$L$</formula>, the corresponding proper acceleration is <formula id="2">${}^L \dot{\mathrm{v}}_{A, L} - \begin{bmatrix} {}^L R_A {}^A g \\ 0_{3\times1} \end{bmatrix} $</formula>), where <formula id="3">$ {}^A g \in \mathbb{R}^3 $</formula> is the gravity acceleration expressed in an inertial frame <formula id="4">$A$</formula> . See iDynTree::LinkNetExternalWrenches . </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkExtForces</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of external 6D force/torques applied to the links. For each link <formula id="0">$L$</formula>, the corresponding external force is <formula id="5">${}_L \mathrm{f}^x_L$</formula>, i.e. the force that the enviroment applies on the on the link <formula id="0">$L$</formula>, expressed in the link frame <formula id="0">$L$</formula>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">linkIntWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of internal joint force/torques. See iDynTree::LinkInternalWrenches . </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">baseForceAndJointTorques</parametername>
</parameternamelist>
<parameterdescription>
<para>Generalized torques output. The base element is the residual force on the base (that is equal to zero if the robot acceleration and the external forces provided in LinkNetExternalWrenches were consistent), while the joint part is composed by the joint torques. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Dynamics.h" line="72" column="10" declfile="iDynTree/Dynamics.h" declline="72" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Dynamics_8h_1afa4f3546edbb4ab3e50a486e316a2470" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::CompositeRigidBodyAlgorithm</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const JointPosDoubleArray &amp;jointPos, LinkCompositeRigidBodyInertias &amp;linkCRBs, FreeFloatingMassMatrix &amp;massMatrix)</argsstring>
        <name>CompositeRigidBodyAlgorithm</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkInertias" kindref="compound">LinkCompositeRigidBodyInertias</ref> &amp;</type>
          <declname>linkCRBs</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingMassMatrix" kindref="compound">FreeFloatingMassMatrix</ref> &amp;</type>
          <declname>massMatrix</declname>
        </param>
        <briefdescription>
<para>Compute the floating base mass matrix, using the composite rigid body algorithm. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Dynamics.h" line="86" column="10" declfile="iDynTree/Dynamics.h" declline="86" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModel_1ga5879141982887fc0d049cc3645f10dd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ArticulatedBodyAlgorithm</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const FreeFloatingPos &amp;robotPos, const FreeFloatingVel &amp;robotVel, const LinkNetExternalWrenches &amp;linkExtWrenches, const JointDOFsDoubleArray &amp;jointTorques, ArticulatedBodyAlgorithmInternalBuffers &amp;buffers, FreeFloatingAcc &amp;robotAcc)</argsstring>
        <name>ArticulatedBodyAlgorithm</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkNetExternalWrenches</ref> &amp;</type>
          <declname>linkExtWrenches</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointDOFsDoubleArray" kindref="compound">JointDOFsDoubleArray</ref> &amp;</type>
          <declname>jointTorques</declname>
        </param>
        <param>
          <type><ref refid="structiDynTree_1_1ArticulatedBodyAlgorithmInternalBuffers" kindref="compound">ArticulatedBodyAlgorithmInternalBuffers</ref> &amp;</type>
          <declname>buffers</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">FreeFloatingAcc</ref> &amp;</type>
          <declname>robotAcc</declname>
        </param>
        <briefdescription>
<para>Compute the floating base acceleration of an unconstrianed robot, using as input the external forces and the joint torques. </para>
        </briefdescription>
        <detaileddescription>
<para>We follow the algorithm described in Featherstone 2008, modified for the floating base case and for handling fixed joints. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Dynamics.h" line="147" column="10" declfile="iDynTree/Dynamics.h" declline="147" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModel_1ga0c75db73b7682b9c524b0727b516b12b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::InverseDynamicsInertialParametersRegressor</definition>
        <argsstring>(const iDynTree::Model &amp;model, const iDynTree::Traversal &amp;traversal, const iDynTree::LinkPositions &amp;referenceFrame_H_link, const iDynTree::LinkVelArray &amp;linksVel, const iDynTree::LinkAccArray &amp;linksAcc, iDynTree::MatrixDynSize &amp;baseForceAndJointTorquesRegressor)</argsstring>
        <name>InverseDynamicsInertialParametersRegressor</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">iDynTree::Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkPositions" kindref="compound">iDynTree::LinkPositions</ref> &amp;</type>
          <declname>referenceFrame_H_link</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">iDynTree::LinkVelArray</ref> &amp;</type>
          <declname>linksVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">iDynTree::LinkAccArray</ref> &amp;</type>
          <declname>linksAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1MatrixDynSize" kindref="compound">iDynTree::MatrixDynSize</ref> &amp;</type>
          <declname>baseForceAndJointTorquesRegressor</declname>
        </param>
        <briefdescription>
<para>Compute the inverse dynamics of the model as linear function of the inertial parameters. </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes the matrix that multiplied by the vector of inertial parameters of a model (see <ref refid="classiDynTree_1_1Model_1a2c283e000a2d6a5e86770d8616b7e18b" kindref="member">iDynTree::Model::getInertialParameters</ref>) returns the inverse dynamics generalized torques. In particular it is consistent with the result of the iDynTree::RNEADynamicPhase function, i.e. the first six rows of the regressor correspond to the sum of all external force/torques acting on the robot, expressed in the origin and with the orientation of the specified referenceFrame, as defined by the referenceFrame_H_link argument.</para>
<para><simplesect kind="note"><para>The regressor only computes the inverse dynamics generalized torques assuming that the external forces are equal to zero, as the contribution of the external forces to the inverse dynamics is indipendent from inertial parameters.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>The model used for the computation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>The traversal used for the computation, it defines the used base link. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">referenceFrame_H_link</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> of each link w.r.t. to given frame D (tipically an inertial frame A, the base frame B or the mixed frame B[A]). For each link <formula id="0">$L$</formula>, the corresponding transform is <formula id="6">${}^D H_L$</formula>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linksVel</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of left-trivialized velocities for each link of the model (for each link <formula id="0">$L$</formula>, the corresponding velocity is <formula id="1">${}^L \mathrm{v}_{A, L}$</formula>). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linksProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of left-trivialized proper acceleration for each link of the model (for each link <formula id="0">$L$</formula>, the corresponding proper acceleration is <formula id="2">${}^L \dot{\mathrm{v}}_{A, L} - \begin{bmatrix} {}^L R_A {}^A g \\ 0_{3\times1} \end{bmatrix} $</formula>), where <formula id="3">$ {}^A g \in \mathbb{R}^3 $</formula> is the gravity acceleration expressed in an inertial frame <formula id="4">$A$</formula> . </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">baseForceAndJointTorquesRegressor</parametername>
</parameternamelist>
<parameterdescription>
<para>The (6+model.getNrOfDOFs() X 10*model.getNrOfLinks()) inverse dynamics regressor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Dynamics.h" line="180" column="10" declfile="iDynTree/Dynamics.h" declline="180" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="DynamicsLinearization_8h_1a0c9b6d083f99f1b6ffd1a6c3a7ae5e07" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardDynamicsLinearization</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const FreeFloatingPos &amp;robotPos, const FreeFloatingVel &amp;robotVel, const LinkNetExternalWrenches &amp;linkExtWrenches, const JointDOFsDoubleArray &amp;jointTorques, ForwardDynamicsLinearizationInternalBuffers &amp;bufs, FreeFloatingAcc &amp;robotAcc, FreeFloatingStateLinearization &amp;A)</argsstring>
        <name>ForwardDynamicsLinearization</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkNetExternalWrenches</ref> &amp;</type>
          <declname>linkExtWrenches</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointDOFsDoubleArray" kindref="compound">JointDOFsDoubleArray</ref> &amp;</type>
          <declname>jointTorques</declname>
        </param>
        <param>
          <type><ref refid="structiDynTree_1_1ForwardDynamicsLinearizationInternalBuffers" kindref="compound">ForwardDynamicsLinearizationInternalBuffers</ref> &amp;</type>
          <declname>bufs</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">FreeFloatingAcc</ref> &amp;</type>
          <declname>robotAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingStateLinearization" kindref="compound">FreeFloatingStateLinearization</ref> &amp;</type>
          <declname>A</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/DynamicsLinearization.h" line="89" column="10" declfile="iDynTree/DynamicsLinearization.h" declline="89" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="DynamicsLinearizationHelpers_8h_1a8f92a6a26be06461e7364405c553bd66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialMotionWrtMotionDerivative" kindref="compound">SpatialMotionWrtMotionDerivative</ref></type>
        <definition>SpatialMotionWrtMotionDerivative iDynTree::operator*</definition>
        <argsstring>(const Transform &amp;a_X_b, const SpatialMotionWrtMotionDerivative &amp;op2)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>a_X_b</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMotionWrtMotionDerivative" kindref="compound">SpatialMotionWrtMotionDerivative</ref> &amp;</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
<para>Equivalent to: </para>
        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">SpatialForceWrtMotionDerivative<sp/>ret;</highlight></codeline>
<codeline><highlight class="normal">toEigen(ret)<sp/>=<sp/>toEigen(transform.asAdjointMatrixWrench())*toEigen(ret);</highlight></codeline>
<codeline><highlight class="normal">return<sp/>ret;</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/DynamicsLinearizationHelpers.h" line="43" column="38" declfile="iDynTree/DynamicsLinearizationHelpers.h" declline="43" declcolumn="38"/>
      </memberdef>
      <memberdef kind="function" id="DynamicsLinearizationHelpers_8h_1aedfbcb0d62ea5bb9bf6fc476f3cc717a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialForceWrtMotionDerivative" kindref="compound">SpatialForceWrtMotionDerivative</ref></type>
        <definition>SpatialForceWrtMotionDerivative iDynTree::operator*</definition>
        <argsstring>(const Transform &amp;a_X_b, const SpatialForceWrtMotionDerivative &amp;op2)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>a_X_b</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialForceWrtMotionDerivative" kindref="compound">SpatialForceWrtMotionDerivative</ref> &amp;</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
<para>Equivalent to: </para>
        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">SpatialForceWrtMotionDerivative<sp/>ret;</highlight></codeline>
<codeline><highlight class="normal">toEigen(ret)<sp/>=<sp/>toEigen(transform.asAdjointMatrixWrench())*toEigen(ret);</highlight></codeline>
<codeline><highlight class="normal">return<sp/>ret;</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/DynamicsLinearizationHelpers.h" line="77" column="38" declfile="iDynTree/DynamicsLinearizationHelpers.h" declline="77" declcolumn="38"/>
      </memberdef>
      <memberdef kind="function" id="DynamicsUtils_8h_1aed28749437ab0ff261382d34506ffad4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::biasWrenchVelocityDerivative</definition>
        <argsstring>(SpatialInertia M, SpatialMotionVector V)</argsstring>
        <name>biasWrenchVelocityDerivative</name>
        <param>
          <type><ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref></type>
          <declname>M</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref></type>
          <declname>V</declname>
        </param>
        <briefdescription>
<para>Given a rigid body inertia <formula id="8">$M$</formula> and spatial motion vector <formula id="9">$V$</formula>, the bias wrench <formula id="10">$B$</formula> of rigid body is defined as: </para>
        </briefdescription>
        <detaileddescription>
<para><formula id="11">\[ B = \times \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/DynamicsUtils.h" line="21" column="5" declfile="iDynTree/DynamicsUtils.h" declline="21" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModel_1ga41ad76666d447a42318ab5778b3ad18e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardPositionKinematics</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const Transform &amp;worldHbase, const VectorDynSize &amp;jointPositions, LinkPositions &amp;linkPositions)</argsstring>
        <name>ForwardPositionKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>worldHbase</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>jointPositions</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>linkPositions</declname>
        </param>
        <briefdescription>
<para>Given a robot floating base configuration (i.e. </para>
        </briefdescription>
        <detaileddescription>
<para>world_H_base and the joint positions) compute for each link the world_H_link transform.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the used model, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the used traversal, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">worldHbase</parametername>
</parameternamelist>
<parameterdescription>
<para>the world_H_base transform, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointPositions</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector of (internal) joint positions, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">linkPositions</parametername>
</parameternamelist>
<parameterdescription>
<para>linkPositions(l) contains the world_H_link transform. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went well, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ForwardKinematics.h" line="37" column="10" declfile="iDynTree/ForwardKinematics.h" declline="37" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="ForwardKinematics_8h_1a7d9ed3aeb57a5730beb59828bdf2301c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardPositionKinematics</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const FreeFloatingPos &amp;jointPos, LinkPositions &amp;linkPos)</argsstring>
        <name>ForwardPositionKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>linkPos</declname>
        </param>
        <briefdescription>
<para>Variant of ForwardPositionKinematics that takes in input a <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> object instead of a separate couple of (worldHbase,jointPositions) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ForwardKinematics.h" line="48" column="10" declfile="iDynTree/ForwardKinematics.h" declline="48" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="ForwardKinematics_8h_1a11cc6474718df311245c95f5452f7608" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardVelAccKinematics</definition>
        <argsstring>(const iDynTree::Model &amp;model, const iDynTree::Traversal &amp;traversal, const iDynTree::FreeFloatingPos &amp;robotPos, const iDynTree::FreeFloatingVel &amp;robotVel, const iDynTree::FreeFloatingAcc &amp;robotAcc, iDynTree::LinkVelArray &amp;linkVel, iDynTree::LinkAccArray &amp;linkAcc)</argsstring>
        <name>ForwardVelAccKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">iDynTree::Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">iDynTree::FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">iDynTree::FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">iDynTree::FreeFloatingAcc</ref> &amp;</type>
          <declname>robotAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">iDynTree::LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">iDynTree::LinkAccArray</ref> &amp;</type>
          <declname>linkAcc</declname>
        </param>
        <briefdescription>
<para>Function that compute the links velocities and accelerations given the free floating robot velocities and accelerations. </para>
        </briefdescription>
        <detaileddescription>
<para>This function implements what is usually known as the &quot;forward pass&quot; of the Recursive Newton Euler algorithm. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ForwardKinematics.h" line="62" column="10" declfile="iDynTree/ForwardKinematics.h" declline="62" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="ForwardKinematics_8h_1af853268cad240fb96e9190b6c07d7dfb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardPosVelAccKinematics</definition>
        <argsstring>(const iDynTree::Model &amp;model, const iDynTree::Traversal &amp;traversal, const iDynTree::FreeFloatingPos &amp;robotPos, const iDynTree::FreeFloatingVel &amp;robotVel, const iDynTree::FreeFloatingAcc &amp;robotAcc, iDynTree::LinkPositions &amp;linkPos, iDynTree::LinkVelArray &amp;linkVel, iDynTree::LinkAccArray &amp;linkAcc)</argsstring>
        <name>ForwardPosVelAccKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">iDynTree::Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">iDynTree::FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">iDynTree::FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">iDynTree::FreeFloatingAcc</ref> &amp;</type>
          <declname>robotAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkPositions" kindref="compound">iDynTree::LinkPositions</ref> &amp;</type>
          <declname>linkPos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">iDynTree::LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">iDynTree::LinkAccArray</ref> &amp;</type>
          <declname>linkAcc</declname>
        </param>
        <briefdescription>
<para>Function that compute the links position, velocities and accelerations given the free floating robot position, velocities and accelerations. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ForwardKinematics.h" line="76" column="10" declfile="iDynTree/ForwardKinematics.h" declline="76" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="ForwardKinematics_8h_1a82da15110d52ad717aa6c145f1c8a681" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardPosVelKinematics</definition>
        <argsstring>(const iDynTree::Model &amp;model, const iDynTree::Traversal &amp;traversal, const iDynTree::FreeFloatingPos &amp;robotPos, const iDynTree::FreeFloatingVel &amp;robotVel, iDynTree::LinkPositions &amp;linkPos, iDynTree::LinkVelArray &amp;linkVel)</argsstring>
        <name>ForwardPosVelKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">iDynTree::Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">iDynTree::FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">iDynTree::FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkPositions" kindref="compound">iDynTree::LinkPositions</ref> &amp;</type>
          <declname>linkPos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">iDynTree::LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <briefdescription>
<para>Function that compute the links position and velocities and accelerations given the free floating robot position and velocities. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ForwardKinematics.h" line="91" column="10" declfile="iDynTree/ForwardKinematics.h" declline="91" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="ForwardKinematics_8h_1a2848acd42a384966c3f2bbd760e29baa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardAccKinematics</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const FreeFloatingPos &amp;robotPos, const FreeFloatingVel &amp;robotVel, const FreeFloatingAcc &amp;robotAcc, const LinkVelArray &amp;linkVel, LinkAccArray &amp;linkAcc)</argsstring>
        <name>ForwardAccKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">FreeFloatingAcc</ref> &amp;</type>
          <declname>robotAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>linkAcc</declname>
        </param>
        <briefdescription>
<para>Function that computes the links accelerations given the free floating robot velocities and accelerations. </para>
        </briefdescription>
        <detaileddescription>
<para>This function implements what is usually known as the acceleration part &quot;forward pass&quot; of the Recursive Newton Euler algorithm. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ForwardKinematics.h" line="105" column="10" declfile="iDynTree/ForwardKinematics.h" declline="105" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="ForwardKinematics_8h_1a16f1071f088ed89178092de7b820558d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardBiasAccKinematics</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const FreeFloatingPos &amp;robotPos, const FreeFloatingVel &amp;robotVel, const SpatialAcc &amp;baseBiasAcc, const LinkVelArray &amp;linkVel, LinkAccArray &amp;linkBiasAcc)</argsstring>
        <name>ForwardBiasAccKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialAcc" kindref="compound">SpatialAcc</ref> &amp;</type>
          <declname>baseBiasAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>linkBiasAcc</declname>
        </param>
        <briefdescription>
<para>Function that computes the links bias accelerations given the free floating robot velocities. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>This function can also consider a non-zero base acceleration, because when computing the bias acc for the MIXED representation, a zero mixed base acceleration is a equivalent to a non-zero BODY_FIXED base acceleration.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the used model, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the used traversal, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">worldHbase</parametername>
</parameternamelist>
<parameterdescription>
<para>the world_H_base transform, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">robotPos</parametername>
</parameternamelist>
<parameterdescription>
<para>the position of the robot, i.e. <formula id="12">$ ({}^A H_B, s)$</formula>, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">robotVel</parametername>
</parameternamelist>
<parameterdescription>
<para>the velocity of the robot, with the base velocity expressed in BODY_FIXED representation i.e. <formula id="13">$ \nu = \begin{bmatrix} {}^B \mathrm{v}_{A,B} \newline \dot{s} \end{bmatrix} $</formula>, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">baseBiasAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>base bias acceleration with BODY_FIXED rapresentation, useful when the bias acceleration is considering the MIXED base acceleration to be zero, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>the velocity of each link of the robot, with velocity expressed with BODY_FIXED representation i.e. for each link <formula id="14">$ $</formula> we have <formula id="15">$ {}^L \mathrm{v}_{A,L} $</formula>, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">linkBiasAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>the bias acceleration of each link of the robot, with the acceleration expressed with BODY_FIXED representation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ForwardKinematics.h" line="134" column="10" declfile="iDynTree/ForwardKinematics.h" declline="134" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="ForwardKinematics_8h_1a2249785bd035cf4d2f35851d9eb50d26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::ForwardBiasAccKinematics</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const FreeFloatingPos &amp;robotPos, const FreeFloatingVel &amp;robotVel, const LinkVelArray &amp;linkVel, LinkAccArray &amp;linkBiasAcc)</argsstring>
        <name>ForwardBiasAccKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>linkBiasAcc</declname>
        </param>
        <briefdescription>
<para>Legacy function, will be deprecated, use the variant with an explicit baseBiasAcc value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ForwardKinematics.h" line="145" column="10" declfile="iDynTree/ForwardKinematics.h" declline="145" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModel_1gab0b6f0ce3e6e175b1532bdd897fd83c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::FreeFloatingJacobianUsingLinkPos</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const JointPosDoubleArray &amp;jointPositions, const LinkPositions &amp;linkPositions, const LinkIndex linkIndex, const Transform &amp;jacobFrame_X_world, const Transform &amp;baseFrame_X_jacobBaseFrame, const MatrixView&lt; double &gt; &amp;jacobian)</argsstring>
        <name>FreeFloatingJacobianUsingLinkPos</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPositions</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>linkPositions</declname>
        </param>
        <param>
          <type>const LinkIndex</type>
          <declname>linkIndex</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>jacobFrame_X_world</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>baseFrame_X_jacobBaseFrame</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; double &gt; &amp;</type>
          <declname>jacobian</declname>
        </param>
        <briefdescription>
<para>Compute a free floating jacobian. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the used model, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the used traversal, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointPositions</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector of (internal) joint positions, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkPositions</parametername>
</parameternamelist>
<parameterdescription>
<para>linkPositions(l) contains the world_H_link transform. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the link of which we compute the jacobian. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jacobFrame_X_world</parametername>
</parameternamelist>
<parameterdescription>
<para>TODO </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">baseFrame_X_jacobBaseFrame</parametername>
</parameternamelist>
<parameterdescription>
<para>TODO </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">jacobian</parametername>
</parameternamelist>
<parameterdescription>
<para>the computed Jacobian </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went well, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Jacobians.h" line="41" column="10" declfile="iDynTree/Jacobians.h" declline="41" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="ModelSensorsTransformers_8h_1af8355a73b30d3b5797fddae1f80ac778" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::createReducedModelAndSensors</definition>
        <argsstring>(const Model &amp;fullModel, const SensorsList &amp;fullSensors, const std::vector&lt; std::string &gt; &amp;jointsInReducedModel, Model &amp;reducedModel, SensorsList &amp;reducedSensors)</argsstring>
        <name>createReducedModelAndSensors</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>fullModel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> &amp;</type>
          <declname>fullSensors</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>jointsInReducedModel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>reducedModel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> &amp;</type>
          <declname>reducedSensors</declname>
        </param>
        <briefdescription>
<para>Variant of createReducedModel function that also process the sensorList . </para>
        </briefdescription>
        <detaileddescription>
<para>Note: since iDynTree 10, this has been superseded by the regular createReducedModel that also operated on the <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> associated with the model.</para>
<para>To migrate to this version, just change from:</para>
<para><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> fullModel, reducedModel; std::vector&lt;std::string&gt; jointsInReducedModel; <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> fullSensors, reducedSensors;</para>
<para>bool ok = createReducedModelAndSensors(fullModel, fullSensors, jointsInReducedModel, reducedModel, reducedSensors);</para>
<para>// handle ok // access reducedModel and reducedSensors</para>
<para>to</para>
<para><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> fullModel, reducedModel; std::vector&lt;std::string&gt; jointsInReducedModel; <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> fullSensors; fullModel.sensors() = fullSensors;</para>
<para>bool ok = createReducedModel(fullModel, jointsInReducedModel, reducedModel);</para>
<para>// Handle ok // access reducedModel and reducedModel.sensors() </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelSensorsTransformers.h" line="58" column="6" declfile="iDynTree/ModelSensorsTransformers.h" declline="58" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1ae3c9d8004d8849d347af71dfbbc998f1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Link" kindref="compound">Link</ref></type>
        <definition>Link iDynTree::getRandomLink</definition>
        <argsstring>()</argsstring>
        <name>getRandomLink</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="23" column="13" bodyfile="iDynTree/ModelTestUtils.h" bodystart="23" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1aea1ae47d4bec72e35885ee56cf39578b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::addRandomLinkToModel</definition>
        <argsstring>(Model &amp;model, std::string parentLink, std::string newLinkName, bool onlyRevoluteJoints=false)</argsstring>
        <name>addRandomLinkToModel</name>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>parentLink</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>newLinkName</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>onlyRevoluteJoints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Add a random link with random model. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="48" column="13" bodyfile="iDynTree/ModelTestUtils.h" bodystart="48" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1abbc9efd0eed3caf7826a0f67056972f8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::addRandomAdditionalFrameToModel</definition>
        <argsstring>(Model &amp;model, std::string parentLink, std::string newFrameName)</argsstring>
        <name>addRandomAdditionalFrameToModel</name>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>parentLink</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>newFrameName</declname>
        </param>
        <briefdescription>
<para>Add a random additional frame to a model model. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="95" column="13" bodyfile="iDynTree/ModelTestUtils.h" bodystart="95" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1a6480b737c82af8b72b95857960254bad" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>LinkIndex</type>
        <definition>LinkIndex iDynTree::getRandomLinkIndexOfModel</definition>
        <argsstring>(const Model &amp;model)</argsstring>
        <name>getRandomLinkIndexOfModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="100" column="18" bodyfile="iDynTree/ModelTestUtils.h" bodystart="100" bodyend="105"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1a75223c9a86126d90e70857cc48ff302e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string iDynTree::getRandomLinkOfModel</definition>
        <argsstring>(const Model &amp;model)</argsstring>
        <name>getRandomLinkOfModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="107" column="20" bodyfile="iDynTree/ModelTestUtils.h" bodystart="107" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1a2f8e6bff5b6a359c5bb88792dde90ac3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string iDynTree::int2string</definition>
        <argsstring>(int i)</argsstring>
        <name>int2string</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="114" column="20" bodyfile="iDynTree/ModelTestUtils.h" bodystart="114" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1a0aa7e6e0780497939a29fe8d6b635834" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref></type>
        <definition>Model iDynTree::getRandomModel</definition>
        <argsstring>(unsigned int nrOfJoints, size_t nrOfAdditionalFrames=10, bool onlyRevoluteJoints=false)</argsstring>
        <name>getRandomModel</name>
        <param>
          <type>unsigned int</type>
          <declname>nrOfJoints</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>nrOfAdditionalFrames</declname>
          <defval>10</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>onlyRevoluteJoints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="123" column="14" bodyfile="iDynTree/ModelTestUtils.h" bodystart="123" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1aced0d1a54a20c982a5d1ec11f40d8b2f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref></type>
        <definition>Model iDynTree::getRandomChain</definition>
        <argsstring>(unsigned int nrOfJoints, size_t nrOfAdditionalFrames=10, bool onlyRevoluteJoints=false)</argsstring>
        <name>getRandomChain</name>
        <param>
          <type>unsigned int</type>
          <declname>nrOfJoints</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>nrOfAdditionalFrames</declname>
          <defval>10</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>onlyRevoluteJoints</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="146" column="14" bodyfile="iDynTree/ModelTestUtils.h" bodystart="146" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1aff4391c79fb7cd4b59feed20b012d1d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::getRandomJointPositions</definition>
        <argsstring>(VectorDynSize &amp;vec, const Model &amp;model)</argsstring>
        <name>getRandomJointPositions</name>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <briefdescription>
<para>Get random joint position consistently with the limits of the model. </para>
        </briefdescription>
        <detaileddescription>
<para>If the input vector has the wrong size, it will be resized. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="174" column="13" bodyfile="iDynTree/ModelTestUtils.h" bodystart="174" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="ModelTestUtils_8h_1a72bed46cd07c0617f3f59ffbbb0823a0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::getRandomInverseDynamicsInputs</definition>
        <argsstring>(FreeFloatingPos &amp;pos, FreeFloatingVel &amp;vel, FreeFloatingAcc &amp;acc, LinkNetExternalWrenches &amp;extWrenches)</argsstring>
        <name>getRandomInverseDynamicsInputs</name>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>pos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">FreeFloatingVel</ref> &amp;</type>
          <declname>vel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">FreeFloatingAcc</ref> &amp;</type>
          <declname>acc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkNetExternalWrenches</ref> &amp;</type>
          <declname>extWrenches</declname>
        </param>
        <briefdescription>
<para>Get random robot positions, velocities and accelerations and external wrenches to be given as an input to InverseDynamics. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTestUtils.h" line="205" column="13" bodyfile="iDynTree/ModelTestUtils.h" bodystart="205" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformers_8h_1aab77480c8f9d5add110768cf75226508" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::removeFakeLinks</definition>
        <argsstring>(const Model &amp;modelWithFakeLinks, Model &amp;modelWithoutFakeLinks)</argsstring>
        <name>removeFakeLinks</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>modelWithFakeLinks</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>modelWithoutFakeLinks</declname>
        </param>
        <briefdescription>
<para>\function Remove all fake links in the model, transforming them in frames. </para>
        </briefdescription>
        <detaileddescription>
<para>Given a <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> in input, this function copies all its links and joints to the model in output, except for links that recognized as &quot;fake links&quot;.</para>
<para>The condition for a link to be classified as &quot;fake link&quot; are:<itemizedlist>
<listitem><para>The link has a zero mass.</para>
</listitem><listitem><para>The link is a leaf, i.e. it is connected to only one neighbor.</para>
</listitem><listitem><para>The link is connected to its only neighbor with a fixed joint.</para>
</listitem></itemizedlist>
</para>
<para>Once a &quot;fake link&quot; has been identified to respect this two conditions, it and the joint that it connects it to its only neighbor is not copied to the output model, but a frame with the same name of the &quot;fake link&quot; and with the same transform is added to the model.</para>
<para><simplesect kind="warning"><para>This function does not handle <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> contained inside the input model.</para>
</simplesect>
<simplesect kind="note"><para>The definition of &quot;fake link&quot; used in this function excludes the case in which two fake links are attached to one another. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformers.h" line="50" column="6" declfile="iDynTree/ModelTransformers.h" declline="50" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformers_8h_1a0dfcb86d2d13eb1969493ee84da2f5c0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::createReducedModel</definition>
        <argsstring>(const Model &amp;fullModel, const std::vector&lt; std::string &gt; &amp;jointsInReducedModel, Model &amp;reducedModel)</argsstring>
        <name>createReducedModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>fullModel</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>jointsInReducedModel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>reducedModel</declname>
        </param>
        <briefdescription>
<para>This function takes in input a <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> and an ordered list of joints and returns a model with just the joint specified in the list, with that exact order. </para>
        </briefdescription>
        <detaileddescription>
<para>All other joints are be removed by lumping (i.e. fusing together) the inertia of the links that are connected by that joint, assuming the joint to be in &quot;rest&quot; position (i.e. zero for revolute or prismatic joints). The links eliminated with this process are be added back to the reduced model as &quot;frames&quot;, and are copied in the same way all the additional frames of the lumped links. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformers.h" line="65" column="6" declfile="iDynTree/ModelTransformers.h" declline="65" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformers_8h_1ae25f91a29dc9b01ae310d5e1526fa273" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::createReducedModel</definition>
        <argsstring>(const Model &amp;fullModel, const std::vector&lt; std::string &gt; &amp;jointsInReducedModel, Model &amp;reducedModel, const std::unordered_map&lt; std::string, double &gt; &amp;removedJointPositions)</argsstring>
        <name>createReducedModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>fullModel</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt; &amp;</type>
          <declname>jointsInReducedModel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>reducedModel</declname>
        </param>
        <param>
          <type>const std::unordered_map&lt; std::string, double &gt; &amp;</type>
          <declname>removedJointPositions</declname>
        </param>
        <briefdescription>
<para>This function takes in input a <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> and an ordered list of joints and returns a model with just the joint specified in the list, with that exact order. </para>
        </briefdescription>
        <detaileddescription>
<para>All other joints are be removed by lumping (i.e. fusing together) the inertia of the links that are connected by that joint, assuming the joint to be in &quot;rest&quot; position (i.e. zero for revolute or prismatic joints), or the position specified in the removedJointPositions if a given joint is specified in removedJointPositions </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformers.h" line="80" column="6" declfile="iDynTree/ModelTransformers.h" declline="80" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformers_8h_1aa6a9c44d5b80ede19b30f721f88d3679" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::createModelWithNormalizedJointNumbering</definition>
        <argsstring>(const Model &amp;model, const std::string &amp;baseForNormalizedJointNumbering, Model &amp;reducedModel)</argsstring>
        <name>createModelWithNormalizedJointNumbering</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>baseForNormalizedJointNumbering</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>reducedModel</declname>
        </param>
        <briefdescription>
<para>Given a specified base, return a model with a &quot;normalized&quot; joint numbering for that base. </para>
        </briefdescription>
        <detaileddescription>
<para>This function takes in input a <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> and a name of a link in that model. It returns a model identical to the one in input, but with the joint serialization of the non-fixed joint modified in such a way that a non-fixed joint has an index higher than all the non-fixed joints on the path between it and the base. After all the non-fixed joints, the fixed joints are also added with the same criteria, but applied to fixed joints.</para>
<para><simplesect kind="note"><para>This method make sure that the non-fixed joint in the model have a &quot;regular numbering&quot; as described in Featherstone &quot;Rigid Body Dynamics Algorithm&quot;, section 4.1.2 . Note that this numbering is not required by any algorithm in iDynTree, but it may be useful for example to ensure that for a chain model the joint numbering is the one induced by the kinematic structure.</para>
</simplesect>
<simplesect kind="warning"><para>This function does not handle <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> contained inside the input model.</para>
</simplesect>
<simplesect kind="return"><para>true if all went well, false if there was an error in conversion. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformers.h" line="104" column="6" declfile="iDynTree/ModelTransformers.h" declline="104" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformers_8h_1a3800ea0a0da713ba27da022845601b2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::extractSubModel</definition>
        <argsstring>(const iDynTree::Model &amp;fullModel, const iDynTree::Traversal &amp;subModelTraversal, iDynTree::Model &amp;outputSubModel)</argsstring>
        <name>extractSubModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>fullModel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">iDynTree::Traversal</ref> &amp;</type>
          <declname>subModelTraversal</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>outputSubModel</declname>
        </param>
        <briefdescription>
<para>Extract sub model from sub model traversal. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates a new <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> containing links and joints composing the subModelTraversal. The function takes in input a <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> and a <ref refid="classiDynTree_1_1Traversal" kindref="compound">iDynTree::Traversal</ref>. The new model will contain joints and links composing the subModelTraversal, with the same order. The FT sensor frames are added as additional frames.</para>
<para><simplesect kind="warning"><para>This function does not handle <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> contained inside the input model.</para>
</simplesect>
<simplesect kind="return"><para>true if all went well, false if there was an error in creating the sub model. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformers.h" line="122" column="6" declfile="iDynTree/ModelTransformers.h" declline="122" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformers_8h_1a43a3d5de5f629b00c5c7a607278a4f20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::addValidNamesToAllSolidShapes</definition>
        <argsstring>(const iDynTree::Model &amp;inputModel, iDynTree::Model &amp;outputModel)</argsstring>
        <name>addValidNamesToAllSolidShapes</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>inputModel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>outputModel</declname>
        </param>
        <briefdescription>
<para>Add automatically generated names to all visual and collision solid shapes of the model. </para>
        </briefdescription>
        <detaileddescription>
<para>This function creates a new <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> that is identical to the input one, but that sets a valid name for all the visual and collision solid shapes of the model.</para>
<para>For links that already have at least either collision or visual with valid name, <bold>all</bold> the corresponding shapes (collision or visual) will not be modified.</para>
<para>For links in which all shapes of a given type that do not have a valid name, a name will be generated as the following:<itemizedlist>
<listitem><para>If there is a single collision or visual element in the link, it will be named &lt;linkName&gt;_collision or &lt;linkName&gt;_visual</para>
</listitem><listitem><para>If there are multiple collision or visual elements in the link, the solid shapes will be &lt;linkName&gt;_collision_0, &lt;linkName&gt;_collision_1, ... &lt;linkName&gt;_collision_n or &lt;linkName&gt;_visual_0, &lt;linkName&gt;_visual_1, ... &lt;linkName&gt;_visual_n</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="return"><para>true if all went well, false if there was an error in creating the sub model. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformers.h" line="145" column="6" declfile="iDynTree/ModelTransformers.h" declline="145" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformers_8h_1a133a097cc3ef37982c00cdd729829118" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::moveLinkFramesToBeCompatibleWithURDFWithGivenBaseLink</definition>
        <argsstring>(const iDynTree::Model &amp;inputModel, iDynTree::Model &amp;outputModel)</argsstring>
        <name>moveLinkFramesToBeCompatibleWithURDFWithGivenBaseLink</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>inputModel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>outputModel</declname>
        </param>
        <briefdescription>
<para><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> the input model in model that can be exported as URDF with the given base link. </para>
        </briefdescription>
        <detaileddescription>
<para>In iDynTree, the link frame can be placed without constraint w.r.t. to the joints to which the link is connected. On the other hand, in the URDF format, the origin of the frame of the child link connected to its parent with a non-fixed joint <bold>must</bold> lay on the axis of the joint.</para>
<para>That means that if you want to export a model with an arbitrary base link, some link frame will need to be moved to respect the constraint given by the URDF format. This function perform exactly this transformation, ensuring that inertia, visual and collision information is probably accounted for, and leaving the original link frames in the model as &quot;additional frames&quot; with the naming scheme &lt;linkName&gt;_original_frame .</para>
<para>Note that the operation done depends on the base link used, if you want to use a different base link, change the default base link of the model via inputModel.setDefaultBaseLink method.</para>
<para><simplesect kind="return"><para>true if all went well, false if there was an error in creating the sub model. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformers.h" line="166" column="6" declfile="iDynTree/ModelTransformers.h" declline="166" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformers_8h_1a9a8fd1db7c7bbfb060362056a4ec65ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::removeAdditionalFramesFromModel</definition>
        <argsstring>(const Model &amp;modelWithAllAdditionalFrames, Model &amp;modelWithOnlyAllowedAdditionalFrames, const std::vector&lt; std::string &gt; allowedAdditionalFrames=std::vector&lt; std::string &gt;())</argsstring>
        <name>removeAdditionalFramesFromModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>modelWithAllAdditionalFrames</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>modelWithOnlyAllowedAdditionalFrames</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::string &gt;</type>
          <declname>allowedAdditionalFrames</declname>
          <defval>std::vector&lt; std::string &gt;()</defval>
        </param>
        <briefdescription>
<para>\function Remove all additional frames from the model, except a specified allowlist. </para>
        </briefdescription>
        <detaileddescription>
<para>This function takes in input a model, and return a model with all the additional frame list removed, except for the additional frames whose name is specified in the specified allowlist.</para>
<para><simplesect kind="note"><para>The main use of this function is for processing models that need to be passed to other libraries or physics engines, where the additional frames may create problems or create performance problem. As long as you are using iDynTree, the presence of additional frames does not impact the performance of kinematics or dynamics algorithms, so there is no need to call this function to remove the additional frames.</para>
</simplesect>
<simplesect kind="return"><para>true if all went well, false if there was an error. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformers.h" line="186" column="6" declfile="iDynTree/ModelTransformers.h" declline="186" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeSensors_1ga26f5afdf5245848ed0cf946cab8510d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::predictSensorsMeasurements</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const FreeFloatingPos &amp;robotPos, const FreeFloatingVel &amp;robotVel, const FreeFloatingAcc &amp;robotAcc, const LinAcceleration &amp;gravity, const LinkNetExternalWrenches &amp;externalWrenches, FreeFloatingAcc &amp;buf_properRobotAcc, LinkPositions &amp;buf_linkPos, LinkVelArray &amp;buf_linkVel, LinkAccArray &amp;buf_linkProperAcc, LinkInternalWrenches &amp;buf_internalWrenches, FreeFloatingGeneralizedTorques &amp;buf_outputTorques, SensorsMeasurements &amp;predictedMeasurement)</argsstring>
        <name>predictSensorsMeasurements</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">FreeFloatingAcc</ref> &amp;</type>
          <declname>robotAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1GeomVector3" kindref="compound">LinAcceleration</ref> &amp;</type>
          <declname>gravity</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkNetExternalWrenches</ref> &amp;</type>
          <declname>externalWrenches</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">FreeFloatingAcc</ref> &amp;</type>
          <declname>buf_properRobotAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>buf_linkPos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>buf_linkVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>buf_linkProperAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkInternalWrenches</ref> &amp;</type>
          <declname>buf_internalWrenches</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingGeneralizedTorques" kindref="compound">FreeFloatingGeneralizedTorques</ref> &amp;</type>
          <declname>buf_outputTorques</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SensorsMeasurements" kindref="compound">SensorsMeasurements</ref> &amp;</type>
          <declname>predictedMeasurement</declname>
        </param>
        <briefdescription>
<para>Predict the measurement of a set of sensors. </para>
        </briefdescription>
        <detaileddescription>
<para>Given a SensorList object describing a list of sensor of a model fill the output argument predictedMeasurement with the predicted measurement of the sensors consistent with the state and the acceleration/torques and forces of the <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref>.</para>
<para>This function takes in input the internal buffers used for the computation to avoid dynamic memory allocation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the model used to predict the sensor measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sensorList</parametername>
</parameternamelist>
<parameterdescription>
<para>the sensors list used to predict the sensors measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> used for predict the sensor measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">robotPos</parametername>
</parameternamelist>
<parameterdescription>
<para>the position of the model used for prediction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">robotVel</parametername>
</parameternamelist>
<parameterdescription>
<para>the velocity of the model used for prediction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">robotAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>the acceleration of the model used for prediction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">gravity</parametername>
</parameternamelist>
<parameterdescription>
<para>the gravity acceleration (in world frame) used for prediction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">externalWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>the net external wrench acting on each link. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_properRobotAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the proper acceleration of the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_linkPos</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the position of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the velocity of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_linkProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the proper acceleration of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_internalWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the internal wrenches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_outputTorques</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the generalized joint torques. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">predictedMeasurement</parametername>
</parameternamelist>
<parameterdescription>
<para>the predicted measurements for the sensors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the sensors in the list are all valid </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PredictSensorsMeasurements.h" line="64" column="11" declfile="iDynTree/PredictSensorsMeasurements.h" declline="64" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeSensors_1ga85a09204a0c57c96bb77548d2a633677" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::predictSensorsMeasurementsFromRawBuffers</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const LinkVelArray &amp;buf_linkVel, const LinkAccArray &amp;buf_linkProperAcc, const LinkInternalWrenches &amp;buf_internalWrenches, SensorsMeasurements &amp;predictedMeasurement)</argsstring>
        <name>predictSensorsMeasurementsFromRawBuffers</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>buf_linkVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>buf_linkProperAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkInternalWrenches</ref> &amp;</type>
          <declname>buf_internalWrenches</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SensorsMeasurements" kindref="compound">SensorsMeasurements</ref> &amp;</type>
          <declname>predictedMeasurement</declname>
        </param>
        <briefdescription>
<para>Predict the measurement of a set of sensors. </para>
        </briefdescription>
        <detaileddescription>
<para>Helper function that works on buffers already compute with Dynamics functions</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the model used to predict the sensor measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> used for predict the sensor measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf_linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the velocity of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf_linkProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the proper acceleration of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf_internalWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the internal wrenches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">predictedMeasurement</parametername>
</parameternamelist>
<parameterdescription>
<para>the predicted measurements for the sensors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the sensors in the list are all valid </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PredictSensorsMeasurements.h" line="95" column="11" declfile="iDynTree/PredictSensorsMeasurements.h" declline="95" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeSensors_1gacf87de6a0acc7c79369e4ea587ef19bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::predictSensorsMeasurements</definition>
        <argsstring>(const Model &amp;model, const SensorsList &amp;sensorList, const Traversal &amp;traversal, const FreeFloatingPos &amp;robotPos, const FreeFloatingVel &amp;robotVel, const FreeFloatingAcc &amp;robotAcc, const LinAcceleration &amp;gravity, const LinkNetExternalWrenches &amp;externalWrenches, FreeFloatingAcc &amp;buf_properRobotAcc, LinkPositions &amp;buf_linkPos, LinkVelArray &amp;buf_linkVel, LinkAccArray &amp;buf_linkProperAcc, LinkInternalWrenches &amp;buf_internalWrenches, FreeFloatingGeneralizedTorques &amp;buf_outputTorques, SensorsMeasurements &amp;predictedMeasurement)</argsstring>
        <name>predictSensorsMeasurements</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> &amp;</type>
          <declname>sensorList</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingPos" kindref="compound">FreeFloatingPos</ref> &amp;</type>
          <declname>robotPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingVel" kindref="compound">FreeFloatingVel</ref> &amp;</type>
          <declname>robotVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">FreeFloatingAcc</ref> &amp;</type>
          <declname>robotAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1GeomVector3" kindref="compound">LinAcceleration</ref> &amp;</type>
          <declname>gravity</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkNetExternalWrenches</ref> &amp;</type>
          <declname>externalWrenches</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingAcc" kindref="compound">FreeFloatingAcc</ref> &amp;</type>
          <declname>buf_properRobotAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>buf_linkPos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>buf_linkVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>buf_linkProperAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkInternalWrenches</ref> &amp;</type>
          <declname>buf_internalWrenches</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1FreeFloatingGeneralizedTorques" kindref="compound">FreeFloatingGeneralizedTorques</ref> &amp;</type>
          <declname>buf_outputTorques</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SensorsMeasurements" kindref="compound">SensorsMeasurements</ref> &amp;</type>
          <declname>predictedMeasurement</declname>
        </param>
        <briefdescription>
<para>Predict the measurement of a set of sensors. </para>
        </briefdescription>
        <detaileddescription>
<para>Given a SensorList object describing a list of sensor of a model fill the output argument predictedMeasurement with the predicted measurement of the sensors consistent with the state and the acceleration/torques and forces of the <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref>.</para>
<para>This function takes in input the internal buffers used for the computation to avoid dynamic memory allocation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the model used to predict the sensor measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sensorList</parametername>
</parameternamelist>
<parameterdescription>
<para>the sensors list used to predict the sensors measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> used for predict the sensor measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">robotPos</parametername>
</parameternamelist>
<parameterdescription>
<para>the position of the model used for prediction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">robotVel</parametername>
</parameternamelist>
<parameterdescription>
<para>the velocity of the model used for prediction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">robotAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>the acceleration of the model used for prediction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">gravity</parametername>
</parameternamelist>
<parameterdescription>
<para>the gravity acceleration (in world frame) used for prediction. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">externalWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>the net external wrench acting on each link. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_properRobotAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the proper acceleration of the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_linkPos</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the position of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the velocity of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_linkProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the proper acceleration of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_internalWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the internal wrenches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">buf_outputTorques</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the generalized joint torques. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">predictedMeasurement</parametername>
</parameternamelist>
<parameterdescription>
<para>the predicted measurements for the sensors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the sensors in the list are all valid </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PredictSensorsMeasurements.h" line="137" column="11" declfile="iDynTree/PredictSensorsMeasurements.h" declline="137" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeSensors_1gaa68c8cac6b85223f729cd8855627d35e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::predictSensorsMeasurementsFromRawBuffers</definition>
        <argsstring>(const Model &amp;model, const SensorsList &amp;sensorList, const Traversal &amp;traversal, const LinkVelArray &amp;buf_linkVel, const LinkAccArray &amp;buf_linkProperAcc, const LinkInternalWrenches &amp;buf_internalWrenches, SensorsMeasurements &amp;predictedMeasurement)</argsstring>
        <name>predictSensorsMeasurementsFromRawBuffers</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> &amp;</type>
          <declname>sensorList</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>buf_linkVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>buf_linkProperAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkInternalWrenches</ref> &amp;</type>
          <declname>buf_internalWrenches</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1SensorsMeasurements" kindref="compound">SensorsMeasurements</ref> &amp;</type>
          <declname>predictedMeasurement</declname>
        </param>
        <briefdescription>
<para>Predict the measurement of a set of sensors. </para>
        </briefdescription>
        <detaileddescription>
<para>Helper function that works on buffers already compute with Dynamics functions</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the model used to predict the sensor measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sensorList</parametername>
</parameternamelist>
<parameterdescription>
<para>the sensors list used to predict the sensors measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> used for predict the sensor measurements. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf_linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the velocity of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf_linkProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the proper acceleration of every link in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">buf_internalWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>internal buffer, storing the internal wrenches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">predictedMeasurement</parametername>
</parameternamelist>
<parameterdescription>
<para>the predicted measurements for the sensors.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the sensors in the list are all valid </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PredictSensorsMeasurements.h" line="171" column="11" declfile="iDynTree/PredictSensorsMeasurements.h" declline="171" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="Sensors_8h_1a784ae0ef50c758f0cf07ab414f432963" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::isLinkSensor</definition>
        <argsstring>(const SensorType type)</argsstring>
        <name>isLinkSensor</name>
        <param>
          <type>const SensorType</type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>Short function to check if a SensorType is a <ref refid="classiDynTree_1_1LinkSensor" kindref="compound">LinkSensor</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Sensors.h" line="44" column="17" bodyfile="iDynTree/Sensors.h" bodystart="44" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="Sensors_8h_1a6edabe0d73bb9102d0ad456124c0f195" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::isJointSensor</definition>
        <argsstring>(const SensorType type)</argsstring>
        <name>isJointSensor</name>
        <param>
          <type>const SensorType</type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>Short function to check if a SensorType is. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Sensors.h" line="62" column="17" bodyfile="iDynTree/Sensors.h" bodystart="62" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="Sensors_8h_1a6b73f760e18bf9860c623ddc8a0f376c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t iDynTree::getSensorTypeSize</definition>
        <argsstring>(const SensorType type)</argsstring>
        <name>getSensorTypeSize</name>
        <param>
          <type>const SensorType</type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Sensors.h" line="67" column="24" bodyfile="iDynTree/Sensors.h" bodystart="67" bodyend="81"/>
      </memberdef>
      <memberdef kind="function" id="SubModel_8h_1a2f7475185a0d9ae6c7dcd2048d4a23fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::computeTransformToTraversalBase</definition>
        <argsstring>(const Model &amp;fullModel, const Traversal &amp;traversal, const JointPosDoubleArray &amp;jointPos, LinkPositions &amp;traversalBase_H_link)</argsstring>
        <name>computeTransformToTraversalBase</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>fullModel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>traversalBase_H_link</declname>
        </param>
        <briefdescription>
<para>Helper loop to compute the position of each link wrt to the frame of the subModel base. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fullModel</parametername>
</parameternamelist>
<parameterdescription>
<para>full model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>traversal on which to run the loop </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointPos</parametername>
</parameternamelist>
<parameterdescription>
<para>joint positions for the full model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">traversalBase_H_link</parametername>
</parameternamelist>
<parameterdescription>
<para>traversalBase_H_link[i] will store the traversalBase_H_i transform </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SubModel.h" line="126" column="10" declfile="iDynTree/SubModel.h" declline="126" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="SubModel_8h_1a3f3b031bdaab68634b5cc61f5e1e14b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::computeTransformToSubModelBase</definition>
        <argsstring>(const Model &amp;fullModel, const SubModelDecomposition &amp;subModelDecomposition, const JointPosDoubleArray &amp;jointPos, LinkPositions &amp;subModelBase_H_link)</argsstring>
        <name>computeTransformToSubModelBase</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>fullModel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SubModelDecomposition" kindref="compound">SubModelDecomposition</ref> &amp;</type>
          <declname>subModelDecomposition</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkPositions" kindref="compound">LinkPositions</ref> &amp;</type>
          <declname>subModelBase_H_link</declname>
        </param>
        <briefdescription>
<para>Run the computeTransformToTraversalBase for all the traversal in the subModelDecomposition, and store the results in the linkPos array. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">fullModel</parametername>
</parameternamelist>
<parameterdescription>
<para>full model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">subModelDecomposition</parametername>
</parameternamelist>
<parameterdescription>
<para>model decomposition on which the loop will run </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointPos</parametername>
</parameternamelist>
<parameterdescription>
<para>joint positions for the full model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">subModelBase_H_link</parametername>
</parameternamelist>
<parameterdescription>
<para>subModelBase_H_link[i] will store the subModelBase_H_i transform </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SubModel.h" line="141" column="10" declfile="iDynTree/SubModel.h" declline="141" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeICUB_1ga93e84fbc1880a920199aae0cbabd76ea" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::DHChainFromiKinChain</definition>
        <argsstring>(iCub::iKin::iKinChain &amp;ikinChain, DHChain &amp;out)</argsstring>
        <name>DHChainFromiKinChain</name>
        <param>
          <type>iCub::iKin::iKinChain &amp;</type>
          <declname>ikinChain</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1DHChain" kindref="compound">DHChain</ref> &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Load a <ref refid="classiDynTree_1_1DHChain" kindref="compound">iDynTree::DHChain</ref> object from a iCub::iKin::iKinChain . </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true if all went ok, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/iKinConversionsImplementation.h" line="40" column="13" bodyfile="iDynTree/iKinConversionsImplementation.h" bodystart="40" bodyend="63" declfile="iDynTree/iKinConversions.h" declline="25" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeICUB_1gadb9ad80c8043481f2bb8f013542db690" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::modelFromiKinChain</definition>
        <argsstring>(iCub::iKin::iKinChain &amp;ikinChain, Model &amp;output)</argsstring>
        <name>modelFromiKinChain</name>
        <param>
          <type>iCub::iKin::iKinChain &amp;</type>
          <declname>ikinChain</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>output</declname>
        </param>
        <briefdescription>
<para>Load a <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> object from a iCub::iKin::iKinChain . </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true if all went ok, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/iKinConversionsImplementation.h" line="65" column="13" bodyfile="iDynTree/iKinConversionsImplementation.h" bodystart="65" bodyend="78" declfile="iDynTree/iKinConversions.h" declline="35" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeICUB_1ga681d23161951646fcb60dc7681e59482" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::iKinLimbFromModel</definition>
        <argsstring>(const Model &amp;model, const std::string &amp;baseFrame, const std::string &amp;distalFrame, iCub::iKin::iKinLimb &amp;ikinLimb)</argsstring>
        <name>iKinLimbFromModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>baseFrame</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>distalFrame</declname>
        </param>
        <param>
          <type>iCub::iKin::iKinLimb &amp;</type>
          <declname>ikinLimb</declname>
        </param>
        <briefdescription>
<para>Extract an iCub::iKin::iKinLimb from an <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> . </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true if all went ok, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/iKinConversionsImplementation.h" line="131" column="13" bodyfile="iDynTree/iKinConversionsImplementation.h" bodystart="131" bodyend="140" declfile="iDynTree/iKinConversions.h" declline="76" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeICUB_1gaaedc638580c296a9a355975268ea25bb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::iKinLimbFromDHChain</definition>
        <argsstring>(const DHChain &amp;dhChain, iCub::iKin::iKinLimb &amp;ikinLimb)</argsstring>
        <name>iKinLimbFromDHChain</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1DHChain" kindref="compound">DHChain</ref> &amp;</type>
          <declname>dhChain</declname>
        </param>
        <param>
          <type>iCub::iKin::iKinLimb &amp;</type>
          <declname>ikinLimb</declname>
        </param>
        <briefdescription>
<para>Create a iCub::iKin::iKinLimb from an <ref refid="classiDynTree_1_1DHChain" kindref="compound">iDynTree::DHChain</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/iKinConversionsImplementation.h" line="119" column="13" bodyfile="iDynTree/iKinConversionsImplementation.h" bodystart="119" bodyend="129" declfile="iDynTree/iKinConversions.h" declline="86" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="iKinConversionsImplementation_8h_1a907871ccc9e6e56fb19fa0af4c0854c8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structiDynTree_1_1DHLink" kindref="compound">DHLink</ref></type>
        <definition>DHLink iDynTree::iKinLink2DHLink</definition>
        <argsstring>(const iCub::iKin::iKinLink &amp;ikinlink)</argsstring>
        <name>iKinLink2DHLink</name>
        <param>
          <type>const iCub::iKin::iKinLink &amp;</type>
          <declname>ikinlink</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/iKinConversionsImplementation.h" line="19" column="15" bodyfile="iDynTree/iKinConversionsImplementation.h" bodystart="19" bodyend="31"/>
      </memberdef>
      <memberdef kind="function" id="iKinConversionsImplementation_8h_1ae6d845189d4491128320b2c78c6082ec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>iCub::iKin::iKinLink</type>
        <definition>iCub::iKin::iKinLink iDynTree::DHLink2iKinLink</definition>
        <argsstring>(const DHLink &amp;dhLink)</argsstring>
        <name>DHLink2iKinLink</name>
        <param>
          <type>const <ref refid="structiDynTree_1_1DHLink" kindref="compound">DHLink</ref> &amp;</type>
          <declname>dhLink</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/iKinConversionsImplementation.h" line="33" column="29" bodyfile="iDynTree/iKinConversionsImplementation.h" bodystart="33" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="skinDynLibConversionsImplementation_8h_1abd0cb602d0a91817a13e042d47004d79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class contactsList</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool iDynTree::fromSkinDynLibToiDynTreeHelper</definition>
        <argsstring>(const Model &amp;model, const contactsList &amp;dynList, LinkUnknownWrenchContacts &amp;unknowns, const skinDynLibConversionsHelper &amp;conversionHelper)</argsstring>
        <name>fromSkinDynLibToiDynTreeHelper</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const contactsList &amp;</type>
          <declname>dynList</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkUnknownWrenchContacts" kindref="compound">LinkUnknownWrenchContacts</ref> &amp;</type>
          <declname>unknowns</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1skinDynLibConversionsHelper" kindref="compound">skinDynLibConversionsHelper</ref> &amp;</type>
          <declname>conversionHelper</declname>
        </param>
        <briefdescription>
<para>Templated version of fromSkinDynLibToiDynTree, useful to implement the exact same function for dynContactList and skinContactList, that have exactly the same interface, but they don&apos;t have any common ancestor in the class structure. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/skinDynLibConversionsImplementation.h" line="159" column="6" bodyfile="iDynTree/skinDynLibConversionsImplementation.h" bodystart="159" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a5481a54f7c787fd4cf55a0f5fd21bbb0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; Eigen::VectorXd &gt;</type>
        <definition>Eigen::Map&lt;Eigen::VectorXd&gt; iDynTree::toEigen</definition>
        <argsstring>(VectorDynSize &amp;vec)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="46" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="46" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a0d2e67fee79a1191ed16ab1d522b0078" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(MatrixDynSize &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1MatrixDynSize" kindref="compound">MatrixDynSize</ref> &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="51" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="51" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a3f48b18c53414248343c3adaf5db988c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; const Eigen::VectorXd &gt;</type>
        <definition>Eigen::Map&lt;const Eigen::VectorXd&gt; iDynTree::toEigen</definition>
        <argsstring>(const VectorDynSize &amp;vec)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="56" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="56" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a3d1f28b899ee110b8af0c92c9945455c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; const Eigen::VectorXd &gt;</type>
        <definition>Eigen::Map&lt; Eigen::VectorXd &gt; iDynTree::toEigen</definition>
        <argsstring>(Span&lt; const double &gt; vec)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; const double &gt;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="62" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="62" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a529708f2899d75d6491fce5823c6c069" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, 0, Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</type>
        <definition>Eigen::Map&lt;const Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, 0, Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(const MatrixView&lt; const double &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; const double &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="75" column="1" bodyfile="iDynTree/EigenHelpers.h" bodystart="75" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a0007fc5ab429e207c6244ac715f82dc0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, 0, Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</type>
        <definition>Eigen::Map&lt;Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, 0, Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(const MatrixView&lt; double &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; double &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="124" column="1" bodyfile="iDynTree/EigenHelpers.h" bodystart="124" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1af9123b8fa68b1799fd197ab4a1acc618" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt;const Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(const MatrixDynSize &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixDynSize" kindref="compound">MatrixDynSize</ref> &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="172" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="172" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a4dc3574842fc660108111d96dac71b23" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>unsigned int</type>
            <declname>VecSize</declname>
            <defname>VecSize</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; Eigen::Matrix&lt; double, VecSize, 1 &gt; &gt;</type>
        <definition>Eigen::Map&lt;Eigen::Matrix&lt;double,VecSize,1&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(VectorFixSize&lt; VecSize &gt; &amp;vec)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; VecSize &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="179" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="179" bodyend="182"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a17939782b66cf87bba581ac4d6db6270" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>unsigned int</type>
            <declname>VecSize</declname>
            <defname>VecSize</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; const Eigen::Matrix&lt; double, VecSize, 1 &gt; &gt;</type>
        <definition>Eigen::Map&lt;const Eigen::Matrix&lt;double,VecSize,1&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(const VectorFixSize&lt; VecSize &gt; &amp;vec)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; VecSize &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="185" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="185" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1ac34e051a03bd114394e71919b795171e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>unsigned int</type>
            <declname>nRows</declname>
            <defname>nRows</defname>
          </param>
          <param>
            <type>unsigned int</type>
            <declname>nCols</declname>
            <defname>nCols</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; Eigen::Matrix&lt; double, nRows, nCols, Eigen::RowMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::Matrix&lt;double,nRows,nCols,Eigen::RowMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(MatrixFixSize&lt; nRows, nCols &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; nRows, nCols &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="191" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="191" bodyend="194"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1ab60f7d72717e939931bf139b222b2832" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>unsigned int</type>
            <declname>nRows</declname>
            <defname>nRows</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; Eigen::Matrix&lt; double, nRows, 1 &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::Matrix&lt;double,nRows,1&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(MatrixFixSize&lt; nRows, 1 &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; nRows, 1 &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="197" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="197" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a3153f5d1e97e538fae73b906b511c518" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>unsigned int</type>
            <declname>nCols</declname>
            <defname>nCols</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; Eigen::Matrix&lt; double, 1, nCols &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::Matrix&lt;double,1,nCols&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(MatrixFixSize&lt; 1, nCols &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; 1, nCols &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="203" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="203" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a9639a283e2caa3460084f5e3ac48aa49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>unsigned int</type>
            <declname>nRows</declname>
            <defname>nRows</defname>
          </param>
          <param>
            <type>unsigned int</type>
            <declname>nCols</declname>
            <defname>nCols</defname>
          </param>
        </templateparamlist>
        <type>Eigen::Map&lt; const Eigen::Matrix&lt; double, nRows, nCols, Eigen::RowMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt; const Eigen::Matrix&lt;double,nRows,nCols,Eigen::RowMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(const MatrixFixSize&lt; nRows, nCols &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; nRows, nCols &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="209" column="19" bodyfile="iDynTree/EigenHelpers.h" bodystart="209" bodyend="212"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1af643aa15e4ab96c1e19f5364893d4b0b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const Eigen::Matrix&lt; double, 6, 1 &gt;</type>
        <definition>const Eigen::Matrix&lt;double,6,1&gt; iDynTree::toEigen</definition>
        <argsstring>(const SpatialMotionVector &amp;vec)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="215" column="28" bodyfile="iDynTree/EigenHelpers.h" bodystart="215" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a4bb2e73fb98abd04aed4da600567b24b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const Eigen::Matrix&lt; double, 6, 1 &gt;</type>
        <definition>const Eigen::Matrix&lt;double,6,1&gt; iDynTree::toEigen</definition>
        <argsstring>(const SpatialForceVector &amp;vec)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="225" column="28" bodyfile="iDynTree/EigenHelpers.h" bodystart="225" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1acf2d7088e9fd094e6aa9c79bd4364b69" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::fromEigen</definition>
        <argsstring>(SpatialMotionVector &amp;vec, const Eigen::Matrix&lt; double, 6, 1 &gt; &amp;eigVec)</argsstring>
        <name>fromEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const Eigen::Matrix&lt; double, 6, 1 &gt; &amp;</type>
          <declname>eigVec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="236" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="236" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a1943bf2f7027929dd5a9203b35d60b82" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::fromEigen</definition>
        <argsstring>(SpatialForceVector &amp;vec, const Eigen::Matrix&lt; double, 6, 1 &gt; &amp;eigVec)</argsstring>
        <name>fromEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const Eigen::Matrix&lt; double, 6, 1 &gt; &amp;</type>
          <declname>eigVec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="242" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="242" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1ad32fda4b9fa803472c83dea084ec14d8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::fromEigen</definition>
        <argsstring>(Transform &amp;trans, const Eigen::Matrix4d &amp;eigMat)</argsstring>
        <name>fromEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>trans</declname>
        </param>
        <param>
          <type>const Eigen::Matrix4d &amp;</type>
          <declname>eigMat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="248" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="248" bodyend="258"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1ae5b49ed3e6ce87e8262be598d41b01bb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Derived</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; typename Derived::Scalar, 3, 3, Eigen::RowMajor &gt;</type>
        <definition>Eigen::Matrix&lt;typename Derived::Scalar, 3, 3, Eigen::RowMajor&gt; iDynTree::skew</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;vec)</argsstring>
        <name>skew</name>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="261" column="22" bodyfile="iDynTree/EigenHelpers.h" bodystart="261" bodyend="267"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a8e4347585aaeb967bfb2916b135b9357" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Derived</type>
          </param>
        </templateparamlist>
        <type>Eigen::Matrix&lt; typename Derived::Scalar, 3, 1 &gt;</type>
        <definition>Eigen::Matrix&lt;typename Derived::Scalar, 3, 1&gt; iDynTree::unskew</definition>
        <argsstring>(const Eigen::MatrixBase&lt; Derived &gt; &amp;mat)</argsstring>
        <name>unskew</name>
        <param>
          <type>const Eigen::MatrixBase&lt; Derived &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="270" column="22" bodyfile="iDynTree/EigenHelpers.h" bodystart="270" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1ab923f233e9624344a28e361ddc2c4c10" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>unsigned int</type>
            <declname>nRows</declname>
            <defname>nRows</defname>
          </param>
          <param>
            <type>unsigned int</type>
            <declname>nCols</declname>
            <defname>nCols</defname>
          </param>
          <param>
            <type>typename iDynTreeMatrixType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::setSubMatrix</definition>
        <argsstring>(iDynTreeMatrixType &amp;mat, const IndexRange rowRange, const IndexRange colRange, const MatrixFixSize&lt; nRows, nCols &gt; &amp;subMat)</argsstring>
        <name>setSubMatrix</name>
        <param>
          <type>iDynTreeMatrixType &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>rowRange</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>colRange</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>&lt; nRows, nCols &gt; &amp;</type>
          <declname>subMat</declname>
        </param>
        <briefdescription>
<para>Submatrix helpers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="281" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="281" bodyend="292"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a46433c21ed1226e759f6d2471731ff20" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename iDynTreeMatrixType</type>
          </param>
          <param>
            <type>typename EigMatType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::setSubMatrix</definition>
        <argsstring>(iDynTreeMatrixType &amp;mat, const IndexRange rowRange, const IndexRange colRange, const EigMatType &amp;subMat)</argsstring>
        <name>setSubMatrix</name>
        <param>
          <type>iDynTreeMatrixType &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>rowRange</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>colRange</declname>
        </param>
        <param>
          <type>const EigMatType &amp;</type>
          <declname>subMat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="295" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="295" bodyend="305"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a15eb97c903bd5a5a44d7b36997a383f4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename iDynTreeMatrixType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::setSubMatrix</definition>
        <argsstring>(iDynTreeMatrixType &amp;mat, const IndexRange rowRange, const IndexRange colRange, const double subMat)</argsstring>
        <name>setSubMatrix</name>
        <param>
          <type>iDynTreeMatrixType &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>rowRange</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>colRange</declname>
        </param>
        <param>
          <type>const double</type>
          <declname>subMat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="308" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="308" bodyend="320"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1acab405374af27aa1405539284ac1c79a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename iDynTreeMatrixType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::setSubMatrixToIdentity</definition>
        <argsstring>(iDynTreeMatrixType &amp;mat, const IndexRange rowRange, const IndexRange colRange)</argsstring>
        <name>setSubMatrixToIdentity</name>
        <param>
          <type>iDynTreeMatrixType &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>rowRange</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>colRange</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="323" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="323" bodyend="336"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a05bb9e8c80231289997f79ffc0b2e97c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename iDynTreeMatrixType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::setSubMatrixToMinusIdentity</definition>
        <argsstring>(iDynTreeMatrixType &amp;mat, const IndexRange rowRange, const IndexRange colRange)</argsstring>
        <name>setSubMatrixToMinusIdentity</name>
        <param>
          <type>iDynTreeMatrixType &amp;</type>
          <declname>mat</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>rowRange</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>colRange</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="339" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="339" bodyend="352"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a6dd6e3fecb51492464bb6648090d9785" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>unsigned int</type>
            <declname>size</declname>
            <defname>size</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::setSubVector</definition>
        <argsstring>(VectorDynSize &amp;vec, const IndexRange range, const VectorFixSize&lt; size &gt; &amp;subVec)</argsstring>
        <name>setSubVector</name>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>range</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>&lt; size &gt; &amp;</type>
          <declname>subVec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="356" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="356" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1ac065bee2dbb9521e07df4d769992ccd6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::setSubVector</definition>
        <argsstring>(VectorDynSize &amp;vec, const IndexRange range, double subVec)</argsstring>
        <name>setSubVector</name>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>range</declname>
        </param>
        <param>
          <type>double</type>
          <declname>subVec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="364" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="364" bodyend="371"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a60fc528e9cb5bb8f0a41ad51ae464ac5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::setSubVector</definition>
        <argsstring>(VectorDynSize &amp;vec, const IndexRange range, const SpatialMotionVector &amp;twist)</argsstring>
        <name>setSubVector</name>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>range</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>twist</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="373" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="373" bodyend="380"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a6c26a20e65041a0023677f35f84563f4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::setSubVector</definition>
        <argsstring>(VectorDynSize &amp;vec, const IndexRange range, const SpatialForceVector &amp;wrench)</argsstring>
        <name>setSubVector</name>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>range</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> &amp;</type>
          <declname>wrench</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="382" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="382" bodyend="389"/>
      </memberdef>
      <memberdef kind="function" id="EigenHelpers_8h_1a3707e4cd79954877014299710fee2607" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::setSubVector</definition>
        <argsstring>(VectorDynSize &amp;vec, const IndexRange range, const T &amp;subVec)</argsstring>
        <name>setSubVector</name>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1IndexRange" kindref="compound">IndexRange</ref></type>
          <declname>range</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>subVec</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenHelpers.h" line="392" column="13" bodyfile="iDynTree/EigenHelpers.h" bodystart="392" bodyend="398"/>
      </memberdef>
      <memberdef kind="function" id="EigenMathHelpers_8h_1a903238e532f385a1cd3db7b731fa884c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MapType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::pseudoInverse_helper2</definition>
        <argsstring>(const MapType &amp;A, Eigen::JacobiSVD&lt; Eigen::MatrixXd &gt; &amp;svdDecomposition, MapType &amp;Apinv, double tolerance, unsigned int computationOptions=Eigen::ComputeThinU|Eigen::ComputeThinV)</argsstring>
        <name>pseudoInverse_helper2</name>
        <param>
          <type>const MapType &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>Eigen::JacobiSVD&lt; Eigen::MatrixXd &gt; &amp;</type>
          <declname>svdDecomposition</declname>
        </param>
        <param>
          <type>MapType &amp;</type>
          <declname>Apinv</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tolerance</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>computationOptions</declname>
          <defval>Eigen::ComputeThinU|Eigen::ComputeThinV</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenMathHelpers.h" line="16" column="6" bodyfile="iDynTree/EigenMathHelpers.h" bodystart="16" bodyend="41"/>
      </memberdef>
      <memberdef kind="function" id="EigenMathHelpers_8h_1aacb98344c6221dbf5e5d7678e3e75136" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MapType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::pseudoInverse_helper1</definition>
        <argsstring>(const MapType &amp;A, Eigen::JacobiSVD&lt; Eigen::MatrixXd &gt; &amp;svdDecomposition, MapType &amp;Apinv, double tolerance, unsigned int computationOptions=Eigen::ComputeThinU|Eigen::ComputeThinV)</argsstring>
        <name>pseudoInverse_helper1</name>
        <param>
          <type>const MapType &amp;</type>
          <declname>A</declname>
        </param>
        <param>
          <type>Eigen::JacobiSVD&lt; Eigen::MatrixXd &gt; &amp;</type>
          <declname>svdDecomposition</declname>
        </param>
        <param>
          <type>MapType &amp;</type>
          <declname>Apinv</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tolerance</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>computationOptions</declname>
          <defval>Eigen::ComputeThinU|Eigen::ComputeThinV</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenMathHelpers.h" line="45" column="6" bodyfile="iDynTree/EigenMathHelpers.h" bodystart="45" bodyend="53"/>
      </memberdef>
      <memberdef kind="function" id="EigenMathHelpers_8h_1a0b20a0208cab1ac6cdbd661612ca4c1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MapType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::pseudoInverse</definition>
        <argsstring>(const MapType A, MapType Apinv, double tolerance, unsigned int computationOptions=Eigen::ComputeThinU|Eigen::ComputeThinV)</argsstring>
        <name>pseudoInverse</name>
        <param>
          <type>const MapType</type>
          <declname>A</declname>
        </param>
        <param>
          <type>MapType</type>
          <declname>Apinv</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tolerance</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>computationOptions</declname>
          <defval>Eigen::ComputeThinU|Eigen::ComputeThinV</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenMathHelpers.h" line="56" column="6" bodyfile="iDynTree/EigenMathHelpers.h" bodystart="56" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="EigenSparseHelpers_8h_1ade809da6861adf8889108908fd931ee5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; Eigen::SparseMatrix&lt; double, Eigen::RowMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(iDynTree::SparseMatrix&lt; iDynTree::RowMajor &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1SparseMatrix" kindref="compound">iDynTree::SparseMatrix</ref>&lt; iDynTree::RowMajor &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenSparseHelpers.h" line="14" column="19" bodyfile="iDynTree/EigenSparseHelpers.h" bodystart="14" bodyend="23"/>
      </memberdef>
      <memberdef kind="function" id="EigenSparseHelpers_8h_1a3c0db1fc07367309957972bd66454c7e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; const Eigen::SparseMatrix&lt; double, Eigen::RowMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt;const Eigen::SparseMatrix&lt;double, Eigen::RowMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(const iDynTree::SparseMatrix&lt; iDynTree::RowMajor &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SparseMatrix" kindref="compound">iDynTree::SparseMatrix</ref>&lt; iDynTree::RowMajor &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenSparseHelpers.h" line="25" column="19" bodyfile="iDynTree/EigenSparseHelpers.h" bodystart="25" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="EigenSparseHelpers_8h_1a90ae57e2a42e7bad1cedda56db4ee3d4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; Eigen::SparseMatrix&lt; double, Eigen::ColMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::SparseMatrix&lt;double, Eigen::ColMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(iDynTree::SparseMatrix&lt; iDynTree::ColumnMajor &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type><ref refid="classiDynTree_1_1SparseMatrix" kindref="compound">iDynTree::SparseMatrix</ref>&lt; iDynTree::ColumnMajor &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenSparseHelpers.h" line="36" column="19" bodyfile="iDynTree/EigenSparseHelpers.h" bodystart="36" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="EigenSparseHelpers_8h_1ae48cfcc0f75e51f21ae1ac34de84efc1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; const Eigen::SparseMatrix&lt; double, Eigen::ColMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt;const Eigen::SparseMatrix&lt;double, Eigen::ColMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(const iDynTree::SparseMatrix&lt; iDynTree::ColumnMajor &gt; &amp;mat)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SparseMatrix" kindref="compound">iDynTree::SparseMatrix</ref>&lt; iDynTree::ColumnMajor &gt; &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/EigenSparseHelpers.h" line="47" column="19" bodyfile="iDynTree/EigenSparseHelpers.h" bodystart="47" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="MatrixView_8h_1ae51124a635564fed29ab419da3ec3dcf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; ElementType &gt;</type>
        <definition>IDYNTREE_CONSTEXPR MatrixView&lt;ElementType&gt; iDynTree::make_matrix_view</definition>
        <argsstring>(ElementType *ptr, typename MatrixView&lt; ElementType &gt;::index_type rows, typename MatrixView&lt; ElementType &gt;::index_type cols, const MatrixStorageOrdering &amp;order=MatrixStorageOrdering::RowMajor)</argsstring>
        <name>make_matrix_view</name>
        <param>
          <type>ElementType *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>typename <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; ElementType &gt;::index_type</type>
          <declname>rows</declname>
        </param>
        <param>
          <type>typename <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; ElementType &gt;::index_type</type>
          <declname>cols</declname>
        </param>
        <param>
          <type>const MatrixStorageOrdering &amp;</type>
          <declname>order</declname>
          <defval>MatrixStorageOrdering::RowMajor</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixView.h" line="250" column="5" bodyfile="iDynTree/MatrixView.h" bodystart="250" bodyend="256"/>
      </memberdef>
      <memberdef kind="function" id="MatrixView_8h_1a6bbb3790549d807aa71d5ed22512411f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; MatrixViewInternal::has_IsRowMajor&lt; Container &gt;::value||std::is_same&lt; MatrixView&lt; typename Container::value_type &gt;, Container &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; typename Container::value_type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR MatrixView&lt;typename Container::value_type&gt; iDynTree::make_matrix_view</definition>
        <argsstring>(Container &amp;cont)</argsstring>
        <name>make_matrix_view</name>
        <param>
          <type>Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixView.h" line="263" column="35" bodyfile="iDynTree/MatrixView.h" bodystart="263" bodyend="266"/>
      </memberdef>
      <memberdef kind="function" id="MatrixView_8h_1ace02c0a5e7df4f19a28615bbea0b2d49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; MatrixViewInternal::has_IsRowMajor&lt; Container &gt;::value||std::is_same&lt; MatrixView&lt; const typename Container::value_type &gt;, Container &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; const typename Container::value_type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR MatrixView&lt;const typename Container::value_type&gt; iDynTree::make_matrix_view</definition>
        <argsstring>(const Container &amp;cont)</argsstring>
        <name>make_matrix_view</name>
        <param>
          <type>const Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixView.h" line="273" column="35" bodyfile="iDynTree/MatrixView.h" bodystart="273" bodyend="276"/>
      </memberdef>
      <memberdef kind="function" id="MatrixView_8h_1a60ffec30976d99d36dda278b50600853" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; !MatrixViewInternal::has_IsRowMajor&lt; Container &gt;::value &amp;&amp;!std::is_same&lt; MatrixView&lt; typename Container::value_type &gt;, Container &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; typename Container::value_type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR MatrixView&lt;typename Container::value_type&gt; iDynTree::make_matrix_view</definition>
        <argsstring>(Container &amp;cont, const MatrixStorageOrdering &amp;order=MatrixStorageOrdering::RowMajor)</argsstring>
        <name>make_matrix_view</name>
        <param>
          <type>Container &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>const MatrixStorageOrdering &amp;</type>
          <declname>order</declname>
          <defval>MatrixStorageOrdering::RowMajor</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixView.h" line="284" column="5" bodyfile="iDynTree/MatrixView.h" bodystart="284" bodyend="288"/>
      </memberdef>
      <memberdef kind="function" id="MatrixView_8h_1a6c7864c31a89d1f9f3a5196a21d8cf23" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; !MatrixViewInternal::has_IsRowMajor&lt; Container &gt;::value &amp;&amp;!std::is_same&lt; MatrixView&lt; typename Container::value_type &gt;, Container &gt;::value, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1MatrixView" kindref="compound">MatrixView</ref>&lt; const typename Container::value_type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR MatrixView&lt;const typename Container::value_type&gt; iDynTree::make_matrix_view</definition>
        <argsstring>(const Container &amp;cont, const MatrixStorageOrdering &amp;order=MatrixStorageOrdering::RowMajor)</argsstring>
        <name>make_matrix_view</name>
        <param>
          <type>const Container &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>const MatrixStorageOrdering &amp;</type>
          <declname>order</declname>
          <defval>MatrixStorageOrdering::RowMajor</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/MatrixView.h" line="296" column="5" bodyfile="iDynTree/MatrixView.h" bodystart="296" bodyend="300"/>
      </memberdef>
      <memberdef kind="function" id="Position_8h_1aacc071e8e145a637bd7305dc9f120353" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::IDYNTREE_DEPRECATED_WITH_MSG</definition>
        <argsstring>(&quot;iDynTree::PositionRaw is deprecated, use iDynTree::Position&quot;) typedef Position PositionRaw</argsstring>
        <name>IDYNTREE_DEPRECATED_WITH_MSG</name>
        <param>
          <type>&quot;iDynTree::PositionRaw is</type>
          <declname>deprecated</declname>
        </param>
        <param>
          <type>use <ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref>&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Position.h" line="109" column="5" declfile="iDynTree/Position.h" declline="109" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="PrivateUtils_8h_1a5cb90836a26ae5bb773be45bad7dad54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d iDynTree::squareCrossProductMatrix</definition>
        <argsstring>(const Eigen::Vector3d &amp;v)</argsstring>
        <name>squareCrossProductMatrix</name>
        <param>
          <type>const Eigen::Vector3d &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Maps a 3d vector to the square of the cross product matrix: v --&gt; (v\times)^2 or, if you prefer another notation: v --&gt; S^2(v) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PrivateUtils.h" line="20" column="21" declfile="iDynTree/PrivateUtils.h" declline="20" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="PrivateUtils_8h_1a8dac2640419d7eaba00586c252ab99e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Eigen::Matrix3d</type>
        <definition>Eigen::Matrix3d iDynTree::skew</definition>
        <argsstring>(const Eigen::Vector3d &amp;vec)</argsstring>
        <name>skew</name>
        <param>
          <type>const Eigen::Vector3d &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>Maps a 3d vector to the cross product matrix: v --&gt; (v\times) or, if you prefer another notation: v --&gt; S(v) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PrivateUtils.h" line="28" column="21" declfile="iDynTree/PrivateUtils.h" declline="28" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="PrivateUtils_8h_1ab4c72168cc4cc9909da74c433345e8d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename vector6d</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::efficient6dCopy</definition>
        <argsstring>(vector6d *pthis, const vector6d &amp;other)</argsstring>
        <name>efficient6dCopy</name>
        <param>
          <type>vector6d *</type>
          <declname>pthis</declname>
        </param>
        <param>
          <type>const vector6d &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Efficient version of the copy from one 6D vector to another. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PrivateUtils.h" line="34" column="10" bodyfile="iDynTree/PrivateUtils.h" bodystart="34" bodyend="39"/>
      </memberdef>
      <memberdef kind="function" id="PrivateUtils_8h_1a9f173fe7a9b0aabdbfa0169513dd0afa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename vector6d</type>
          </param>
        </templateparamlist>
        <type>vector6d</type>
        <definition>vector6d iDynTree::efficient6dSum</definition>
        <argsstring>(const vector6d &amp;op1, const vector6d &amp;op2)</argsstring>
        <name>efficient6dSum</name>
        <param>
          <type>const vector6d &amp;</type>
          <declname>op1</declname>
        </param>
        <param>
          <type>const vector6d &amp;</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
<para>Efficient version of the sum of two 6D vectors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PrivateUtils.h" line="45" column="14" bodyfile="iDynTree/PrivateUtils.h" bodystart="45" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="PrivateUtils_8h_1ad44d09b939590fde0dca95ebd7f899c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename vector6d</type>
          </param>
        </templateparamlist>
        <type>vector6d</type>
        <definition>vector6d iDynTree::efficient6ddifference</definition>
        <argsstring>(const vector6d &amp;op1, const vector6d &amp;op2)</argsstring>
        <name>efficient6ddifference</name>
        <param>
          <type>const vector6d &amp;</type>
          <declname>op1</declname>
        </param>
        <param>
          <type>const vector6d &amp;</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
<para>Efficient version of the different of two 6D vectors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PrivateUtils.h" line="57" column="14" bodyfile="iDynTree/PrivateUtils.h" bodystart="57" bodyend="63"/>
      </memberdef>
      <memberdef kind="function" id="PrivateUtils_8h_1ada26d16396f1cd9f82b2e7c921fe202e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename twistType</type>
          </param>
          <param>
            <type>typename motionVectorType</type>
          </param>
          <param>
            <type>typename resultType</type>
          </param>
        </templateparamlist>
        <type>resultType</type>
        <definition>resultType iDynTree::efficientTwistCrossTwist</definition>
        <argsstring>(const twistType &amp;op1, const motionVectorType &amp;op2)</argsstring>
        <name>efficientTwistCrossTwist</name>
        <param>
          <type>const twistType &amp;</type>
          <declname>op1</declname>
        </param>
        <param>
          <type>const motionVectorType &amp;</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
<para>Efficient version of the cross product between a twist and a spatial motion vector (another twist, acceleration, ..) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PrivateUtils.h" line="70" column="16" bodyfile="iDynTree/PrivateUtils.h" bodystart="70" bodyend="81"/>
      </memberdef>
      <memberdef kind="function" id="PrivateUtils_8h_1a2941457a02de10e9de1dea4106588921" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename twistType</type>
          </param>
          <param>
            <type>typename momentumVectorType</type>
          </param>
          <param>
            <type>typename resultType</type>
          </param>
        </templateparamlist>
        <type>resultType</type>
        <definition>resultType iDynTree::efficientTwistCrossMomentum</definition>
        <argsstring>(const twistType &amp;op1, const momentumVectorType &amp;op2)</argsstring>
        <name>efficientTwistCrossMomentum</name>
        <param>
          <type>const twistType &amp;</type>
          <declname>op1</declname>
        </param>
        <param>
          <type>const momentumVectorType &amp;</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
<para>Efficient version of the cross product between a twist and a spatial force vector (momentum, wrench, ..) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/PrivateUtils.h" line="88" column="16" bodyfile="iDynTree/PrivateUtils.h" bodystart="88" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="Rotation_8h_1afc22a429e9fa472ce408d199475fa100" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::IDYNTREE_DEPRECATED_WITH_MSG</definition>
        <argsstring>(&quot;iDynTree::RotationRaw is deprecated, use iDynTree::Rotation&quot;) typedef Rotation RotationRaw</argsstring>
        <name>IDYNTREE_DEPRECATED_WITH_MSG</name>
        <param>
          <type>&quot;iDynTree::RotationRaw is</type>
          <declname>deprecated</declname>
        </param>
        <param>
          <type>use <ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref>&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Rotation.h" line="479" column="5" declfile="iDynTree/Rotation.h" declline="479" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="RotationalInertia_8h_1affa3ef6d96e03cfad96623d8d7dbcacf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::IDYNTREE_DEPRECATED_WITH_MSG</definition>
        <argsstring>(&quot;iDynTree::RotationalInertiaRaw is deprecated, use iDynTree::RotationalInertia&quot;) typedef RotationalInertia RotationalInertiaRaw</argsstring>
        <name>IDYNTREE_DEPRECATED_WITH_MSG</name>
        <param>
          <type>&quot;iDynTree::RotationalInertiaRaw is</type>
          <declname>deprecated</declname>
        </param>
        <param>
          <type>use <ref refid="classiDynTree_1_1RotationalInertia" kindref="compound">iDynTree::RotationalInertia</ref>&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/RotationalInertia.h" line="47" column="5" declfile="iDynTree/RotationalInertia.h" declline="47" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="SO3Utils_8h_1a72d7e0a9ca21815a7dadb8ea94f5aef4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::isValidRotationMatrix</definition>
        <argsstring>(const iDynTree::Rotation &amp;r)</argsstring>
        <name>isValidRotationMatrix</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref> &amp;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>Check if the rotation matrix is valid. </para>
        </briefdescription>
        <detaileddescription>
<para>It checks that the determinant is 1, that the Frobenius norm is finite and that it is orthogonal. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>The input rotation </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if it is a rotation matrix. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SO3Utils.h" line="33" column="10" declfile="iDynTree/SO3Utils.h" declline="33" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="SO3Utils_8h_1a7950f68e2a23c633dc53411db5b5b573" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double iDynTree::geodesicL2Distance</definition>
        <argsstring>(const iDynTree::Rotation &amp;rotation1, const iDynTree::Rotation &amp;rotation2)</argsstring>
        <name>geodesicL2Distance</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref> &amp;</type>
          <declname>rotation1</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref> &amp;</type>
          <declname>rotation2</declname>
        </param>
        <briefdescription>
<para>Computes the geodesic distance between two rotation matrices. </para>
        </briefdescription>
        <detaileddescription>
<para>It implements the angular distance presented in Sec. 4 of &quot;Rotation Averaging&quot; (available at <ulink url="http://users.cecs.anu.edu.au/~hongdong/rotationaveraging.pdf">http://users.cecs.anu.edu.au/~hongdong/rotationaveraging.pdf</ulink>), in particular <formula id="59">$d = ||log(R_1^\top R_2)||^2 $</formula>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rotation1</parametername>
</parameternamelist>
<parameterdescription>
<para>The first rotation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rotation2</parametername>
</parameternamelist>
<parameterdescription>
<para>The other rotation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the geodesic L2 distance between the two rotation matrices. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SO3Utils.h" line="44" column="12" declfile="iDynTree/SO3Utils.h" declline="44" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="SO3Utils_8h_1a2c019748c0b171a73279ba732546d87a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::geodesicL2MeanRotation</definition>
        <argsstring>(const std::vector&lt; iDynTree::Rotation &gt; &amp;inputRotations, iDynTree::Rotation &amp;meanRotation, const GeodesicL2MeanOptions &amp;options=GeodesicL2MeanOptions())</argsstring>
        <name>geodesicL2MeanRotation</name>
        <param>
          <type>const std::vector&lt; <ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref> &gt; &amp;</type>
          <declname>inputRotations</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref> &amp;</type>
          <declname>meanRotation</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1GeodesicL2MeanOptions" kindref="compound">GeodesicL2MeanOptions</ref> &amp;</type>
          <declname>options</declname>
          <defval><ref refid="structiDynTree_1_1GeodesicL2MeanOptions" kindref="compound">GeodesicL2MeanOptions</ref>()</defval>
        </param>
        <briefdescription>
<para>Computes the geodesic mean amongst the provided rotations. </para>
        </briefdescription>
        <detaileddescription>
<para>It implements Algorithm 1 in Sec. 5.3 of &quot;Rotation Averaging&quot; (available at <ulink url="http://users.cecs.anu.edu.au/~hongdong/rotationaveraging.pdf">http://users.cecs.anu.edu.au/~hongdong/rotationaveraging.pdf</ulink>).</para>
<para>Inside it calls geodesicL2WeightedMeanRotation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inputRotations</parametername>
</parameternamelist>
<parameterdescription>
<para>The rotations to average. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>meanRotation</parametername>
</parameternamelist>
<parameterdescription>
<para>The mean rotation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>options</parametername>
</parameternamelist>
<parameterdescription>
<para>The options for the inner optimization (refinement) loop. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>false in case of failure, true otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SO3Utils.h" line="58" column="10" declfile="iDynTree/SO3Utils.h" declline="58" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="SO3Utils_8h_1a07cf035073cc1e3f95ef18eda4928db5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::geodesicL2WeightedMeanRotation</definition>
        <argsstring>(const std::vector&lt; iDynTree::Rotation &gt; &amp;inputRotations, const std::vector&lt; double &gt; &amp;weights, iDynTree::Rotation &amp;meanRotation, const GeodesicL2MeanOptions &amp;options=GeodesicL2MeanOptions())</argsstring>
        <name>geodesicL2WeightedMeanRotation</name>
        <param>
          <type>const std::vector&lt; <ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref> &gt; &amp;</type>
          <declname>inputRotations</declname>
        </param>
        <param>
          <type>const std::vector&lt; double &gt; &amp;</type>
          <declname>weights</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref> &amp;</type>
          <declname>meanRotation</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1GeodesicL2MeanOptions" kindref="compound">GeodesicL2MeanOptions</ref> &amp;</type>
          <declname>options</declname>
          <defval><ref refid="structiDynTree_1_1GeodesicL2MeanOptions" kindref="compound">GeodesicL2MeanOptions</ref>()</defval>
        </param>
        <briefdescription>
<para>Computes the weighted geodesic mean amongst the provided rotations. </para>
        </briefdescription>
        <detaileddescription>
<para>It implements Algorithm 1 in Sec. 5.3 of &quot;Rotation Averaging&quot; (available at <ulink url="http://users.cecs.anu.edu.au/~hongdong/rotationaveraging.pdf">http://users.cecs.anu.edu.au/~hongdong/rotationaveraging.pdf</ulink>), with a small modification to take into accounts weights different from 1.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>inputRotations</parametername>
</parameternamelist>
<parameterdescription>
<para>The rotations to average. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>weights</parametername>
</parameternamelist>
<parameterdescription>
<para>The weights for each rotation. If this vector is null assumes that each weight is 1.0 (equivalent to geodesicL2MeanRotation) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>meanRotation</parametername>
</parameternamelist>
<parameterdescription>
<para>The weighted mean rotation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>options</parametername>
</parameternamelist>
<parameterdescription>
<para>The options for the inner optimization (refinement) loop. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>false in case of failure, true otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SO3Utils.h" line="74" column="10" declfile="iDynTree/SO3Utils.h" declline="74" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1affda5f6a0111301c3e8c09f46ae84887" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>std::ptrdiff_t</type>
            <declname>FirstExtent</declname>
            <defname>FirstExtent</defname>
          </param>
          <param>
            <type>std::ptrdiff_t</type>
            <declname>SecondExtent</declname>
            <defname>SecondExtent</defname>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR bool</type>
        <definition>IDYNTREE_CONSTEXPR bool iDynTree::operator==</definition>
        <argsstring>(Span&lt; ElementType, FirstExtent &gt; l, Span&lt; ElementType, SecondExtent &gt; r)</argsstring>
        <name>operator==</name>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, FirstExtent &gt;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, SecondExtent &gt;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="642" column="25" bodyfile="iDynTree/Span.h" bodystart="642" bodyend="646"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1abc78e202932a5b364ccc6952143736a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>std::ptrdiff_t</type>
            <declname>Extent</declname>
            <defname>Extent</defname>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR bool</type>
        <definition>IDYNTREE_CONSTEXPR bool iDynTree::operator!=</definition>
        <argsstring>(Span&lt; ElementType, Extent &gt; l, Span&lt; ElementType, Extent &gt; r)</argsstring>
        <name>operator!=</name>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="649" column="25" bodyfile="iDynTree/Span.h" bodystart="649" bodyend="653"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1a42627470960988b6f18ca9a7037dac03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>std::ptrdiff_t</type>
            <declname>Extent</declname>
            <defname>Extent</defname>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR bool</type>
        <definition>IDYNTREE_CONSTEXPR bool iDynTree::operator&lt;</definition>
        <argsstring>(Span&lt; ElementType, Extent &gt; l, Span&lt; ElementType, Extent &gt; r)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="656" column="20" bodyfile="iDynTree/Span.h" bodystart="656" bodyend="660"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1ae774056f8c53958ea2448c4921080471" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>std::ptrdiff_t</type>
            <declname>Extent</declname>
            <defname>Extent</defname>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR bool</type>
        <definition>IDYNTREE_CONSTEXPR bool iDynTree::operator&lt;=</definition>
        <argsstring>(Span&lt; ElementType, Extent &gt; l, Span&lt; ElementType, Extent &gt; r)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="663" column="20" bodyfile="iDynTree/Span.h" bodystart="663" bodyend="667"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1ac28edf035d889d4c6218848e5007d4ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>std::ptrdiff_t</type>
            <declname>Extent</declname>
            <defname>Extent</defname>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR bool</type>
        <definition>IDYNTREE_CONSTEXPR bool iDynTree::operator&gt;</definition>
        <argsstring>(Span&lt; ElementType, Extent &gt; l, Span&lt; ElementType, Extent &gt; r)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="670" column="25" bodyfile="iDynTree/Span.h" bodystart="670" bodyend="674"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1a249acd1b49049d01403046ea4fa61513" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>std::ptrdiff_t</type>
            <declname>Extent</declname>
            <defname>Extent</defname>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR bool</type>
        <definition>IDYNTREE_CONSTEXPR bool iDynTree::operator&gt;=</definition>
        <argsstring>(Span&lt; ElementType, Extent &gt; l, Span&lt; ElementType, Extent &gt; r)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>l</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, Extent &gt;</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="677" column="25" bodyfile="iDynTree/Span.h" bodystart="677" bodyend="681"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1afea09daa42453877437d4a0bfb11ce3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType &gt;</type>
        <definition>IDYNTREE_CONSTEXPR Span&lt;ElementType&gt; iDynTree::make_span</definition>
        <argsstring>(ElementType *ptr, typename Span&lt; ElementType &gt;::index_type count)</argsstring>
        <name>make_span</name>
        <param>
          <type>ElementType *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>typename <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType &gt;::index_type</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="714" column="25" bodyfile="iDynTree/Span.h" bodystart="714" bodyend="717"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1a32b250386639651e4c79f31d35094ca9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType &gt;</type>
        <definition>IDYNTREE_CONSTEXPR Span&lt;ElementType&gt; iDynTree::make_span</definition>
        <argsstring>(ElementType *firstElem, ElementType *lastElem)</argsstring>
        <name>make_span</name>
        <param>
          <type>ElementType *</type>
          <declname>firstElem</declname>
        </param>
        <param>
          <type>ElementType *</type>
          <declname>lastElem</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="720" column="25" bodyfile="iDynTree/Span.h" bodystart="720" bodyend="723"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1aef2273818c22b800f0296005f678539f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; ElementType, N &gt;</type>
        <definition>IDYNTREE_CONSTEXPR Span&lt;ElementType, N&gt; iDynTree::make_span</definition>
        <argsstring>(ElementType(&amp;arr)[N]) noexcept</argsstring>
        <name>make_span</name>
        <param>
          <type>ElementType(&amp;)</type>
          <declname>arr</declname>
          <array>[N]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="726" column="25" bodyfile="iDynTree/Span.h" bodystart="726" bodyend="729"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1ae39036a1440abb3b9e4897272394317a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; typename Container::value_type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR Span&lt;typename Container::value_type&gt; iDynTree::make_span</definition>
        <argsstring>(Container &amp;cont)</argsstring>
        <name>make_span</name>
        <param>
          <type>Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="732" column="25" bodyfile="iDynTree/Span.h" bodystart="732" bodyend="735"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1a9ecfc7eaccb7475c951c97cdf20a2b65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename std::enable_if&lt;SpanUtils::is_value_defined&lt;Container&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; const typename Container::value_type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR Span&lt;const typename Container::value_type&gt; iDynTree::make_span</definition>
        <argsstring>(const Container &amp;cont)</argsstring>
        <name>make_span</name>
        <param>
          <type>const Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="738" column="25" bodyfile="iDynTree/Span.h" bodystart="738" bodyend="741"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1a7f2bdb0504977bcc9abcd0790dbd3a10" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Ptr</type>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; typename Ptr::element_type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR Span&lt;typename Ptr::element_type&gt; iDynTree::make_span</definition>
        <argsstring>(Ptr &amp;cont, std::ptrdiff_t count)</argsstring>
        <name>make_span</name>
        <param>
          <type>Ptr &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>std::ptrdiff_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="744" column="25" bodyfile="iDynTree/Span.h" bodystart="744" bodyend="747"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1acaebdb9ef4dfce796979f9392e238616" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Ptr</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename std::enable_if&lt;!SpanUtils::is_value_defined&lt;Ptr&gt;::value &amp;&amp; SpanUtils::is_element_defined&lt;Ptr&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; typename Ptr::element_type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR Span&lt;typename Ptr::element_type&gt; iDynTree::make_span</definition>
        <argsstring>(Ptr &amp;cont)</argsstring>
        <name>make_span</name>
        <param>
          <type>Ptr &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="750" column="25" bodyfile="iDynTree/Span.h" bodystart="750" bodyend="753"/>
      </memberdef>
      <memberdef kind="function" id="Span_8h_1a30a50da99346e81a568b2d5629347b92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Container</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename std::enable_if&lt;!SpanUtils::is_value_defined&lt;Container&gt;::value &amp;&amp;                                                             !SpanUtils::is_element_defined&lt;Container&gt;::value &amp;&amp;                                                             SpanUtils::has_data_method&lt;Container&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type>IDYNTREE_CONSTEXPR <ref refid="classiDynTree_1_1Span" kindref="compound">Span</ref>&lt; typename std::remove_pointer&lt; decltype(std::declval&lt; Container &gt;).data())&gt;::type &gt;</type>
        <definition>IDYNTREE_CONSTEXPR Span&lt;typename std::remove_pointer&lt;decltype (std::declval&lt;Container&gt;).data())&gt;::type&gt; iDynTree::make_span</definition>
        <argsstring>(Container &amp;cont)</argsstring>
        <name>make_span</name>
        <param>
          <type>Container &amp;</type>
          <declname>cont</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Span.h" line="758" column="28" bodyfile="iDynTree/Span.h" bodystart="758" bodyend="761"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a668ee99a790b7af845958d4673161135" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::assertStringAreEqual</definition>
        <argsstring>(const std::string &amp;val1, const std::string &amp;val2, double tol=DEFAULT_TOL, std::string file=&quot;&quot;, int line=-1)</argsstring>
        <name>assertStringAreEqual</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>val1</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>val2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tol</declname>
          <defval>DEFAULT_TOL</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="59" column="10" declfile="iDynTree/TestUtils.h" declline="59" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a274077496ffac0ee45107923c3fe9cee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::assertDoubleAreEqual</definition>
        <argsstring>(const double &amp;val1, const double &amp;val2, double tol=DEFAULT_TOL, std::string file=&quot;&quot;, int line=-1)</argsstring>
        <name>assertDoubleAreEqual</name>
        <param>
          <type>const double &amp;</type>
          <declname>val1</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>val2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tol</declname>
          <defval>DEFAULT_TOL</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="62" column="10" declfile="iDynTree/TestUtils.h" declline="62" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1ac18550f459dae84f3a502274b39193cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::assertTransformsAreEqual</definition>
        <argsstring>(const Transform &amp;trans1, const Transform &amp;trans2, double tol=DEFAULT_TOL, std::string file=&quot;&quot;, int line=-1)</argsstring>
        <name>assertTransformsAreEqual</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>trans1</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>trans2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tol</declname>
          <defval>DEFAULT_TOL</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Assert that two transforms are equal, and exit with EXIT_FAILURE if they are not. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="69" column="10" declfile="iDynTree/TestUtils.h" declline="69" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1ae326a16295b6efe5e6023665cb2a012f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::assertSpatialMotionAreEqual</definition>
        <argsstring>(const SpatialMotionVector &amp;t1, const SpatialMotionVector &amp;t2, double tol=DEFAULT_TOL, std::string file=&quot;&quot;, int line=-1)</argsstring>
        <name>assertSpatialMotionAreEqual</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>t1</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>t2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tol</declname>
          <defval>DEFAULT_TOL</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Assert that two spatial motion vectors are equal, and exit with EXIT_FAILURE if they are not. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="76" column="10" declfile="iDynTree/TestUtils.h" declline="76" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a0c0a527efda465b7b190e726c148b5dc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::assertSpatialForceAreEqual</definition>
        <argsstring>(const SpatialForceVector &amp;f1, const SpatialForceVector &amp;f2, double tol=DEFAULT_TOL, std::string file=&quot;&quot;, int line=-1)</argsstring>
        <name>assertSpatialForceAreEqual</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> &amp;</type>
          <declname>f1</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> &amp;</type>
          <declname>f2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tol</declname>
          <defval>DEFAULT_TOL</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
<para>Assert that two spatial force vectors are equal, and exit with EXIT_FAILURE if they are not. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="83" column="10" declfile="iDynTree/TestUtils.h" declline="83" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a1289062400b0dd99e49653356d569e8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::assertTrue</definition>
        <argsstring>(bool prop, std::string file=&quot;&quot;, int line=-1)</argsstring>
        <name>assertTrue</name>
        <param>
          <type>bool</type>
          <declname>prop</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
          <defval>-1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="85" column="10" declfile="iDynTree/TestUtils.h" declline="85" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a2296e58922e46f4fc2d91689f9e59da9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::getRandomBool</definition>
        <argsstring>()</argsstring>
        <name>getRandomBool</name>
        <briefdescription>
<para>Get random bool. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="90" column="10" declfile="iDynTree/TestUtils.h" declline="90" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a051e689c0d7974b18929629680c95619" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double iDynTree::getRandomDouble</definition>
        <argsstring>(double min=0.0, double max=1.0)</argsstring>
        <name>getRandomDouble</name>
        <param>
          <type>double</type>
          <declname>min</declname>
          <defval>0.0</defval>
        </param>
        <param>
          <type>double</type>
          <declname>max</declname>
          <defval>1.0</defval>
        </param>
        <briefdescription>
<para>Get a random double between min and max . </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="95" column="12" declfile="iDynTree/TestUtils.h" declline="95" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1ab3920b4ee524d6bb9062435d7c9d7065" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int iDynTree::getRandomInteger</definition>
        <argsstring>(int min, int max)</argsstring>
        <name>getRandomInteger</name>
        <param>
          <type>int</type>
          <declname>min</declname>
        </param>
        <param>
          <type>int</type>
          <declname>max</declname>
        </param>
        <briefdescription>
<para>Get a random integer between min and max (included). </para>
        </briefdescription>
        <detaileddescription>
<para>For example a dice could be simulated with getRandomInteger(1,6); </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="101" column="9" declfile="iDynTree/TestUtils.h" declline="101" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a30e37efb8be6e98f4bf9aabd7493748c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VectorType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::getRandomVector</definition>
        <argsstring>(VectorType &amp;vec, double min=0.0, double max=1.0)</argsstring>
        <name>getRandomVector</name>
        <param>
          <type>VectorType &amp;</type>
          <declname>vec</declname>
        </param>
        <param>
          <type>double</type>
          <declname>min</declname>
          <defval>0.0</defval>
        </param>
        <param>
          <type>double</type>
          <declname>max</declname>
          <defval>1.0</defval>
        </param>
        <briefdescription>
<para>Fill a vector with random double. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="107" column="10" bodyfile="iDynTree/TestUtils.h" bodystart="107" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a8960c4bd871d87f67470f2ab8f8b5e8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MatrixType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::getRandomMatrix</definition>
        <argsstring>(MatrixType &amp;mat)</argsstring>
        <name>getRandomMatrix</name>
        <param>
          <type>MatrixType &amp;</type>
          <declname>mat</declname>
        </param>
        <briefdescription>
<para>Fill a matrix of random doubles. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="119" column="10" bodyfile="iDynTree/TestUtils.h" bodystart="119" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a553049a8d951cbad14dd59168935a7b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref></type>
        <definition>Position iDynTree::getRandomPosition</definition>
        <argsstring>()</argsstring>
        <name>getRandomPosition</name>
        <briefdescription>
<para>Get a random position. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="133" column="14" declfile="iDynTree/TestUtils.h" declline="133" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a9929fdbd53800f02bd76305f9d985942" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation iDynTree::getRandomRotation</definition>
        <argsstring>()</argsstring>
        <name>getRandomRotation</name>
        <briefdescription>
<para>Get a random rotation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="138" column="14" declfile="iDynTree/TestUtils.h" declline="138" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a977a15d73114a87fd6705dd9a8f7c736" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref></type>
        <definition>Transform iDynTree::getRandomTransform</definition>
        <argsstring>()</argsstring>
        <name>getRandomTransform</name>
        <briefdescription>
<para>Get a random transform. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="143" column="15" declfile="iDynTree/TestUtils.h" declline="143" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1ae4c3a6982c0bec99386eb3f4c05632d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Axis" kindref="compound">Axis</ref></type>
        <definition>Axis iDynTree::getRandomAxis</definition>
        <argsstring>()</argsstring>
        <name>getRandomAxis</name>
        <briefdescription>
<para>Get a random axis. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="148" column="10" declfile="iDynTree/TestUtils.h" declline="148" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a293fa271f52f72d795f4858b34273ed6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref></type>
        <definition>SpatialInertia iDynTree::getRandomInertia</definition>
        <argsstring>()</argsstring>
        <name>getRandomInertia</name>
        <briefdescription>
<para>Get a random (but physically consistent) inertia. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="153" column="20" declfile="iDynTree/TestUtils.h" declline="153" declcolumn="20"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a088ed6a480496334ee1dd51f088c6bb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref></type>
        <definition>SpatialMotionVector iDynTree::getRandomTwist</definition>
        <argsstring>()</argsstring>
        <name>getRandomTwist</name>
        <briefdescription>
<para>Get a random twist-like 6D vector. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="158" column="25" declfile="iDynTree/TestUtils.h" declline="158" declcolumn="25"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a04bcdc7077b46c1944825327875cb65b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref></type>
        <definition>SpatialForceVector iDynTree::getRandomWrench</definition>
        <argsstring>()</argsstring>
        <name>getRandomWrench</name>
        <briefdescription>
<para>Get a random wrench-like 6D object. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="163" column="24" declfile="iDynTree/TestUtils.h" declline="163" declcolumn="24"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a91197a36381e2fa990a0b54da40abee9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VectorType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::printVector</definition>
        <argsstring>(std::string, const VectorType &amp;vec)</argsstring>
        <name>printVector</name>
        <param>
          <type>std::string</type>
        </param>
        <param>
          <type>const VectorType &amp;</type>
          <declname>vec</declname>
        </param>
        <briefdescription>
<para>Helper for printing vectors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="169" column="10" bodyfile="iDynTree/TestUtils.h" bodystart="169" bodyend="176"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a2e5af240e2fab62a2527d450c4bdcabd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VectorType1</type>
          </param>
          <param>
            <type>typename VectorType2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::printVectorDifference</definition>
        <argsstring>(std::string name, const VectorType1 &amp;vec1, const VectorType2 &amp;vec2)</argsstring>
        <name>printVectorDifference</name>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>const VectorType1 &amp;</type>
          <declname>vec1</declname>
        </param>
        <param>
          <type>const VectorType2 &amp;</type>
          <declname>vec2</declname>
        </param>
        <briefdescription>
<para>Helper for printing difference of two vectors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="182" column="10" bodyfile="iDynTree/TestUtils.h" bodystart="182" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1aa25d97acb2792de12937a70d01e75ae7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::printVectorWrongElements</definition>
        <argsstring>(std::string name, std::vector&lt; bool &gt; &amp;correctElems)</argsstring>
        <name>printVectorWrongElements</name>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; bool &gt; &amp;</type>
          <declname>correctElems</declname>
        </param>
        <briefdescription>
<para>Helper for printing the patter of wrong elements in between two vectors. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="202" column="17" bodyfile="iDynTree/TestUtils.h" bodystart="202" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a456896bb82abd7daca7ac57546380e94" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::printMatrixWrongElements</definition>
        <argsstring>(std::string name, std::vector&lt; std::vector&lt; TestMatrixMismatch &gt; &gt; &amp;correctElems)</argsstring>
        <name>printMatrixWrongElements</name>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::vector&lt; <ref refid="structiDynTree_1_1TestMatrixMismatch" kindref="compound">TestMatrixMismatch</ref> &gt; &gt; &amp;</type>
          <declname>correctElems</declname>
        </param>
        <briefdescription>
<para>Helper for printing the patter of wrong elements in between two matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="223" column="17" bodyfile="iDynTree/TestUtils.h" bodystart="223" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a004eafd55ec8125ba2842dc2458088be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MatrixType1</type>
          </param>
          <param>
            <type>typename MatrixType2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::printMatrixPercentageError</definition>
        <argsstring>(const MatrixType1 &amp;mat1, const MatrixType2 &amp;mat2)</argsstring>
        <name>printMatrixPercentageError</name>
        <param>
          <type>const MatrixType1 &amp;</type>
          <declname>mat1</declname>
        </param>
        <param>
          <type>const MatrixType2 &amp;</type>
          <declname>mat2</declname>
        </param>
        <briefdescription>
<para>Helper for printing the patter of wrong elements in between two matrix. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="260" column="10" bodyfile="iDynTree/TestUtils.h" bodystart="260" bodyend="276"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1aa20d8a80e1de786a905ee0e897e45586" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VectorType1</type>
          </param>
          <param>
            <type>typename VectorType2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::assertVectorAreEqual</definition>
        <argsstring>(const VectorType1 &amp;vec1, const VectorType2 &amp;vec2, double tol, std::string file, int line)</argsstring>
        <name>assertVectorAreEqual</name>
        <param>
          <type>const VectorType1 &amp;</type>
          <declname>vec1</declname>
        </param>
        <param>
          <type>const VectorType2 &amp;</type>
          <declname>vec2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
        </param>
        <briefdescription>
<para>Assert that two vectors are equal, and exit with EXIT_FAILURE if they are not. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="284" column="10" bodyfile="iDynTree/TestUtils.h" bodystart="284" bodyend="314"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1a6b4c4d79f076ed9013708a5ab40e9273" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VectorType1</type>
          </param>
          <param>
            <type>typename VectorType2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::assertVectorAreEqualWithRelativeTol</definition>
        <argsstring>(const VectorType1 &amp;vec1, const VectorType2 &amp;vec2, double relativeTol, double minAbsoluteTol, std::string file, int line)</argsstring>
        <name>assertVectorAreEqualWithRelativeTol</name>
        <param>
          <type>const VectorType1 &amp;</type>
          <declname>vec1</declname>
        </param>
        <param>
          <type>const VectorType2 &amp;</type>
          <declname>vec2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>relativeTol</declname>
        </param>
        <param>
          <type>double</type>
          <declname>minAbsoluteTol</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
        </param>
        <briefdescription>
<para>Assert that two vectors are equal, and exit with EXIT_FAILURE if they are not. </para>
        </briefdescription>
        <detaileddescription>
<para>The tolerance passed in this function is a relative tolerance on the max element of the comparison, i.e. absoluteTol = max(relativeTol*max(val1,val2), minAbsoluteTol) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="323" column="10" bodyfile="iDynTree/TestUtils.h" bodystart="323" bodyend="354"/>
      </memberdef>
      <memberdef kind="function" id="TestUtils_8h_1ac3a22c22491b65545bdfbab336950530" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MatrixType1</type>
          </param>
          <param>
            <type>typename MatrixType2</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::assertMatrixAreEqual</definition>
        <argsstring>(const MatrixType1 &amp;mat1, const MatrixType2 &amp;mat2, double tol, std::string file, int line)</argsstring>
        <name>assertMatrixAreEqual</name>
        <param>
          <type>const MatrixType1 &amp;</type>
          <declname>mat1</declname>
        </param>
        <param>
          <type>const MatrixType2 &amp;</type>
          <declname>mat2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tol</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>file</declname>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
        </param>
        <briefdescription>
<para>Assert that two matrices are equal, and exit with EXIT_FAILURE if they are not. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/TestUtils.h" line="362" column="10" bodyfile="iDynTree/TestUtils.h" bodystart="362" bodyend="398"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1ac967fe3c6f3c26e946fe2f70ee6f3af9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::assertWoAbort</definition>
        <argsstring>(const char *semCheck, const char *file, const char *func, int line)</argsstring>
        <name>assertWoAbort</name>
        <param>
          <type>const char *</type>
          <declname>semCheck</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>file</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>func</declname>
        </param>
        <param>
          <type>int</type>
          <declname>line</declname>
        </param>
        <briefdescription>
<para>Function embedding the semantic checks. </para>
        </briefdescription>
        <detaileddescription>
<para>This function can throw an exception if the semantic check detects an error (returns False). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="49" column="10" declfile="iDynTree/Utils.h" declline="49" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1af82eb4858f1f94dbcf92a68210e17593" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::checkEqualOrUnknown</definition>
        <argsstring>(const int op1, const int op2)</argsstring>
        <name>checkEqualOrUnknown</name>
        <param>
          <type>const int</type>
          <declname>op1</declname>
        </param>
        <param>
          <type>const int</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
<para>Helper class for semantic checking. </para>
        </briefdescription>
        <detaileddescription>
<para>Return true if two values are equal, or if one of the two is unknown All negative values are used for represent an unknown value. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="57" column="10" declfile="iDynTree/Utils.h" declline="57" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1ab710bc576b963cce44ee3a97a0d37df5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::reportError</definition>
        <argsstring>(const char *className, const char *methodName, const char *errorMessage)</argsstring>
        <name>reportError</name>
        <param>
          <type>const char *</type>
          <declname>className</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>methodName</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>errorMessage</declname>
        </param>
        <briefdescription>
<para>Helper function for reporting error if the semantic check fails. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="63" column="10" declfile="iDynTree/Utils.h" declline="63" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1a1b924287a0557e41bb16704961399f68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::reportErrorIf</definition>
        <argsstring>(bool condition, const char *className_methodName, const char *errorMessage)</argsstring>
        <name>reportErrorIf</name>
        <param>
          <type>bool</type>
          <declname>condition</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>className_methodName</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>errorMessage</declname>
        </param>
        <briefdescription>
<para>Call report error if condition is true. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="68" column="10" declfile="iDynTree/Utils.h" declline="68" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1ad1ad9933bf06265120db1feecb34ac9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::reportWarning</definition>
        <argsstring>(const char *className, const char *methodName, const char *errorMessage)</argsstring>
        <name>reportWarning</name>
        <param>
          <type>const char *</type>
          <declname>className</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>methodName</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>errorMessage</declname>
        </param>
        <briefdescription>
<para>Helper function for reporting warnings in iDynTree. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="74" column="10" declfile="iDynTree/Utils.h" declline="74" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1a6260625e944d3b34a7db5730dbd11d21" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::reportInfo</definition>
        <argsstring>(const char *className, const char *methodName, const char *message)</argsstring>
        <name>reportInfo</name>
        <param>
          <type>const char *</type>
          <declname>className</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>methodName</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>message</declname>
        </param>
        <briefdescription>
<para>Helper function for reporting information messages in iDynTree. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="80" column="10" declfile="iDynTree/Utils.h" declline="80" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1a34f0ca347ac5bfae3a50fe09ccd787d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::reportDebug</definition>
        <argsstring>(const char *className, const char *methodName, const char *message)</argsstring>
        <name>reportDebug</name>
        <param>
          <type>const char *</type>
          <declname>className</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>methodName</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>message</declname>
        </param>
        <briefdescription>
<para>Helper function for reporting debug messages in iDynTree. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="86" column="10" declfile="iDynTree/Utils.h" declline="86" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1a2099697a85abd10017e2ab2ca9f3336e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double iDynTree::deg2rad</definition>
        <argsstring>(const double valueInDeg)</argsstring>
        <name>deg2rad</name>
        <param>
          <type>const double</type>
          <declname>valueInDeg</declname>
        </param>
        <briefdescription>
<para>Convert a double from degrees to radians. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="91" column="12" declfile="iDynTree/Utils.h" declline="91" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1a3ffc4d06e77379cc44c32f2ea44df1d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double iDynTree::rad2deg</definition>
        <argsstring>(const double valueInRad)</argsstring>
        <name>rad2deg</name>
        <param>
          <type>const double</type>
          <declname>valueInRad</declname>
        </param>
        <briefdescription>
<para>Convert a double from radians to degree. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="96" column="12" declfile="iDynTree/Utils.h" declline="96" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="Utils_8h_1a3f330bf40f3d09799c2b4923f79173ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::checkDoublesAreEqual</definition>
        <argsstring>(const double &amp;val1, const double &amp;val2, double tol=DEFAULT_TOL)</argsstring>
        <name>checkDoublesAreEqual</name>
        <param>
          <type>const double &amp;</type>
          <declname>val1</declname>
        </param>
        <param>
          <type>const double &amp;</type>
          <declname>val2</declname>
        </param>
        <param>
          <type>double</type>
          <declname>tol</declname>
          <defval>DEFAULT_TOL</defval>
        </param>
        <briefdescription>
<para>Check whether two doubles are equal given a tolerance tol. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Utils.h" line="125" column="10" declfile="iDynTree/Utils.h" declline="125" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="InverseKinematics_8h_1a399f5a8eff425f1036038ee927fb81cb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int iDynTree::sizeOfRotationParametrization</definition>
        <argsstring>(enum InverseKinematicsRotationParametrization rotationParametrization)</argsstring>
        <name>sizeOfRotationParametrization</name>
        <param>
          <type>enum InverseKinematicsRotationParametrization</type>
          <declname>rotationParametrization</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/InverseKinematics.h" line="48" column="16" bodyfile="iDynTree/InverseKinematics.h" bodystart="48" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="BerdyHelper_8h_1a39f8730ab92b19678c82e418b8c0f2a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::isLinkBerdyDynamicVariable</definition>
        <argsstring>(const BerdyDynamicVariablesTypes dynamicVariableType)</argsstring>
        <name>isLinkBerdyDynamicVariable</name>
        <param>
          <type>const <ref refid="group__iDynTreeExperimental_1ga83d8f828969dabc7dc82904d8de15312" kindref="member">BerdyDynamicVariablesTypes</ref></type>
          <declname>dynamicVariableType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/BerdyHelper.h" line="141" column="6" declfile="iDynTree/BerdyHelper.h" declline="141" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="BerdyHelper_8h_1a1d21c6d1ea587b6ed88d52bdf43fcf8b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::isJointBerdyDynamicVariable</definition>
        <argsstring>(const BerdyDynamicVariablesTypes dynamicVariableType)</argsstring>
        <name>isJointBerdyDynamicVariable</name>
        <param>
          <type>const <ref refid="group__iDynTreeExperimental_1ga83d8f828969dabc7dc82904d8de15312" kindref="member">BerdyDynamicVariablesTypes</ref></type>
          <declname>dynamicVariableType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/BerdyHelper.h" line="142" column="6" declfile="iDynTree/BerdyHelper.h" declline="142" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="BerdyHelper_8h_1a517a9e2101a59831cf912d8559b4900c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::isDOFBerdyDynamicVariable</definition>
        <argsstring>(const BerdyDynamicVariablesTypes dynamicVariableType)</argsstring>
        <name>isDOFBerdyDynamicVariable</name>
        <param>
          <type>const <ref refid="group__iDynTreeExperimental_1ga83d8f828969dabc7dc82904d8de15312" kindref="member">BerdyDynamicVariablesTypes</ref></type>
          <declname>dynamicVariableType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/BerdyHelper.h" line="143" column="6" declfile="iDynTree/BerdyHelper.h" declline="143" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ExternalWrenchesEstimation_8h_1ad96bdadc6f50434261b8fdab971904e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::estimateExternalWrenchesWithoutInternalFT</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const LinkUnknownWrenchContacts &amp;unknownWrenches, const JointPosDoubleArray &amp;jointPos, const LinkVelArray &amp;linkVel, const LinkAccArray &amp;linkProperAcc, estimateExternalWrenchesBuffers &amp;bufs, LinkContactWrenches &amp;outputContactWrenches)</argsstring>
        <name>estimateExternalWrenchesWithoutInternalFT</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkUnknownWrenchContacts" kindref="compound">LinkUnknownWrenchContacts</ref> &amp;</type>
          <declname>unknownWrenches</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>linkProperAcc</declname>
        </param>
        <param>
          <type><ref refid="structiDynTree_1_1estimateExternalWrenchesBuffers" kindref="compound">estimateExternalWrenchesBuffers</ref> &amp;</type>
          <declname>bufs</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkContactWrenches" kindref="compound">LinkContactWrenches</ref> &amp;</type>
          <declname>outputContactWrenches</declname>
        </param>
        <briefdescription>
<para>Estimate the external contact wrenches using the MultiBody Newton-Euler equations. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is used to estimate the external contacts forces <bold>without</bold> using any measurement of the internal FT sensors. It is tipically used to get data for calibrating the offset of the internal FT sensors. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ExternalWrenchesEstimation.h" line="261" column="6" declfile="iDynTree/ExternalWrenchesEstimation.h" declline="261" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ExternalWrenchesEstimation_8h_1a4c628669d7801fee070c5ac32312b45d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::estimateExternalWrenches</definition>
        <argsstring>(const Model &amp;model, const SubModelDecomposition &amp;subModels, const SensorsList &amp;sensors, const LinkUnknownWrenchContacts &amp;unknownWrenches, const JointPosDoubleArray &amp;jointPos, const LinkVelArray &amp;linkVel, const LinkAccArray &amp;linkProperAcc, const SensorsMeasurements &amp;ftSensorsMeasurements, estimateExternalWrenchesBuffers &amp;bufs, LinkContactWrenches &amp;outputContactWrenches)</argsstring>
        <name>estimateExternalWrenches</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SubModelDecomposition" kindref="compound">SubModelDecomposition</ref> &amp;</type>
          <declname>subModels</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SensorsList" kindref="compound">SensorsList</ref> &amp;</type>
          <declname>sensors</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkUnknownWrenchContacts" kindref="compound">LinkUnknownWrenchContacts</ref> &amp;</type>
          <declname>unknownWrenches</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>linkProperAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SensorsMeasurements" kindref="compound">SensorsMeasurements</ref> &amp;</type>
          <declname>ftSensorsMeasurements</declname>
        </param>
        <param>
          <type><ref refid="structiDynTree_1_1estimateExternalWrenchesBuffers" kindref="compound">estimateExternalWrenchesBuffers</ref> &amp;</type>
          <declname>bufs</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkContactWrenches" kindref="compound">LinkContactWrenches</ref> &amp;</type>
          <declname>outputContactWrenches</declname>
        </param>
        <briefdescription>
<para>Estimate the external wrenches trasmitted by the contacts between the model and the external environment. </para>
        </briefdescription>
        <detaileddescription>
<para>This function exploits the measurements of internal FT sensors (whose structure is contained in the sensors parameters and which measurements are contained in the ftSensorsMeasurements parameters) to compute an estimation of the values of the unknown wrenches specified in the unknownWrenches parameter.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the considered model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">subModels</parametername>
</parameternamelist>
<parameterdescription>
<para>a decomposition of the model along the joint of the six axis F/T sensors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sensors</parametername>
</parameternamelist>
<parameterdescription>
<para>a description of the sensors available in the model. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">unknownWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>a description of the contacts for which the contact wrench is unknown. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector of link twists, expressed w.r.t to the link orientation and the link origin </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector of link spatial (in the Featherstone sense) and proper accelerations, expressed w.r.t to the link orientation and the link origin </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">ftSensorsMeasurements</parametername>
</parameternamelist>
<parameterdescription>
<para>the measurements of the internal six axis F/T sensors. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">outputContactWrenches</parametername>
</parameternamelist>
<parameterdescription>
<para>the estimated contact wrenches. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went well (the dimension of the inputs are consistent), false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ExternalWrenchesEstimation.h" line="289" column="6" declfile="iDynTree/ExternalWrenchesEstimation.h" declline="289" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ExternalWrenchesEstimation_8h_1a4552fdf67855209419f189466fbb8e69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::dynamicsEstimationForwardVelAccKinematics</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const Vector3 &amp;base_classicalProperAcc, const Vector3 &amp;base_angularVel, const Vector3 &amp;base_angularAcc, const JointPosDoubleArray &amp;jointPos, const JointDOFsDoubleArray &amp;jointVel, const JointDOFsDoubleArray &amp;jointAcc, LinkVelArray &amp;linkVel, LinkAccArray &amp;linkProperAcc)</argsstring>
        <name>dynamicsEstimationForwardVelAccKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref> &amp;</type>
          <declname>base_classicalProperAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref> &amp;</type>
          <declname>base_angularVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref> &amp;</type>
          <declname>base_angularAcc</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointDOFsDoubleArray" kindref="compound">JointDOFsDoubleArray</ref> &amp;</type>
          <declname>jointVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointDOFsDoubleArray" kindref="compound">JointDOFsDoubleArray</ref> &amp;</type>
          <declname>jointAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>linkProperAcc</declname>
        </param>
        <briefdescription>
<para>Modified forward kinematics for torque/force estimation. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a version of forward kinematics modified to fit the needs of joint torques/external wrenches estimation.</para>
<para>There are several difference with respect to the classical forward kinematics. The first one is that the only inputs necessary related to the base link are the base link classical proper acceleration, the base link angular velocity and the base link angular acceleration. This is because the dynamics of an articulated system does not depend on an offset in linear velocity, and hence the estimation of joint torques/external wrenches is not affected by the base link linear velocity. This will mean that the link velocitity computed by this algorithm are not the velocity of the links with respect to an inertial frame. Nevertherless they can still be used for estimation.</para>
<para>There are two main ways in which the base information is computed: one is exploiting the knoledge that a link is not moving with respect to an inertial frame: in this case the classical proper acceleration boils down to the inverted gravitational acceleration, while the angular velocity and angular accelerations are equal to zero. The other way is to exploit the measure of an accelerometer and of a gyroscope mounted on the base link of the traversal: the accelerometer will then measure directly the classical proper acceleration, while the gyroscope will measure the angular velocity. The angular acceleration can be computed by numerical derivation, or simply neglected if its effect on the estimation is minimal.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the input model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the traversal used to propagate the velocity and the proper acceleration </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">base_classicalProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>classical proper acceleration of the base origin </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">base_angularVel</parametername>
</parameternamelist>
<parameterdescription>
<para>angular velocity of the base link frame </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">base_angularAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>angular acceleration of the base link frame </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointPos</parametername>
</parameternamelist>
<parameterdescription>
<para>joint positions </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointVel</parametername>
</parameternamelist>
<parameterdescription>
<para>joint velocities </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>joint accelerations </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of link twists, expressed in the link frame for both orientation and origin </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">linkProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of link proper spatial acceleration, expressed in the link frame for both orientation and origin </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went well, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ExternalWrenchesEstimation.h" line="341" column="6" declfile="iDynTree/ExternalWrenchesEstimation.h" declline="341" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ExternalWrenchesEstimation_8h_1a9c5c034c8fc89c4d0d19f17d2134a7a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::dynamicsEstimationForwardVelKinematics</definition>
        <argsstring>(const Model &amp;model, const Traversal &amp;traversal, const Vector3 &amp;base_angularVel, const JointPosDoubleArray &amp;jointPos, const JointDOFsDoubleArray &amp;jointVel, LinkVelArray &amp;linkVel)</argsstring>
        <name>dynamicsEstimationForwardVelKinematics</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Traversal" kindref="compound">Traversal</ref> &amp;</type>
          <declname>traversal</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref> &amp;</type>
          <declname>base_angularVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointPosDoubleArray" kindref="compound">JointPosDoubleArray</ref> &amp;</type>
          <declname>jointPos</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1JointDOFsDoubleArray" kindref="compound">JointDOFsDoubleArray</ref> &amp;</type>
          <declname>jointVel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <briefdescription>
<para>Modified forward kinematics for floating basedynamics estimation. </para>
        </briefdescription>
        <detaileddescription>
<para>This is a version of velocity forward kinematics modified to fit the needs of free floating dynamics estimation.</para>
<para>There are several difference with respect to the classical forward kinematics. The first one is that the only inputs necessary related to the base link is the base link angular velocity. This is because the dynamics of an articulated system does not depend on an offset in linear velocity. This will mean that the link velocities computed by this algorithm are not the velocity of the links with respect to an inertial frame. Nevertherless they can still be used for estimation.</para>
<para>There are two main ways in which the base information is computed: one is exploiting the knoledge that a link is not moving with respect to an inertial frame: in this case the angular velocity is equal to zero. The other way is to exploit the measure of a gyroscope mounted on the base link of the traversal: the gyroscope will measure the link angular velocity.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the input model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">traversal</parametername>
</parameternamelist>
<parameterdescription>
<para>the traversal used to propagate the velocity and the proper acceleration </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">base_angularVel</parametername>
</parameternamelist>
<parameterdescription>
<para>angular velocity of the base link frame </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointPos</parametername>
</parameternamelist>
<parameterdescription>
<para>joint positions </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">jointVel</parametername>
</parameternamelist>
<parameterdescription>
<para>joint velocities </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of link twists, expressed in the link frame for both orientation and origin </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went well, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ExternalWrenchesEstimation.h" line="382" column="6" declfile="iDynTree/ExternalWrenchesEstimation.h" declline="382" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ExternalWrenchesEstimation_8h_1a2cf3011d218d8a98440bdcafdd1d54e6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::computeLinkNetWrenchesWithoutGravity</definition>
        <argsstring>(const Model &amp;model, const LinkVelArray &amp;linkVel, const LinkAccArray &amp;linkProperAcc, LinkNetTotalWrenchesWithoutGravity &amp;linkNetWrenchesWithoutGravity)</argsstring>
        <name>computeLinkNetWrenchesWithoutGravity</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkVelArray" kindref="compound">LinkVelArray</ref> &amp;</type>
          <declname>linkVel</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkAccArray" kindref="compound">LinkAccArray</ref> &amp;</type>
          <declname>linkProperAcc</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkNetTotalWrenchesWithoutGravity</ref> &amp;</type>
          <declname>linkNetWrenchesWithoutGravity</declname>
        </param>
        <briefdescription>
<para>Compute the net internal and external wrenches (excluding gravity forces) acting on the links. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>the input model </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkVel</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector of link twists, expressed w.r.t to the link orientation and the link origin </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkProperAcc</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector of link spatial (in the Featherstone sense) and proper accelerations, expressed w.r.t to the link orientation and the link origin </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">linkNetWrenchesWithoutGravity</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector of the sum of all the wrenches (both internal and external, excluding gravity) acting on link i, expressed (both orientation and point) with respect to the reference frame of link i </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ExternalWrenchesEstimation.h" line="396" column="6" declfile="iDynTree/ExternalWrenchesEstimation.h" declline="396" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="ExternalWrenchesEstimation_8h_1ab6c0784c22088705cc07732b5b29dd4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::estimateLinkContactWrenchesFromLinkNetExternalWrenches</definition>
        <argsstring>(const Model &amp;model, const LinkUnknownWrenchContacts &amp;unknownWrenches, const LinkNetExternalWrenches &amp;netExtWrenches, LinkContactWrenches &amp;outputContactWrenches)</argsstring>
        <name>estimateLinkContactWrenchesFromLinkNetExternalWrenches</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkUnknownWrenchContacts" kindref="compound">LinkUnknownWrenchContacts</ref> &amp;</type>
          <declname>unknownWrenches</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1LinkWrenches" kindref="compound">LinkNetExternalWrenches</ref> &amp;</type>
          <declname>netExtWrenches</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1LinkContactWrenches" kindref="compound">LinkContactWrenches</ref> &amp;</type>
          <declname>outputContactWrenches</declname>
        </param>
        <briefdescription>
<para>Compute the link contact wrenches from the net external wrenches. </para>
        </briefdescription>
        <detaileddescription>
<para>If there are more than 6 unknows for link, the problem becomes ill-defined and the function just assign all the external wrench to the first contact.  </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ExternalWrenchesEstimation.h" line="410" column="6" declfile="iDynTree/ExternalWrenchesEstimation.h" declline="410" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="InertialParametersSolidShapesHelpers_8h_1a4ed7d9dcd80664b1b86236a0f1086cda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::estimateInertialParametersFromLinkBoundingBoxesAndTotalMass</definition>
        <argsstring>(const double totalMass, iDynTree::Model &amp;model, VectorDynSize &amp;estimatedInertialParams)</argsstring>
        <name>estimateInertialParametersFromLinkBoundingBoxesAndTotalMass</name>
        <param>
          <type>const double</type>
          <declname>totalMass</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> &amp;</type>
          <declname>estimatedInertialParams</declname>
        </param>
        <briefdescription>
<para>Estimate the inertial parameters of a model using link bounding boxes and the total mass. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">totalMass</parametername>
</parameternamelist>
<parameterdescription>
<para>The total mass of the model, in Kilograms. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">model</parametername>
</parameternamelist>
<parameterdescription>
<para>The model, used to extract the bounding box of the links. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">inertialParameters</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of inertial parameters, in the format used by <ref refid="classiDynTree_1_1Model_1a2c283e000a2d6a5e86770d8616b7e18b" kindref="member">Model::getInertialParameters</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went well, false otherwise .</para>
</simplesect>
<simplesect kind="note"><para>if inertialParameters does not have the correct size, it will be resized. </para>
</simplesect>
<simplesect kind="warning"><para>This function needs to allocate some internal buffers, and so it performs dynamic memory allocation.</para>
</simplesect>
<simplesect kind="note"><para>This function requires IDYNTREE_USES_ASSIMP to be true, otherwise it always returns false. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/InertialParametersSolidShapesHelpers.h" line="26" column="6" declfile="iDynTree/InertialParametersSolidShapesHelpers.h" declline="26" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="InertialParametersSolidShapesHelpers_8h_1a3fc080109daad044981533bc143d1bee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::computeBoundingBoxFromShape</definition>
        <argsstring>(const SolidShape &amp;geom, Box &amp;box)</argsstring>
        <name>computeBoundingBoxFromShape</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SolidShape" kindref="compound">SolidShape</ref> &amp;</type>
          <declname>geom</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Box" kindref="compound">Box</ref> &amp;</type>
          <declname>box</declname>
        </param>
        <briefdescription>
<para>Compute bounding box from a solid shape object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">geom</parametername>
</parameternamelist>
<parameterdescription>
<para>The link collision as a iDynTree solid shape object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">box</parametername>
</parameternamelist>
<parameterdescription>
<para>The bounding box for the solid shape object </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went well, false otherwise .</para>
</simplesect>
<simplesect kind="note"><para>If the shape is an <ref refid="classiDynTree_1_1ExternalMesh" kindref="compound">ExternalMesh</ref> type, this function requires IDYNTREE_USES_ASSIMP to be true, otherwise it always returns false. </para>
</simplesect>
<simplesect kind="note"><para>If the shape is an <ref refid="classiDynTree_1_1ExternalMesh" kindref="compound">ExternalMesh</ref> type, an Axis-Aligned Bounding <ref refid="classiDynTree_1_1Box" kindref="compound">Box</ref> (AABB) is computed from the mesh vertices. This means that the returned bounding box is neither unique nor a minimum volume bounding box for the given mesh. The axes alignment to compute AABB is done with respect to the frame associated with the shape. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/InertialParametersSolidShapesHelpers.h" line="41" column="6" declfile="iDynTree/InertialParametersSolidShapesHelpers.h" declline="41" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="InertialParametersSolidShapesHelpers_8h_1a22b1c506654dc8a1589bbccc2ba32deb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> &gt;</type>
        <definition>std::vector&lt;Position&gt; iDynTree::computeBoxVertices</definition>
        <argsstring>(const Box box)</argsstring>
        <name>computeBoxVertices</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Box" kindref="compound">Box</ref></type>
          <declname>box</declname>
        </param>
        <briefdescription>
<para>Get the bounding box vertices in the link frame. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">box</parametername>
</parameternamelist>
<parameterdescription>
<para>The link collision solid shape as a <ref refid="classiDynTree_1_1Box" kindref="compound">Box</ref> object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>vector of vertex positions in the link frame. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/InertialParametersSolidShapesHelpers.h" line="49" column="13" declfile="iDynTree/InertialParametersSolidShapesHelpers.h" declline="49" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="ModelTransformersSolidShapes_8h_1adbe329aea649b6a379dfd7077ceb1eb9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::approximateSolidShapesWithPrimitiveShape</definition>
        <argsstring>(const Model &amp;inputModel, Model &amp;outputModel, ApproximateSolidShapesWithPrimitiveShapeOptions options=ApproximateSolidShapesWithPrimitiveShapeOptions())</argsstring>
        <name>approximateSolidShapesWithPrimitiveShape</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>inputModel</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref> &amp;</type>
          <declname>outputModel</declname>
        </param>
        <param>
          <type><ref refid="structiDynTree_1_1ApproximateSolidShapesWithPrimitiveShapeOptions" kindref="compound">ApproximateSolidShapesWithPrimitiveShapeOptions</ref></type>
          <declname>options</declname>
          <defval><ref refid="structiDynTree_1_1ApproximateSolidShapesWithPrimitiveShapeOptions" kindref="compound">ApproximateSolidShapesWithPrimitiveShapeOptions</ref>()</defval>
        </param>
        <briefdescription>
<para>\function Approximate solid shapes of the input model with some primitive shapes. </para>
        </briefdescription>
        <detaileddescription>
<para>This function takes in input a <ref refid="classiDynTree_1_1Model" kindref="compound">Model</ref>, and returns in output the same model, but with all solid shapes of the model (both collision and visual) substituted with a primitive shape that approximates in some way the original solid shape.</para>
<para><simplesect kind="note"><para>At the moment, the only conversion type provided is to approximate each solid shape of the model with its axis aligned bounding box, using the iDynTree::computeBoundingBoxFromShape function. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/ModelTransformersSolidShapes.h" line="53" column="6" declfile="iDynTree/ModelTransformersSolidShapes.h" declline="53" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModelIO_1ga80941e03b0209a745a76fadc3264879a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::dofsListFromURDF</definition>
        <argsstring>(const std::string &amp;urdf_filename, std::vector&lt; std::string &gt; &amp;dofs)</argsstring>
        <name>dofsListFromURDF</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>urdf_filename</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>dofs</declname>
        </param>
        <briefdescription>
<para>Load a list of dofs names from a URDF file. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true if all went ok, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/URDFDofsImport.h" line="22" column="6" declfile="iDynTree/URDFDofsImport.h" declline="22" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModelIO_1ga657c7f9a0eedd9b8f71a54e6a83acdc0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::dofsListFromURDFString</definition>
        <argsstring>(const std::string &amp;urdf_string, std::vector&lt; std::string &gt; &amp;dofs)</argsstring>
        <name>dofsListFromURDFString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>urdf_string</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>dofs</declname>
        </param>
        <briefdescription>
<para>Load a list of dofs object from a URDF string. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>true if all went ok, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/URDFDofsImport.h" line="32" column="6" declfile="iDynTree/URDFDofsImport.h" declline="32" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModelIO_1gaeaa7b0320760138dab8d2e7ba5525b2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::URDFFromModel</definition>
        <argsstring>(const iDynTree::Model &amp;model, const std::string &amp;urdf_filename, const ModelExporterOptions options=ModelExporterOptions())</argsstring>
        <name>URDFFromModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>model</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>urdf_filename</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1ModelExporterOptions" kindref="compound">ModelExporterOptions</ref></type>
          <declname>options</declname>
          <defval><ref refid="structiDynTree_1_1ModelExporterOptions" kindref="compound">ModelExporterOptions</ref>()</defval>
        </param>
        <briefdescription>
<para>Export a <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> object to a URDF file. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="structiDynTree_1_1ModelExporterOptions" kindref="compound">iDynTree::ModelExporterOptions</ref> for more details on supported and default options.</para>
</simplesect>
<simplesect kind="warning"><para>This function does not support exporting sensor or solid shapes at the moment.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">urdf_filename</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to the URDF file that will be created. It can be either a relative filename with respect to the current working directory, or an absolute filename. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structiDynTree_1_1ModelExporterOptions" kindref="compound">iDynTree::ModelExporterOptions</ref> struct of options passed to the parser. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went ok, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFModelExport.h" line="32" column="6" declfile="private/URDFModelExport.h" declline="32" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeModelIO_1gab9223d51ca118bea013bbbde14d6e054" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::URDFStringFromModel</definition>
        <argsstring>(const iDynTree::Model &amp;output, std::string &amp;urdf_string, const ModelExporterOptions options=ModelExporterOptions())</argsstring>
        <name>URDFStringFromModel</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> &amp;</type>
          <declname>output</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>urdf_string</declname>
        </param>
        <param>
          <type>const <ref refid="structiDynTree_1_1ModelExporterOptions" kindref="compound">ModelExporterOptions</ref></type>
          <declname>options</declname>
          <defval><ref refid="structiDynTree_1_1ModelExporterOptions" kindref="compound">ModelExporterOptions</ref>()</defval>
        </param>
        <briefdescription>
<para>Export a <ref refid="classiDynTree_1_1Model" kindref="compound">iDynTree::Model</ref> object to a URDF string. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="structiDynTree_1_1ModelExporterOptions" kindref="compound">iDynTree::ModelExporterOptions</ref> for more details on supported and default options.</para>
</simplesect>
<simplesect kind="warning"><para>This function does not support exporting sensor or solid shapes at the moment.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">options</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="structiDynTree_1_1ModelExporterOptions" kindref="compound">iDynTree::ModelExporterOptions</ref> struct of options passed to the parser. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if all went ok, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFModelExport.h" line="48" column="6" declfile="private/URDFModelExport.h" declline="48" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1a91b6a382b3717636fb3a45a8ba4f8850" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::stringToDoubleWithClassicLocale</definition>
        <argsstring>(const std::string &amp;inStr, double &amp;outDouble)</argsstring>
        <name>stringToDoubleWithClassicLocale</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>inStr</declname>
        </param>
        <param>
          <type>double &amp;</type>
          <declname>outDouble</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="22" column="13" bodyfile="private/URDFParsingUtils.h" bodystart="22" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1a9c8ea4244ff5dc2276f8008b53a609e8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::stringToIntWithClassicLocale</definition>
        <argsstring>(const std::string &amp;inStr, int &amp;outInt)</argsstring>
        <name>stringToIntWithClassicLocale</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>inStr</declname>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>outInt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="30" column="13" bodyfile="private/URDFParsingUtils.h" bodystart="30" bodyend="36"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1ab5e3c195abc73e35657df0f831daab96" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::stringToUnsignedIntWithClassicLocale</definition>
        <argsstring>(const std::string &amp;inStr, unsigned int &amp;outInt)</argsstring>
        <name>stringToUnsignedIntWithClassicLocale</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>inStr</declname>
        </param>
        <param>
          <type>unsigned int &amp;</type>
          <declname>outInt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="38" column="13" bodyfile="private/URDFParsingUtils.h" bodystart="38" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1a072b6eff9a6c9173d96ebef185343d90" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::doubleToStringWithClassicLocale</definition>
        <argsstring>(const double &amp;inDouble, std::string &amp;outStr)</argsstring>
        <name>doubleToStringWithClassicLocale</name>
        <param>
          <type>const double &amp;</type>
          <declname>inDouble</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>outStr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="46" column="13" bodyfile="private/URDFParsingUtils.h" bodystart="46" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1adffeb935ed6aad8d6f30705238117df8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string iDynTree::intToString</definition>
        <argsstring>(const int inInt)</argsstring>
        <name>intToString</name>
        <param>
          <type>const int</type>
          <declname>inInt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="61" column="20" bodyfile="private/URDFParsingUtils.h" bodystart="61" bodyend="66"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1a49c5650f4d8f43d3af304224dcf880c0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string iDynTree::intToString</definition>
        <argsstring>(const size_t inInt)</argsstring>
        <name>intToString</name>
        <param>
          <type>const size_t</type>
          <declname>inInt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="68" column="20" bodyfile="private/URDFParsingUtils.h" bodystart="68" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1ab77f7c41e63dbfbfc327283490b7cb92" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::splitString</definition>
        <argsstring>(const std::string &amp;inStr, std::vector&lt; std::string &gt; &amp;pieces)</argsstring>
        <name>splitString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>inStr</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; &amp;</type>
          <declname>pieces</declname>
        </param>
        <briefdescription>
<para>Split string along spaces. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="79" column="13" bodyfile="private/URDFParsingUtils.h" bodystart="79" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1a8645d0238ce891d16d8d7be074bd33dc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::vector3FromString</definition>
        <argsstring>(const std::string &amp;vector_str, Vector3 &amp;out)</argsstring>
        <name>vector3FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>vector_str</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector3</ref> &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="102" column="13" bodyfile="private/URDFParsingUtils.h" bodystart="102" bodyend="136"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1a5872c10e6e9f23dbeeb87ad4b503a5ba" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename iDynTreeVectorType</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool iDynTree::vectorToString</definition>
        <argsstring>(const iDynTreeVectorType &amp;in, std::string &amp;out_str)</argsstring>
        <name>vectorToString</name>
        <param>
          <type>const iDynTreeVectorType &amp;</type>
          <declname>in</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>out_str</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="139" column="13" bodyfile="private/URDFParsingUtils.h" bodystart="139" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="URDFParsingUtils_8h_1ab55f4fdf60c8947b61adde47e0495b10" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::vector4FromString</definition>
        <argsstring>(const std::string &amp;vector_str, Vector4 &amp;out)</argsstring>
        <name>vector4FromString</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>vector_str</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector4</ref> &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="private/URDFParsingUtils.h" line="160" column="13" bodyfile="private/URDFParsingUtils.h" bodystart="160" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="YARPConfigurationsLoader_8h_1a51e39202a162fa642eed01df66c75878" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::parseRotationMatrix</definition>
        <argsstring>(const yarp::os::Searchable &amp;rf, const std::string &amp;key, iDynTree::Rotation &amp;rotation)</argsstring>
        <name>parseRotationMatrix</name>
        <param>
          <type>const yarp::os::Searchable &amp;</type>
          <declname>rf</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>key</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Rotation" kindref="compound">iDynTree::Rotation</ref> &amp;</type>
          <declname>rotation</declname>
        </param>
        <briefdescription>
<para>Takes a rotation matrix from configuration file. </para>
        </briefdescription>
        <detaileddescription>
<para>Notice, the matrix is parsed row-wise. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>rf</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::os::Searchable The input searchable </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key</parametername>
</parameternamelist>
<parameterdescription>
<para>The name corresponding to the matrix to be read </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rotation</parametername>
</parameternamelist>
<parameterdescription>
<para>The output rotation </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if successfull </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConfigurationsLoader.h" line="21" column="10" bodyfile="iDynTree/YARPConfigurationsLoaderImplementation.h" bodystart="9" bodyend="39" declfile="iDynTree/YARPConfigurationsLoader.h" declline="21" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1ga5043dfa20b4ffc99d8dbdae5b15c0dae" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toiDynTree</definition>
        <argsstring>(const yarp::sig::Vector &amp;yarpVector, iDynTree::Wrench &amp;iDynTreeWrench)</argsstring>
        <name>toiDynTree</name>
        <param>
          <type>const yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Wrench" kindref="compound">iDynTree::Wrench</ref> &amp;</type>
          <declname>iDynTreeWrench</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Vector to a <ref refid="classiDynTree_1_1Wrench" kindref="compound">iDynTree::Wrench</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iDynTreeWrench</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Wrench" kindref="compound">iDynTree::Wrench</ref> output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="19" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="19" bodyend="29" declfile="iDynTree/YARPConversions.h" declline="26" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1gaa28c5100610c33e81bafbdad8cd65f74" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toYarp</definition>
        <argsstring>(const iDynTree::Wrench &amp;iDynTreeWrench, yarp::sig::Vector &amp;yarpVector)</argsstring>
        <name>toYarp</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Wrench" kindref="compound">iDynTree::Wrench</ref> &amp;</type>
          <declname>iDynTreeWrench</declname>
        </param>
        <param>
          <type>yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <briefdescription>
<para>Convert a <ref refid="classiDynTree_1_1Wrench" kindref="compound">iDynTree::Wrench</ref> to a yarp::sig::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iDynTreeWrench</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Wrench" kindref="compound">iDynTree::Wrench</ref> input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="32" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="32" bodyend="42" declfile="iDynTree/YARPConversions.h" declline="35" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1gaf7ed1a24bb847b7742685eb9f59bb92b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toiDynTree</definition>
        <argsstring>(const yarp::sig::Vector &amp;yarpVector, iDynTree::Position &amp;iDynTreePosition)</argsstring>
        <name>toiDynTree</name>
        <param>
          <type>const yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref> &amp;</type>
          <declname>iDynTreePosition</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Vector to a <ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iDynTreePosition</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref> output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise (if the input yarpVector has size different from 3) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="44" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="44" bodyend="53" declfile="iDynTree/YARPConversions.h" declline="44" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1gafcb81129ef0d16f5f1eb1cc6e1df4252" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toiDynTree</definition>
        <argsstring>(const yarp::sig::Vector &amp;yarpVector, iDynTree::Vector3 &amp;iDynTreeVector3)</argsstring>
        <name>toiDynTree</name>
        <param>
          <type>const yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::Vector3</ref> &amp;</type>
          <declname>iDynTreeVector3</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Vector to a iDynTree::Vector3. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iDynTreePosition</parametername>
</parameternamelist>
<parameterdescription>
<para>iDynTree::Vector3 output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise (if the input yarpVector has size different from 3) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="55" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="55" bodyend="64" declfile="iDynTree/YARPConversions.h" declline="53" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1ga9020f2412b884fd0ef63e726c1342947" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toYarp</definition>
        <argsstring>(const iDynTree::Position &amp;iDynTreePosition, yarp::sig::Vector &amp;yarpVector)</argsstring>
        <name>toYarp</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref> &amp;</type>
          <declname>iDynTreePosition</declname>
        </param>
        <param>
          <type>yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <briefdescription>
<para>Convert a <ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref> to a yarp::sig::Vector of 3 elements. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iDynTreePosition</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref> input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was sucessful, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="66" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="66" bodyend="75" declfile="iDynTree/YARPConversions.h" declline="62" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1gaea2d5b8825259e8fa15c166cb843ee40" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toiDynTree</definition>
        <argsstring>(const yarp::sig::Vector &amp;yarpVector, iDynTree::Direction &amp;iDynTreeDirection)</argsstring>
        <name>toiDynTree</name>
        <param>
          <type>const yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Direction" kindref="compound">iDynTree::Direction</ref> &amp;</type>
          <declname>iDynTreeDirection</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Vector of 3 elements to a <ref refid="classiDynTree_1_1Direction" kindref="compound">iDynTree::Direction</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iDynTreeDirection</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Direction" kindref="compound">iDynTree::Direction</ref> output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise (if the input yarpVector has size different from 3)</para>
</simplesect>
<simplesect kind="note"><para>the direction vector will be normalized to have unit norm. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="77" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="77" bodyend="90" declfile="iDynTree/YARPConversions.h" declline="74" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1ga6b716f09fcb568a6b3eea04b44160f19" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toYarp</definition>
        <argsstring>(const iDynTree::Vector3 &amp;iDynTreeDirection, yarp::sig::Vector &amp;yarpVector)</argsstring>
        <name>toYarp</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::Vector3</ref> &amp;</type>
          <declname>iDynTreeDirection</declname>
        </param>
        <param>
          <type>yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <briefdescription>
<para>Convert a <ref refid="classiDynTree_1_1Direction" kindref="compound">iDynTree::Direction</ref> to a yarp::sig::Vector of 3 elements. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iDynTreeDirection</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref> input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was sucessful, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="92" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="92" bodyend="101" declfile="iDynTree/YARPConversions.h" declline="84" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1gaa01de51e3acfd87599aa688e4c3d32c0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toiDynTree</definition>
        <argsstring>(const yarp::sig::Matrix &amp;yarpHomogeneousMatrix, iDynTree::Transform &amp;iDynTreeTransform)</argsstring>
        <name>toiDynTree</name>
        <param>
          <type>const yarp::sig::Matrix &amp;</type>
          <declname>yarpHomogeneousMatrix</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1Transform" kindref="compound">iDynTree::Transform</ref> &amp;</type>
          <declname>iDynTreeTransform</declname>
        </param>
        <briefdescription>
<para>Convert a 4x4 yarp::sig::Matrix representing an homegeneous matrix to a <ref refid="classiDynTree_1_1Transform" kindref="compound">iDynTree::Transform</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpHomogeneousMatrix</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Matrix 4x4 homegeneous matrix input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iDynTreeTransform</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Transform" kindref="compound">iDynTree::Transform</ref> output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="110" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="110" bodyend="139" declfile="iDynTree/YARPConversions.h" declline="94" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1ga0c1a2189345fb926b98f2d82219d5dd1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toYarp</definition>
        <argsstring>(const iDynTree::Transform &amp;iDynTreeTransform, yarp::sig::Matrix &amp;yarpHomogeneousMatrix)</argsstring>
        <name>toYarp</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">iDynTree::Transform</ref> &amp;</type>
          <declname>iDynTreeTransform</declname>
        </param>
        <param>
          <type>yarp::sig::Matrix &amp;</type>
          <declname>yarpHomogeneousMatrix</declname>
        </param>
        <briefdescription>
<para>Convert a <ref refid="classiDynTree_1_1Transform" kindref="compound">iDynTree::Transform</ref> to a 4x4 yarp::sig::Matrix representing an homegeneous matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iDynTreeTransform</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1Transform" kindref="compound">iDynTree::Transform</ref> input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>yarpHomogeneousMatrix</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Matrix 4x4 homegeneous matrix output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="141" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="141" bodyend="149" declfile="iDynTree/YARPConversions.h" declline="104" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1ga8c4d32377000e6629f2855a6d5aebf72" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::toiDynTree</definition>
        <argsstring>(const yarp::sig::Vector &amp;yarpVector, iDynTree::VectorDynSize &amp;iDynTreeVector)</argsstring>
        <name>toiDynTree</name>
        <param>
          <type>const yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <param>
          <type><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">iDynTree::VectorDynSize</ref> &amp;</type>
          <declname>iDynTreeVector</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Vector to a <ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">iDynTree::VectorDynSize</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iDynTreeVector</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">iDynTree::VectorDynSize</ref> output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise </para>
</simplesect>
<simplesect kind="note"><para>the output <ref refid="classiDynTree_1_1VectorDynSize" kindref="compound">VectorDynSize</ref> will be resized if necessary. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversionsImplementation.h" line="103" column="13" bodyfile="iDynTree/YARPConversionsImplementation.h" bodystart="103" bodyend="108" declfile="iDynTree/YARPConversions.h" declline="115" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1ga3e0ac29c597c34c171d29fb18127ab3b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VectorType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::toYarp</definition>
        <argsstring>(const VectorType &amp;iDynTreeVector, yarp::sig::Vector &amp;yarpVector)</argsstring>
        <name>toYarp</name>
        <param>
          <type>const VectorType &amp;</type>
          <declname>iDynTreeVector</declname>
        </param>
        <param>
          <type>yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <briefdescription>
<para>Convert a <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::VectorFixSize</ref> to a yarp::sig::Vector. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iDynTreeVector</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::VectorFixSize</ref> input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>the output yarp::sig::Vector will be resized if necessary. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversions.h" line="126" column="6" bodyfile="iDynTree/YARPConversions.h" bodystart="126" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1ga63598edaacfc53e5728e944a0dab5ebb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MatrixType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void iDynTree::toYarp</definition>
        <argsstring>(const MatrixType &amp;iDynTreeMatrix, yarp::sig::Matrix &amp;yarpMatrix)</argsstring>
        <name>toYarp</name>
        <param>
          <type>const MatrixType &amp;</type>
          <declname>iDynTreeMatrix</declname>
        </param>
        <param>
          <type>yarp::sig::Matrix &amp;</type>
          <declname>yarpMatrix</declname>
        </param>
        <briefdescription>
<para>Convert a <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">iDynTree::MatrixFixSize</ref> to a yarp::sig::Matrix. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iDynTreeMatrix</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">iDynTree::MatrixFixSize</ref> input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>yarpMatrix</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Matrix output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>the output yarp::sig::Matrix will be resized if necessary. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversions.h" line="146" column="6" bodyfile="iDynTree/YARPConversions.h" bodystart="146" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1ga056a45c2887a5f314c963c89bb16a270" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename VectorType</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool iDynTree::toiDynTree</definition>
        <argsstring>(const yarp::sig::Vector &amp;yarpVector, VectorType &amp;iDynTreeVector)</argsstring>
        <name>toiDynTree</name>
        <param>
          <type>const yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <param>
          <type>VectorType &amp;</type>
          <declname>iDynTreeVector</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Vector to a <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::VectorFixSize</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iDynTreeVector</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">iDynTree::VectorFixSize</ref> output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise (if the input yarpMatrix has size different from the output <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">VectorFixSize</ref>) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversions.h" line="172" column="6" bodyfile="iDynTree/YARPConversions.h" bodystart="172" bodyend="182"/>
      </memberdef>
      <memberdef kind="function" id="group__iDynTreeYARP_1gae1c1d7e3baf33d9b84f593330a3cf199" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename MatrixType</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool iDynTree::toiDynTree</definition>
        <argsstring>(const yarp::sig::Matrix &amp;yarpMatrix, MatrixType &amp;iDynTreeMatrix)</argsstring>
        <name>toiDynTree</name>
        <param>
          <type>const yarp::sig::Matrix &amp;</type>
          <declname>yarpMatrix</declname>
        </param>
        <param>
          <type>MatrixType &amp;</type>
          <declname>iDynTreeMatrix</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Matrix to a <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">iDynTree::MatrixFixSize</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpMatrix</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Matrix input </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>iDynTreeMatrix</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">iDynTree::MatrixFixSize</ref> output </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if conversion was successful, false otherwise (if the input yarpMatrix has size different from the <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">MatrixFixSize</ref>) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPConversions.h" line="194" column="6" bodyfile="iDynTree/YARPConversions.h" bodystart="194" bodyend="210"/>
      </memberdef>
      <memberdef kind="function" id="YARPEigenConversions_8h_1ae7c28c545c2775b437536fd84dabc97d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; Eigen::VectorXd &gt;</type>
        <definition>Eigen::Map&lt;Eigen::VectorXd&gt; iDynTree::toEigen</definition>
        <argsstring>(yarp::sig::Vector &amp;yarpVector)</argsstring>
        <name>toEigen</name>
        <param>
          <type>yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Vector to a Eigen::Map&lt;Eigen::VectorXd&gt; object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector input </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a Eigen::Map vector that points to the data contained in the yarp vector </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPEigenConversions.h" line="20" column="19" bodyfile="iDynTree/YARPEigenConversions.h" bodystart="20" bodyend="23"/>
      </memberdef>
      <memberdef kind="function" id="YARPEigenConversions_8h_1a19f060a1b963d4cdd58a142372675f6b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt; Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(yarp::sig::Matrix &amp;yarpMatrix)</argsstring>
        <name>toEigen</name>
        <param>
          <type>yarp::sig::Matrix &amp;</type>
          <declname>yarpMatrix</declname>
        </param>
        <briefdescription>
<para>Convert a yarp::sig::Matrix to a Eigen::Map&lt; Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt; &gt; object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Matrix input </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a Eigen::Map vector that points to the data contained in the yarp matrix </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPEigenConversions.h" line="30" column="19" bodyfile="iDynTree/YARPEigenConversions.h" bodystart="30" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="YARPEigenConversions_8h_1a0fc1ec0d7de0f823d4a8c32524aaecd7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; const Eigen::VectorXd &gt;</type>
        <definition>Eigen::Map&lt;const Eigen::VectorXd&gt; iDynTree::toEigen</definition>
        <argsstring>(const yarp::sig::Vector &amp;yarpVector)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const yarp::sig::Vector &amp;</type>
          <declname>yarpVector</declname>
        </param>
        <briefdescription>
<para>Convert a const yarp::sig::Vector to a Eigen::Map&lt;const Eigen::VectorXd&gt; object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Vector input </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a Eigen::Map vector that points to the data contained in the yarp vector </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPEigenConversions.h" line="40" column="19" bodyfile="iDynTree/YARPEigenConversions.h" bodystart="40" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="YARPEigenConversions_8h_1a4f400cf54f7b7757adbaa768205b9df9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>Eigen::Map&lt; const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &gt;</type>
        <definition>Eigen::Map&lt;const Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt; &gt; iDynTree::toEigen</definition>
        <argsstring>(const yarp::sig::Matrix &amp;yarpMatrix)</argsstring>
        <name>toEigen</name>
        <param>
          <type>const yarp::sig::Matrix &amp;</type>
          <declname>yarpMatrix</declname>
        </param>
        <briefdescription>
<para>Convert a const yarp::sig::Matrix to a Eigen::Map&lt; const Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt; &gt; object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>yarpVector</parametername>
</parameternamelist>
<parameterdescription>
<para>yarp::sig::Matrix input </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a Eigen::Map vector that points to the data contained in the yarp matrix </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/YARPEigenConversions.h" line="50" column="19" bodyfile="iDynTree/YARPEigenConversions.h" bodystart="50" bodyend="53"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="iDynTree/AccelerometerSensor.h" line="10" column="1"/>
  </compounddef>
</doxygen>
