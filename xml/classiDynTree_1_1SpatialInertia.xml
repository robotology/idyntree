<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classiDynTree_1_1SpatialInertia" kind="class" language="C++" prot="public">
    <compoundname>iDynTree::SpatialInertia</compoundname>
    <includes local="no">iDynTree/SpatialInertia.h</includes>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classiDynTree_1_1SpatialInertia_1a391e52e261b0cd42e34e1868eeda92f4" prot="protected" static="no" mutable="no">
        <type>double</type>
        <definition>double iDynTree::SpatialInertia::m_mass</definition>
        <argsstring></argsstring>
        <name>m_mass</name>
        <briefdescription>
<para>Mass. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="25" column="16" bodyfile="iDynTree/SpatialInertia.h" bodystart="25" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classiDynTree_1_1SpatialInertia_1acbf8e9831ad5f2b1454418109990d6e4" prot="protected" static="no" mutable="no">
        <type>double</type>
        <definition>double iDynTree::SpatialInertia::m_mcom[3]</definition>
        <argsstring>[3]</argsstring>
        <name>m_mcom</name>
        <briefdescription>
<para>First moment of mass (i.e. mass * center of mass). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="26" column="16" bodyfile="iDynTree/SpatialInertia.h" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classiDynTree_1_1SpatialInertia_1aa2c5b1a589d41a1a5d2975b7c4414350" prot="protected" static="no" mutable="no">
        <type><ref refid="classiDynTree_1_1RotationalInertia" kindref="compound">RotationalInertia</ref></type>
        <definition>RotationalInertia iDynTree::SpatialInertia::m_rotInertia</definition>
        <argsstring></argsstring>
        <name>m_rotInertia</name>
        <briefdescription>
<para>Three dimensional rotational inertia. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="27" column="27" bodyfile="iDynTree/SpatialInertia.h" bodystart="27" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1ab599c235ffbb9936d16a56c53f390d06" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>iDynTree::SpatialInertia::SpatialInertia</definition>
        <argsstring>()</argsstring>
        <name>SpatialInertia</name>
        <briefdescription>
<para>Default constructor. </para>
        </briefdescription>
        <detaileddescription>
<para>The data is not reset to zero for perfomance reason. Please initialize the data in the vector before any use. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="34" column="16" bodyfile="iDynTree/SpatialInertia.h" bodystart="34" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a907cad4be71448b45dac2a76aa55e3b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::SpatialInertia::SpatialInertia</definition>
        <argsstring>(const double mass, const Position &amp;com, const RotationalInertia &amp;rotInertia)</argsstring>
        <name>SpatialInertia</name>
        <param>
          <type>const double</type>
          <declname>mass</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> &amp;</type>
          <declname>com</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1RotationalInertia" kindref="compound">RotationalInertia</ref> &amp;</type>
          <declname>rotInertia</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="35" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a64175e97f51f1595870b8aff78f64839" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::SpatialInertia::SpatialInertia</definition>
        <argsstring>(const SpatialInertia &amp;other)</argsstring>
        <name>SpatialInertia</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="38" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a25c6ee7a1f07eabfa32fc26b7cca46e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::SpatialInertia::fromRotationalInertiaWrtCenterOfMass</definition>
        <argsstring>(const double mass, const Position &amp;com, const RotationalInertia &amp;rotInertia)</argsstring>
        <name>fromRotationalInertiaWrtCenterOfMass</name>
        <param>
          <type>const double</type>
          <declname>mass</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> &amp;</type>
          <declname>com</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1RotationalInertia" kindref="compound">RotationalInertia</ref> &amp;</type>
          <declname>rotInertia</declname>
        </param>
        <briefdescription>
<para>Helper constructor-like function that takes mass, center of mass and the rotational inertia expressed in the center of mass. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="49" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1ab52a9bf87a0a91234995cc5b5f6e4b37" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>double iDynTree::SpatialInertia::getMass</definition>
        <argsstring>() const</argsstring>
        <name>getMass</name>
        <briefdescription>
<para>multiplication operator </para>
        </briefdescription>
        <detaileddescription>
<para>overloading happens on proper classes Getter functions</para>
<para><simplesect kind="note"><para>for preserving consistency, no setters are implemented.. if you want to modify a spatial inertia create a new one, and assign it to the spatial inertia that you want modify. Given that no memory allocation happens it should be still efficient. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="68" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a76eeb9d55d89cd0f249dbfe2638f1207" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref></type>
        <definition>Position iDynTree::SpatialInertia::getCenterOfMass</definition>
        <argsstring>() const</argsstring>
        <name>getCenterOfMass</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="69" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a7e3c5484c7f7038f955aac544576000f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classiDynTree_1_1RotationalInertia" kindref="compound">RotationalInertia</ref> &amp;</type>
        <definition>const RotationalInertia&amp; iDynTree::SpatialInertia::getRotationalInertiaWrtFrameOrigin</definition>
        <argsstring>() const</argsstring>
        <name>getRotationalInertiaWrtFrameOrigin</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="70" column="33"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a3c6f18da61651876659fcfa173639428" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1RotationalInertia" kindref="compound">RotationalInertia</ref></type>
        <definition>RotationalInertia iDynTree::SpatialInertia::getRotationalInertiaWrtCenterOfMass</definition>
        <argsstring>() const</argsstring>
        <name>getRotationalInertiaWrtCenterOfMass</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="71" column="27"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a7dc8fd64e0a069923ee589a77689e2a7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref></type>
        <definition>SpatialForceVector iDynTree::SpatialInertia::multiply</definition>
        <argsstring>(const SpatialMotionVector &amp;op) const</argsstring>
        <name>multiply</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>Multiplication function. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="77" column="28"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a2ad61dd654c4a4916e05c7a9dbc81632" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::SpatialInertia::zero</definition>
        <argsstring>()</argsstring>
        <name>zero</name>
        <briefdescription>
<para>reset to zero (i.e. </para>
        </briefdescription>
        <detaileddescription>
<para>the inertia of body with zero mass) the <ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="80" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a7ac807ec779d50c39b04d37578f57e21" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x6</ref></type>
        <definition>Matrix6x6 iDynTree::SpatialInertia::asMatrix</definition>
        <argsstring>() const</argsstring>
        <name>asMatrix</name>
        <briefdescription>
<para>Get the <ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref> as a 6x6 matrix. </para>
        </briefdescription>
        <detaileddescription>
<para>If <formula id="38">$ m \in \mathbb{R} $</formula> is the mass, <formula id="39">$ c \in \mathbb{R}^3 $</formula> is the center of mass, <formula id="40">$ I \in \mathbb{R}^{3 \times 3} $</formula> is the 3d inertia, and <formula id="41">$ 1_3 \in \mathbb{R}^{3 \times 3} $</formula> is the 3d identity matrix this method returns the <formula id="42">$ \mathbb{M} \in \mathbb{R}^{6 \times 6} $</formula> matrix such that: <formula id="43">\[ \mathbb{M} = \begin{bmatrix} m 1_3 &amp; -m c \times \\ m c \times &amp; I \end{bmatrix} \]</formula>.</para>
<para><simplesect kind="note"><para>As all quantities in iDynTree, this inertia assumes the linear-angular serialization. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="100" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1ac8f2cb43371716b2aeb3a893e4e14462" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Twist" kindref="compound">Twist</ref></type>
        <definition>Twist iDynTree::SpatialInertia::applyInverse</definition>
        <argsstring>(const SpatialMomentum &amp;mom) const</argsstring>
        <name>applyInverse</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMomentum" kindref="compound">SpatialMomentum</ref> &amp;</type>
          <declname>mom</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="102" column="15"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a7a7aee5d660fcc79d46351cc250a58cf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x6</ref></type>
        <definition>Matrix6x6 iDynTree::SpatialInertia::getInverse</definition>
        <argsstring>() const</argsstring>
        <name>getInverse</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="103" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1ae27826af45cbe71fe032df901a8581ff" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref></type>
        <definition>SpatialInertia iDynTree::SpatialInertia::operator+</definition>
        <argsstring>(const SpatialInertia &amp;other) const</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="106" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a87e87a50bd6d6ce97333be081e5593fd" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref></type>
        <definition>SpatialForceVector iDynTree::SpatialInertia::operator*</definition>
        <argsstring>(const SpatialMotionVector &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="107" column="28"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a8f34cacbbf37b2ed9eb9c27501b39a9c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialMomentum" kindref="compound">SpatialMomentum</ref></type>
        <definition>SpatialMomentum iDynTree::SpatialInertia::operator*</definition>
        <argsstring>(const Twist &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Twist" kindref="compound">Twist</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="108" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1acae1bf059807dd9af5717034b746b699" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Wrench" kindref="compound">Wrench</ref></type>
        <definition>Wrench iDynTree::SpatialInertia::operator*</definition>
        <argsstring>(const SpatialAcc &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialAcc" kindref="compound">SpatialAcc</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="109" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a100bc8dc58245924b2f3c3a7fbf243bc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Wrench" kindref="compound">Wrench</ref></type>
        <definition>Wrench iDynTree::SpatialInertia::biasWrench</definition>
        <argsstring>(const Twist &amp;V) const</argsstring>
        <name>biasWrench</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Twist" kindref="compound">Twist</ref> &amp;</type>
          <declname>V</declname>
        </param>
        <briefdescription>
<para>Return the bias wrench v.cross(M*v). </para>
        </briefdescription>
        <detaileddescription>
<para>Defining <formula id="44">$ \mathbb{M} $</formula> as this inertia, return the bias wrench v.cross(M*v), defined in math as: <formula id="45">\[ \mathrm{v} \bar\times^* \mathbb{M} \mathrm{v} = \\ \begin{bmatrix} \omega \times &amp; 0 \\ v \times &amp; \omega \times \end{bmatrix} \begin{bmatrix} m 1_3 &amp; -mc\times \\ mc\times &amp; I \end{bmatrix} \begin{bmatrix} v \\ \omega \end{bmatrix} = \\ \begin{bmatrix} m \omega \times v - \omega \times ( m c \times \omega) \\ m c \times ( \omega \times v ) + \omega \times I \omega \end{bmatrix} \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="133" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1ad623214d451123c7e435a53e13572076" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x6</ref></type>
        <definition>Matrix6x6 iDynTree::SpatialInertia::biasWrenchDerivative</definition>
        <argsstring>(const Twist &amp;V) const</argsstring>
        <name>biasWrenchDerivative</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Twist" kindref="compound">Twist</ref> &amp;</type>
          <declname>V</declname>
        </param>
        <briefdescription>
<para>Return the derivative of the bias wrench with respect to the link 6D velocity. </para>
        </briefdescription>
        <detaileddescription>
<para>Defining <formula id="42">$ \mathbb{M} \in \mathbb{R}^{6 \times 6} $</formula> as this inertia, return the derivative with respect to <formula id="46">$ \mathrm{v} = \begin{bmatrix} v \\ \omega \end{bmatrix} \in \mathbb{R}^6 $</formula> of the bias wrench <formula id="47">$ \mathrm{v} \bar\times^* \mathbb{M} \mathrm{v} $</formula> (i.e. v.cross(M*v)).</para>
<para>The bias wrench is: <formula id="48">\[ \mathrm{v} \bar\times^* \mathbb{M} \mathrm{v} = \\ \begin{bmatrix} m \omega \times v - \omega \times ( m c \times \omega) \\ m c \times ( \omega \times v ) + \omega \times I \omega \end{bmatrix} \]</formula></para>
<para>So the derivative with respect to the twist V is : <formula id="49">\[ \partial_\mathrm{v} ( \mathrm{v} \bar\times^* \mathbb{M} \mathrm{v} ) = \\ \begin{bmatrix} m \omega \times &amp; - m v \times + ( m c \times \omega) \times - (\omega \times) (mc \times) \\ (m c \times) ( \omega \times) &amp; - (m c \times )(v \times) + \omega \times I - (I \omega) \times \end{bmatrix} \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="160" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1ac1bfbb66868419b1fd9fd635c8b779a1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector10</ref></type>
        <definition>Vector10 iDynTree::SpatialInertia::asVector</definition>
        <argsstring>() const</argsstring>
        <name>asVector</name>
        <briefdescription>
<para>Get the Rigid Body Inertia as a vector of 10 inertial parameters. </para>
        </briefdescription>
        <detaileddescription>
<para>Return the rigid body inertia inertial parameters, defined as:</para>
<para><table rows="4" cols="3"><row>
<entry thead="yes" align='center'><para>Elements   </para>
</entry><entry thead="yes" align='center'><para>Symbol   </para>
</entry><entry thead="yes" align='center'><para>Description    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>0   </para>
</entry><entry thead="no" align='center'><para><formula id="50">$ m $</formula>   </para>
</entry><entry thead="no" align='center'><para>The mass of the rigid body    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>1-3   </para>
</entry><entry thead="no" align='center'><para><formula id="51">$ m c $</formula>   </para>
</entry><entry thead="no" align='center'><para>The first moment of mass of the rigid body    </para>
</entry></row>
<row>
<entry thead="no" align='center'><para>4-9   </para>
</entry><entry thead="no" align='center'><para><formula id="52">$ \mathop{vech}(I) $</formula>   </para>
</entry><entry thead="no" align='center'><para>The 6 independent elements of the 3d inertia matrix, i.e. <formula id="53">$ \begin{bmatrix} I_{xx} \\ I_{xy} \\ I_{xz} \\ I_{yy} \\ I_{yz} \\ I_{zz} \end{bmatrix} $</formula> .   </para>
</entry></row>
</table>
</para>
<para>The first moment of mass is the center of mass ( <formula id="39">$ c \in \mathbb{R}^3 $</formula> ) w.r.t. to the frame where this rigid body inertia is expressed multiplied by the rigid body mass <formula id="50">$ m $</formula>.</para>
<para>The 3d rigid body inertia <formula id="40">$ I \in \mathbb{R}^{3 \times 3} $</formula> is expressed with the orientation of the frame in which this rigid body inertia is expressed, and with respect to the frame origin. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="183" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a3e9180c32b6979c2baac6b5fe836d322" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::SpatialInertia::fromVector</definition>
        <argsstring>(const Vector10 &amp;inertialParams)</argsstring>
        <name>fromVector</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1VectorFixSize" kindref="compound">Vector10</ref> &amp;</type>
          <declname>inertialParams</declname>
        </param>
        <briefdescription>
<para>Set the Rigid Body Inertia from the inertial parameters in the vector. </para>
        </briefdescription>
        <detaileddescription>
<para>The serialization assumed in the inertialParams is the same used in the asVector method. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="190" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a6b493d81ed9bcedb37f81d0125d1ab04" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool iDynTree::SpatialInertia::isPhysicallyConsistent</definition>
        <argsstring>() const</argsstring>
        <name>isPhysicallyConsistent</name>
        <briefdescription>
<para>Check if the Rigid Body Inertia is physically consistent. </para>
        </briefdescription>
        <detaileddescription>
<para>This method will check:<itemizedlist>
<listitem><para>if the mass is positive,</para>
</listitem><listitem><para>if the 3d inertia at the COM is positive semidefinite, (semidefinite to cover also the case of the inertia of a point mass),</para>
</listitem><listitem><para>if the moment of inertia along the principal axes at the COM respect the triangle inequality.</para>
</listitem></itemizedlist>
</para>
<para>It will return true if all this check will pass, or false otherwise. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="204" column="14"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a1149f9fcf0a85c53765676c9bd3d3d38" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref></type>
        <definition>static SpatialInertia iDynTree::SpatialInertia::combine</definition>
        <argsstring>(const SpatialInertia &amp;op1, const SpatialInertia &amp;op2)</argsstring>
        <name>combine</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref> &amp;</type>
          <declname>op1</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref> &amp;</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="41" column="31"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1aac5e562a500942361c6d6e659719b07b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref></type>
        <definition>static SpatialInertia iDynTree::SpatialInertia::Zero</definition>
        <argsstring>()</argsstring>
        <name>Zero</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="162" column="31"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a183b97d44d255553c648236202c208a6" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x10</ref></type>
        <definition>static Matrix6x10 iDynTree::SpatialInertia::momentumRegressor</definition>
        <argsstring>(const iDynTree::Twist &amp;v)</argsstring>
        <name>momentumRegressor</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Twist" kindref="compound">iDynTree::Twist</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Get the momentum inertial parameters regressor. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the matrix <formula id="54">\[ Y(\mathrm{v}) \in \mathbb{R}^{6 \times 10} \]</formula> such that: <formula id="55">\[ \mathbb{M} \mathrm{v} = Y(\mathrm{v}) \alpha \]</formula></para>
<para>If <formula id="56">$ \alpha \in \mathbb{R}^{10} $</formula> is the inertial parameters representation of <formula id="44">$ \mathbb{M} $</formula>, as returned by the asVector method. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="221" column="27"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a5b8bf854a9e99daa3d7abdacaa73c0fd" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x10</ref></type>
        <definition>static Matrix6x10 iDynTree::SpatialInertia::momentumDerivativeRegressor</definition>
        <argsstring>(const iDynTree::Twist &amp;v, const iDynTree::SpatialAcc &amp;a)</argsstring>
        <name>momentumDerivativeRegressor</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Twist" kindref="compound">iDynTree::Twist</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialAcc" kindref="compound">iDynTree::SpatialAcc</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
<para>Get the momentum derivative inertial parameters regressor. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the matrix <formula id="57">\[ Y(\mathrm{v},a) \in \mathbb{R}^{6 \times 10} \]</formula> such that: <formula id="58">\[ \mathbb{M} a + \mathrm{v} \overline{\times}^{*} \mathbb{M} \mathrm{v} = Y(\mathrm{v}, a)\alpha \]</formula></para>
<para>If <formula id="56">$ \alpha \in \mathbb{R}^{10} $</formula> is the inertial parameters representation of <formula id="44">$ \mathbb{M} $</formula>, as returned by the asVector method.</para>
<para>This is also the regressor of the net wrench acting on a rigid body. As such, it is the building block of all other algorithms to compute dynamics regressors. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="242" column="27"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1SpatialInertia_1a33efaebc74adccc53058177922a50370" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x10</ref></type>
        <definition>static Matrix6x10 iDynTree::SpatialInertia::momentumDerivativeSlotineLiRegressor</definition>
        <argsstring>(const iDynTree::Twist &amp;v, const iDynTree::Twist &amp;vRef, const iDynTree::SpatialAcc &amp;aRef)</argsstring>
        <name>momentumDerivativeSlotineLiRegressor</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Twist" kindref="compound">iDynTree::Twist</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Twist" kindref="compound">iDynTree::Twist</ref> &amp;</type>
          <declname>vRef</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialAcc" kindref="compound">iDynTree::SpatialAcc</ref> &amp;</type>
          <declname>aRef</declname>
        </param>
        <briefdescription>
<para>Get the momentum derivative inertial parameters regressor. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the matrix <formula id="59">\[ Y(\mathrm{v},\mathrm{v}_r,a_r) \in \mathbb{R}^{6\times10} \]</formula> such that: <formula id="60">\[ \mathbb{M} a_r + (\mathrm{v} \overline{\times}^{*} \mathbb{M} - \mathbb{M} \mathrm{v} \times) \mathrm{v}_r = Y(\mathrm{v},\mathrm{v}_r,a_r)\alpha \]</formula></para>
<para>If <formula id="56">$ \alpha \in \mathbb{R}^{10} $</formula> is the inertial parameters representation of <formula id="44">$ \mathbb{M} $</formula>, as returned by the asVector method.</para>
<para>Notice that if <formula id="61">$ \mathrm{v} = \mathrm{v}_r $</formula>, this regressor reduces to the one computed by momentumDerivativeRegressor. The main difference is that (assuming constant <formula id="44">$ \mathbb{M} $</formula>) this regressor respect the passivity condition and thus is the basic building block for building Slotine Li style regressors.</para>
<para>For more on this, please check:</para>
<para>Garofalo, G.; Ott, C.; Albu-Schaffer, A., &quot;On the closed form computation of the dynamic matrices and their differentiations,&quot; in Intelligent Robots and Systems (IROS), 2013 IEEE/RSJ International Conference on doi: 10.1109/IROS.2013.6696688 URL: <ulink url="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6696688&amp;isnumber=6696319">http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6696688&amp;isnumber=6696319</ulink> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/SpatialInertia.h" line="273" column="27"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Class representing a six dimensional inertia. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <collaborationgraph>
      <node id="1">
        <label>iDynTree::SpatialInertia</label>
        <link refid="classiDynTree_1_1SpatialInertia"/>
        <childnode refid="2" relation="usage">
          <edgelabel>m_rotInertia</edgelabel>
        </childnode>
      </node>
      <node id="2">
        <label>iDynTree::RotationalInertia</label>
        <link refid="classiDynTree_1_1RotationalInertia"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>Matrix3x3</label>
        <link refid="classiDynTree_1_1MatrixFixSize"/>
        <childnode refid="4" relation="template-instance">
          <edgelabel>&lt; 3, 3 &gt;</edgelabel>
        </childnode>
      </node>
      <node id="4">
        <label>iDynTree::MatrixFixSize&lt; nRows, nCols &gt;</label>
        <link refid="classiDynTree_1_1MatrixFixSize"/>
      </node>
    </collaborationgraph>
    <location file="iDynTree/SpatialInertia.h" line="22" column="5" bodyfile="iDynTree/SpatialInertia.h" bodystart="23" bodyend="276"/>
    <listofallmembers>
      <member refid="classiDynTree_1_1SpatialInertia_1ac8f2cb43371716b2aeb3a893e4e14462" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>applyInverse</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a7ac807ec779d50c39b04d37578f57e21" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>asMatrix</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1ac1bfbb66868419b1fd9fd635c8b779a1" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>asVector</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a100bc8dc58245924b2f3c3a7fbf243bc" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>biasWrench</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1ad623214d451123c7e435a53e13572076" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>biasWrenchDerivative</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a1149f9fcf0a85c53765676c9bd3d3d38" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>combine</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a25c6ee7a1f07eabfa32fc26b7cca46e0" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>fromRotationalInertiaWrtCenterOfMass</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a3e9180c32b6979c2baac6b5fe836d322" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>fromVector</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a76eeb9d55d89cd0f249dbfe2638f1207" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>getCenterOfMass</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a7a7aee5d660fcc79d46351cc250a58cf" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>getInverse</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1ab52a9bf87a0a91234995cc5b5f6e4b37" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>getMass</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a3c6f18da61651876659fcfa173639428" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>getRotationalInertiaWrtCenterOfMass</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a7e3c5484c7f7038f955aac544576000f" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>getRotationalInertiaWrtFrameOrigin</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a6b493d81ed9bcedb37f81d0125d1ab04" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>isPhysicallyConsistent</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a391e52e261b0cd42e34e1868eeda92f4" prot="protected" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>m_mass</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1acbf8e9831ad5f2b1454418109990d6e4" prot="protected" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>m_mcom</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1aa2c5b1a589d41a1a5d2975b7c4414350" prot="protected" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>m_rotInertia</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a5b8bf854a9e99daa3d7abdacaa73c0fd" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>momentumDerivativeRegressor</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a33efaebc74adccc53058177922a50370" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>momentumDerivativeSlotineLiRegressor</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a183b97d44d255553c648236202c208a6" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>momentumRegressor</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a7dc8fd64e0a069923ee589a77689e2a7" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>multiply</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a87e87a50bd6d6ce97333be081e5593fd" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a8f34cacbbf37b2ed9eb9c27501b39a9c" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1acae1bf059807dd9af5717034b746b699" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1ae27826af45cbe71fe032df901a8581ff" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>operator+</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1ab599c235ffbb9936d16a56c53f390d06" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>SpatialInertia</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a907cad4be71448b45dac2a76aa55e3b0" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>SpatialInertia</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a64175e97f51f1595870b8aff78f64839" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>SpatialInertia</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1a2ad61dd654c4a4916e05c7a9dbc81632" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>zero</name></member>
      <member refid="classiDynTree_1_1SpatialInertia_1aac5e562a500942361c6d6e659719b07b" prot="public" virt="non-virtual"><scope>iDynTree::SpatialInertia</scope><name>Zero</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
