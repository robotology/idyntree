<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classiDynTree_1_1Transform" kind="class" language="C++" prot="public">
    <compoundname>iDynTree::Transform</compoundname>
    <includes local="no">iDynTree/Core/Transform.h</includes>
      <sectiondef kind="user-defined">
      <header>Overloaded operators.</header>
      <description><para>This operators are used to change the frame in which a quantity is expressed from the <formula id="258">$\texttt{frame}$</formula> to the <formula id="259">$\texttt{refFrame}$</formula> of the transform. </para>
</description>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a83a88c7dbba949bfced19dac0a133f4e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref></type>
        <definition>Transform iDynTree::Transform::operator*</definition>
        <argsstring>(const Transform &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Combine two transforms. </para>
        </briefdescription>
        <detaileddescription>
<para>If this object is <formula id="260">\[ (p,R) = ( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} , {}^{\texttt{refOrient}} R_{\texttt{orient}} ) \]</formula> and the argument is <formula id="261">\[ (p&apos;,R&apos;) = ( {}^{\texttt{orient}} p_{\texttt{point},\texttt{newPoint}} , {}^{\texttt{orient}} R_{\texttt{newOrient}} ) \]</formula>.</para>
<para>The resulting transform will be: <formula id="262">\[ (p+Rp&apos;, RR&apos;) = ( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{newPoint}} , {}^{\texttt{refOrient}} R_{\texttt{newOrient}} ) \]</formula>.</para>
<para>Notice that this is equivalent to multiply the associated homogemeous matrices: <formula id="263">\[ {}^{\texttt{refFrame}} H_{\texttt{newFrame}} = {}^{\texttt{refFrame}} H_{\texttt{frame}} {}^{\texttt{frame}} H_{\texttt{newFrame}} \]</formula> or the associated adjoint matrices : <formula id="264">\[ {}^{\texttt{refFrame}} X_{\texttt{newFrame}} = {}^{\texttt{refFrame}} X_{\texttt{frame}} {}^{\texttt{frame}} X_{\texttt{newFrame}} \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="208" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a8a58af1e6c5d582c5765d91e5cdc1675" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref></type>
        <definition>Transform iDynTree::Transform::inverse</definition>
        <argsstring>() const</argsstring>
        <name>inverse</name>
        <briefdescription>
<para>Return the inverse of this <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>If this object is <formula id="260">\[ (p,R) = ( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} , {}^{\texttt{refOrient}} R_{\texttt{orient}} ) \]</formula> this function will return: <formula id="265">\[ (-R^\top p , R^\top) = ( {}^{\texttt{orient}} p_{\texttt{point},\texttt{refPoint}} , {}^{\texttt{orient}} R_{\texttt{refOrient}} ) \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="223" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a47a4606065be27e235712f9805b3bdc9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref></type>
        <definition>Position iDynTree::Transform::operator*</definition>
        <argsstring>(const Position &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change reference frame of a point. </para>
        </briefdescription>
        <detaileddescription>
<para>If this object is <formula id="260">\[ (p,R) = ( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} , {}^{\texttt{refOrient}} R_{\texttt{orient}} ) \]</formula></para>
<para>And the <ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> argument represent a point: <formula id="266">\[ p&apos; = {}^{\texttt{orient}} p_{\texttt{point},\texttt{newPoint}} \]</formula></para>
<para>The result of the operation is: <formula id="267">\[ Rp&apos; + p = {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{newPoint}} \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="244" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1af120c9b238d9efdf947109b47c4e4fdf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Wrench" kindref="compound">Wrench</ref></type>
        <definition>Wrench iDynTree::Transform::operator*</definition>
        <argsstring>(const Wrench &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Wrench" kindref="compound">Wrench</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change frame in which a <ref refid="classiDynTree_1_1Wrench" kindref="compound">Wrench</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
<para>If this object is <formula id="260">\[ (p,R) = ( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} , {}^{\texttt{refOrient}} R_{\texttt{orient}} ) \]</formula></para>
<para>And the argument is a wrench: <formula id="268">\[ {}_{\texttt{frame}} F = \begin{bmatrix} f \\ \tau \end{bmatrix} \]</formula></para>
<para>The result of this operation is : <formula id="269">\[ {}_{\texttt{refFrame}} F = {}_{\texttt{refFrame}}X^{\texttt{frame}} {}_{\texttt{frame}} F = \begin{bmatrix} R &amp; 0_{3\times3} \\ p \times R &amp; R \end{bmatrix} \begin{bmatrix} f \\ \tau \end{bmatrix} = \begin{bmatrix} Rf \\ p \times R f + R\tau \end{bmatrix} \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="284" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a5ecf98714169de1a297c543305005a92" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Twist" kindref="compound">Twist</ref></type>
        <definition>Twist iDynTree::Transform::operator*</definition>
        <argsstring>(const Twist &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Twist" kindref="compound">Twist</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1Twist" kindref="compound">Twist</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
<para>If this object is <formula id="260">\[ (p,R) = ( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} , {}^{\texttt{refOrient}} R_{\texttt{orient}} ) \]</formula></para>
<para>And the argument is a twist: <formula id="270">\[ {}^{\texttt{frame}} V = \begin{bmatrix} v \\ \omega \end{bmatrix} \]</formula></para>
<para>The result of this operation is : <formula id="271">\[ {}^{\texttt{refFrame}} V = {}^{\texttt{refFrame}}X_{\texttt{frame}} {}^{\texttt{frame}} V = \begin{bmatrix} R &amp; p \times R\\ 0_{3\times3} &amp; R \end{bmatrix} \begin{bmatrix} v \\ \omega \end{bmatrix} = \begin{bmatrix} R v + p \times R \omega \\ R\omega \end{bmatrix} \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="324" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a9698f396afb2d422caae294fd6a8894c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialMomentum" kindref="compound">SpatialMomentum</ref></type>
        <definition>SpatialMomentum iDynTree::Transform::operator*</definition>
        <argsstring>(const SpatialMomentum &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMomentum" kindref="compound">SpatialMomentum</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1SpatialMomentum" kindref="compound">SpatialMomentum</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
<para>Check the operator*(const Wrench &amp; other) documentation for the mathematical details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="332" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1adb61420ce0cf15da881551147ced2000" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialAcc" kindref="compound">SpatialAcc</ref></type>
        <definition>SpatialAcc iDynTree::Transform::operator*</definition>
        <argsstring>(const SpatialAcc &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialAcc" kindref="compound">SpatialAcc</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1SpatialAcc" kindref="compound">SpatialAcc</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
<para>Check the operator*(const Twist &amp; other) documentation for the mathematical details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="340" column="22"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1ac77626420790ccdf7bc8672f0f8238d4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref></type>
        <definition>SpatialMotionVector iDynTree::Transform::operator*</definition>
        <argsstring>(const SpatialMotionVector &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
<para>Check the operator*(const Twist &amp; other) documentation for the mathematical details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="348" column="31"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1ad0351792d47583c938b5dab0d678bafc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref></type>
        <definition>SpatialForceVector iDynTree::Transform::operator*</definition>
        <argsstring>(const SpatialForceVector &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1SpatialForceVector" kindref="compound">SpatialForceVector</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
<para>Check the operator*(const Wrench &amp; other) documentation for the mathematical details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="356" column="30"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a1434f959c24d6047900578768e29909c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref></type>
        <definition>SpatialInertia iDynTree::Transform::operator*</definition>
        <argsstring>(const SpatialInertia &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1SpatialInertia" kindref="compound">SpatialInertia</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="362" column="24"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a909ab9d195c19ede41da8b503be868c0" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1ArticulatedBodyInertia" kindref="compound">ArticulatedBodyInertia</ref></type>
        <definition>ArticulatedBodyInertia iDynTree::Transform::operator*</definition>
        <argsstring>(const ArticulatedBodyInertia &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1ArticulatedBodyInertia" kindref="compound">ArticulatedBodyInertia</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1ArticulatedBodyInertia" kindref="compound">ArticulatedBodyInertia</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="368" column="32"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a4b630c9130ea310c7dc05034a145557f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Direction" kindref="compound">Direction</ref></type>
        <definition>Direction iDynTree::Transform::operator*</definition>
        <argsstring>(const Direction &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Direction" kindref="compound">Direction</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1Direction" kindref="compound">Direction</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
<para>If this object is <formula id="260">\[ (p,R) = ( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} , {}^{\texttt{refOrient}} R_{\texttt{orient}} ) \]</formula></para>
<para>And the argument is a direction represented by a unit norm 3d vector : <formula id="272">\[ {}^{\texttt{orient}} d \]</formula></para>
<para>The result of this operation is: <formula id="273">\[ {}^{\texttt{refOrient}} d = R {}^{\texttt{orient}} d \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="390" column="24"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1aa342f1751789eba01433f662d2b0c512" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Axis" kindref="compound">Axis</ref></type>
        <definition>Axis iDynTree::Transform::operator*</definition>
        <argsstring>(const Axis &amp;other) const</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Axis" kindref="compound">Axis</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Change the frame in which a <ref refid="classiDynTree_1_1Axis" kindref="compound">Axis</ref> is expressed. </para>
        </briefdescription>
        <detaileddescription>
<para>If this object is <formula id="260">\[ (p,R) = ( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} , {}^{\texttt{refOrient}} R_{\texttt{orient}} ) \]</formula></para>
<para>And the argument is an axis, specified by the axis origin and the axis direction: <formula id="274">\[ {}^{\texttt{frame}} A = ({}^{\texttt{orient}} p_{\texttt{point},\texttt{axisOrigin}} , {}^{\texttt{orient}} d) = (p&apos;,d) \]</formula></para>
<para>The result of this operation is: <formula id="275">\[ {}^{\texttt{refFrame}} A = ({}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{axisOrigin}} , {}^{\texttt{refOrient}} d) = ( Rp&apos; + p , Rd) \]</formula> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="411" column="24"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Raw data accessors.</header>
      <description><para>For several applications it may be useful to access the fransform contents in the raw form of homogeneous matrix or an adjoint matrix. </para>
</description>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a8db2358dc66b742a7dcc19e5e43f4e39" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix4x4</ref></type>
        <definition>Matrix4x4 iDynTree::Transform::asHomogeneousTransform</definition>
        <argsstring>() const</argsstring>
        <name>asHomogeneousTransform</name>
        <briefdescription>
<para>Return the 4x4 homogeneous matrix representing the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned matrix is the one with this structure:</para>
<para><formula id="277">\[ {}^{\texttt{refFrame}} H_{\texttt{frame}} = \begin{bmatrix} {}^{\texttt{refOrient}} R_{\texttt{orient}} &amp; {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} \\ 0_{1\times3} &amp; 1 \end{bmatrix} \]</formula> Where <formula id="257">${}^{\texttt{refOrient}} R_{\texttt{orient}} \in \mathbb{R}^{3 \times 3}$</formula> is the rotation matrix that takes a 3d vector expressed in the orientationFrame and transform it in a 3d vector expressed in the reference orientation frame.</para>
<para><formula id="278">${}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} \in \mathbb{R}^3$</formula> is the vector between the point and the reference point, pointing toward the point and expressed in the reference orientation frame. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="456" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1afadd977e513cdb2813b8763abe627121" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x6</ref></type>
        <definition>Matrix6x6 iDynTree::Transform::asAdjointTransform</definition>
        <argsstring>() const</argsstring>
        <name>asAdjointTransform</name>
        <briefdescription>
<para>Return the 6x6 adjoint matrix representing this transform. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned matrix is the one with this structure:</para>
<para><formula id="279">\[ {}^{\texttt{refFrame}} X_{\texttt{frame}} = \begin{bmatrix} R &amp; p \times R \\ 0_{3\times3} &amp; R \end{bmatrix} \]</formula></para>
<para>Where <formula id="280">$R = {}^{\texttt{refOrient}} R_{\texttt{orient}} \in \mathbb{R}^{3\times3}$</formula> is the rotation matrix that takes a 3d vector expressed in the orientationFrame and transform it in a 3d vector expressed in the reference orientation frame.</para>
<para><formula id="281">$p = p_{\texttt{refPoint},\texttt{point}} \in \mathbb{R}^3$</formula> is the vector between the point and the reference point, pointing toward the point and expressed in the reference orientation frame <formula id="282">$p \times$</formula> is the skew simmetric matrix such that <formula id="283">$(p \times) v = p \times v$</formula> .</para>
<para><simplesect kind="warning"><para>Note that in iDynTree the matrix are stored in row major order, and the 6d quantites are serialized in linear/angular order. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="489" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a860616069f3511b9a78b82b4a3de1f2d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix6x6</ref></type>
        <definition>Matrix6x6 iDynTree::Transform::asAdjointTransformWrench</definition>
        <argsstring>() const</argsstring>
        <name>asAdjointTransformWrench</name>
        <briefdescription>
<para>Return the 6x6 adjoint matrix (for wrench) representing this transform. </para>
        </briefdescription>
        <detaileddescription>
<para>The returned matrix is the one with this structure:</para>
<para><formula id="284">\[ {}_{\texttt{refFrame}} X^{\texttt{frame}} = \begin{bmatrix} R &amp; 0_{3\times3} \\ p \times R &amp; R \end{bmatrix} \]</formula></para>
<para>Where <formula id="280">$R = {}^{\texttt{refOrient}} R_{\texttt{orient}} \in \mathbb{R}^{3\times3}$</formula> is the rotation matrix that takes a 3d vector expressed in the orientationFrame and transform it in a 3d vector expressed in the reference orientation frame.</para>
<para><formula id="281">$p = p_{\texttt{refPoint},\texttt{point}} \in \mathbb{R}^3$</formula> is the vector between the point and the reference point, pointing toward the point and expressed in the reference orientation frame <formula id="282">$p \times$</formula> is the skew simmetric matrix such that <formula id="283">$(p \times) v = p \times v$</formula> .</para>
<para><simplesect kind="warning"><para>Note that in iDynTree the matrix are stored in row major order, and the 6d quantites are serialized in linear/angular order. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="522" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a0020412b9f32230742d028960fcdc811" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1SpatialMotionVector" kindref="compound">SpatialMotionVector</ref></type>
        <definition>SpatialMotionVector iDynTree::Transform::log</definition>
        <argsstring>() const</argsstring>
        <name>log</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="528" column="29"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Output helpers.</header>
      <description><para>Function to print out the <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref>. </para>
</description>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1ad58158a4351190312529596e6ee4571f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string iDynTree::Transform::toString</definition>
        <argsstring>() const</argsstring>
        <name>toString</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="537" column="21"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a3cfe8175a9139f543034665f40743535" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string iDynTree::Transform::reservedToString</definition>
        <argsstring>() const</argsstring>
        <name>reservedToString</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="539" column="21"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classiDynTree_1_1Transform_1a10cda19caf39a2f170da141491e274f8" prot="protected" static="no" mutable="no">
        <type><ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref></type>
        <definition>Position iDynTree::Transform::pos</definition>
        <argsstring></argsstring>
        <name>pos</name>
        <briefdescription>
<para>The position part of the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>The 3d vector <formula id="250">${}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}}$</formula>, that is the vector between the point and the reference point, pointing toward the point and expressed in the reference orientation frame. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="78" column="18" bodyfile="iDynTree/Core/Transform.h" bodystart="78" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classiDynTree_1_1Transform_1a473cab87d96deea511e558fa67b21e57" prot="protected" static="no" mutable="no">
        <type><ref refid="classiDynTree_1_1Rotation" kindref="compound">Rotation</ref></type>
        <definition>Rotation iDynTree::Transform::rot</definition>
        <argsstring></argsstring>
        <name>rot</name>
        <briefdescription>
<para>The rotation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>Set the rotation matrix <formula id="257">${}^{\texttt{refOrient}} R_{\texttt{orient}} \in \mathbb{R}^{3 \times 3}$</formula>, that is the rotation matrix that takes a 3d vector expressed in the orientationFrame and transform it in a 3d vector expressed in the reference orientation frame. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="88" column="18" bodyfile="iDynTree/Core/Transform.h" bodystart="88" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a27bbf3c5f81a55f521aebccd2ef25c82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::Transform::Transform</definition>
        <argsstring>()</argsstring>
        <name>Transform</name>
        <briefdescription>
<para>Default constructor. </para>
        </briefdescription>
        <detaileddescription>
<para>The data is not reset to the default for perfomance reason. Please initialize the data in the class before any use. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="96" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a46a45cf7fbe614298b85c4784f3518de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::Transform::Transform</definition>
        <argsstring>(const Rotation &amp;_rot, const Position &amp;origin)</argsstring>
        <name>Transform</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>_rot</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> &amp;</type>
          <declname>origin</declname>
        </param>
        <briefdescription>
<para>Constructor from a rotation and a point. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="101" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a51b7b01d69d3e0cf26851745a742a8a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::Transform::Transform</definition>
        <argsstring>(const Matrix4x4 &amp;transform)</argsstring>
        <name>Transform</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix4x4</ref> &amp;</type>
          <declname>transform</declname>
        </param>
        <briefdescription>
<para>Constructor from a Matrix4x4 object. </para>
        </briefdescription>
        <detaileddescription>
<para>It is equivalent of calling <ref refid="classiDynTree_1_1Transform_1adf94fe4e7e534b90a8515d9fe2b03d9c" kindref="member">fromHomogeneousTransform()</ref> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transform</parametername>
</parameternamelist>
<parameterdescription>
<para>The input homogeneous matrix </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="107" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a813733bebe23163c27cecab9e289aeef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>iDynTree::Transform::Transform</definition>
        <argsstring>(const Transform &amp;other)</argsstring>
        <name>Transform</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Copy constructor: create a <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> from another <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="112" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1adf94fe4e7e534b90a8515d9fe2b03d9c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::Transform::fromHomogeneousTransform</definition>
        <argsstring>(const Matrix4x4 &amp;transform)</argsstring>
        <name>fromHomogeneousTransform</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1MatrixFixSize" kindref="compound">Matrix4x4</ref> &amp;</type>
          <declname>transform</declname>
        </param>
        <briefdescription>
<para>Set rotation and translation from a iDynTree::Matrix4x4 object. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transform</parametername>
</parameternamelist>
<parameterdescription>
<para>The input homogeneous matrix </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="118" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a5c0d49ae7be0a639762f99c31af25369" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
        <definition>Transform&amp; iDynTree::Transform::operator=</definition>
        <argsstring>(const Transform &amp;other)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Assigment operator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>the rhs</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>*this equal to the other object </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="127" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1ad2a5547291451dbae5c9b5ca5fe32cd1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classiDynTree_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
        <definition>const Rotation&amp; iDynTree::Transform::getRotation</definition>
        <argsstring>() const</argsstring>
        <name>getRotation</name>
        <briefdescription>
<para>Get the rotation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>Get the rotation matrix <formula id="257">${}^{\texttt{refOrient}} R_{\texttt{orient}} \in \mathbb{R}^{3 \times 3}$</formula>, that is the rotation matrix that takes a 3d vector expressed in the orientationFrame and transform it in a 3d vector expressed in the reference orientation frame. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="137" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a63f8b8f234ecea5da3c0210ca1214f27" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> &amp;</type>
        <definition>const Position&amp; iDynTree::Transform::getPosition</definition>
        <argsstring>() const</argsstring>
        <name>getPosition</name>
        <briefdescription>
<para>Get the translation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>Get 3d vector <formula id="250">${}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}}$</formula>, that is the vector between the point and the reference point, pointing toward the point and expressed in the reference orientation frame. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="147" column="25"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a2b95e05edabf49b5584efb38d105f9be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::Transform::setRotation</definition>
        <argsstring>(const Rotation &amp;rotation)</argsstring>
        <name>setRotation</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Rotation" kindref="compound">Rotation</ref> &amp;</type>
          <declname>rotation</declname>
        </param>
        <briefdescription>
<para>Set the rotation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>Set the rotation matrix <formula id="257">${}^{\texttt{refOrient}} R_{\texttt{orient}} \in \mathbb{R}^{3 \times 3}$</formula>, that is the rotation matrix that takes a 3d vector expressed in the orientationFrame and transform it in a 3d vector expressed in the reference orientation frame. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="157" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1ac27f7fdc364760a5e0e24b3c0abab7a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void iDynTree::Transform::setPosition</definition>
        <argsstring>(const Position &amp;position)</argsstring>
        <name>setPosition</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Position" kindref="compound">Position</ref> &amp;</type>
          <declname>position</declname>
        </param>
        <briefdescription>
<para>Set the translation part of the transform. </para>
        </briefdescription>
        <detaileddescription>
<para>Set 3d vector <formula id="250">${}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}}$</formula>, that is the vector between the point and the reference point, pointing toward the point and expressed in the reference orientation frame. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="167" column="14"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a7b197a50886b7b3613874feafb3f5f6e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref></type>
        <definition>static Transform iDynTree::Transform::compose</definition>
        <argsstring>(const Transform &amp;op1, const Transform &amp;op2)</argsstring>
        <name>compose</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>op1</declname>
        </param>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>op2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="170" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1ae07533c65a0654bc797006083fddbd65" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref></type>
        <definition>static Transform iDynTree::Transform::inverse2</definition>
        <argsstring>(const Transform &amp;trans)</argsstring>
        <name>inverse2</name>
        <param>
          <type>const <ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref> &amp;</type>
          <declname>trans</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="171" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classiDynTree_1_1Transform_1a706809fe4f1904e07634ed3d0c493fcd" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classiDynTree_1_1Transform" kindref="compound">Transform</ref></type>
        <definition>static Transform iDynTree::Transform::Identity</definition>
        <argsstring>()</argsstring>
        <name>Identity</name>
        <briefdescription>
<para>Return an identity transfom. </para>
        </briefdescription>
        <detaileddescription>
<para>Set the rotation to the identity and the translation to 0 : <formula id="276">\[ (0_{3 \times 1}, I_{3 \times 3}) \]</formula></para>
<para><simplesect kind="return"><para>an identity transform. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="iDynTree/Core/Transform.h" line="424" column="26"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Class representation the relative displacement between two different frames. </para>
    </briefdescription>
    <detaileddescription>
<para><image type="html" name="transform.svg"></image>
</para>
<para>This class is designed to be an easy to use proxy to perform change of frame of expression for <ref refid="classiDynTree_1_1Position" kindref="compound">iDynTree::Position</ref>, <ref refid="classiDynTree_1_1Twist" kindref="compound">iDynTree::Twist</ref>, <ref refid="classiDynTree_1_1Wrench" kindref="compound">iDynTree::Wrench</ref> and other data structure in <ref refid="group__iDynTreeCore" kindref="compound">iDynTree core data structures</ref>. For this reason the class is called &quot;Transform&quot;, because it will be mainly used to transform quantities between frames.</para>
<para>Given that this class it may used to represent homogeneous transform matrix as well as adjoint matrix, no raw access to the underline storage ( data() method ) is provided, because it does not have a canonical representation. Instead, access is given to the two elements of a transform: The position vector <formula id="250">${}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}}$</formula> and the rotation matrix <formula id="251">${}^{\texttt{refOrient}} R_{\texttt{orient}}$</formula>.</para>
<para>We will indicate this tranform as <formula id="252">$( {}^{\texttt{refOrient}} p_{\texttt{refPoint},\texttt{point}} , {}^{\texttt{refOrient}} R_{\texttt{orient}} )$</formula></para>
<para>The frame whose origin is the reference point and whose orientation the reference orientation is often indicated as <formula id="253">$ \texttt{refFrame} = (\texttt{refPoint},\texttt{refOrient}) $</formula>.</para>
<para>Similarly the frame whose origin is the point and whose orientation is the orientation is indicated as <formula id="254">$ \texttt{frame} = (\texttt{point},\texttt{orient}) $</formula>.</para>
<para>This transform object can be obtained as the <formula id="255">${}^{\texttt{refFrame}} H_{\texttt{frame}}$</formula> 4x4 homogeneous matrix using the asHomogeneousTransform method, or as the <formula id="256">${}^{\texttt{refFrame}} X_{\texttt{frame}}$</formula> 6x6 adjoint matrix using the asAdjointTransform . </para>
    </detaileddescription>
    <collaborationgraph>
      <node id="9">
        <label>iDynTree::VectorFixSize&lt; VecSize &gt;</label>
        <link refid="classiDynTree_1_1VectorFixSize"/>
      </node>
      <node id="2">
        <label>iDynTree::Rotation</label>
        <link refid="classiDynTree_1_1Rotation"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="7">
        <label>iDynTree::PositionRaw</label>
        <link refid="classiDynTree_1_1PositionRaw"/>
        <childnode refid="8" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>Matrix3x3</label>
        <link refid="classiDynTree_1_1MatrixFixSize"/>
        <childnode refid="5" relation="template-instance">
          <edgelabel>&lt; 3, 3 &gt;</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>iDynTree::RotationRaw</label>
        <link refid="classiDynTree_1_1RotationRaw"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="6">
        <label>iDynTree::Position</label>
        <link refid="classiDynTree_1_1Position"/>
        <childnode refid="7" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>iDynTree::MatrixFixSize&lt; nRows, nCols &gt;</label>
        <link refid="classiDynTree_1_1MatrixFixSize"/>
      </node>
      <node id="8">
        <label>Vector3</label>
        <link refid="classiDynTree_1_1VectorFixSize"/>
        <childnode refid="9" relation="template-instance">
          <edgelabel>&lt; 3 &gt;</edgelabel>
        </childnode>
      </node>
      <node id="1">
        <label>iDynTree::Transform</label>
        <link refid="classiDynTree_1_1Transform"/>
        <childnode refid="2" relation="usage">
          <edgelabel>rot</edgelabel>
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>pos</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="iDynTree/Core/Transform.h" line="67" column="5" bodyfile="iDynTree/Core/Transform.h" bodystart="68" bodyend="542"/>
    <listofallmembers>
      <member refid="classiDynTree_1_1Transform_1afadd977e513cdb2813b8763abe627121" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>asAdjointTransform</name></member>
      <member refid="classiDynTree_1_1Transform_1a860616069f3511b9a78b82b4a3de1f2d" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>asAdjointTransformWrench</name></member>
      <member refid="classiDynTree_1_1Transform_1a8db2358dc66b742a7dcc19e5e43f4e39" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>asHomogeneousTransform</name></member>
      <member refid="classiDynTree_1_1Transform_1a7b197a50886b7b3613874feafb3f5f6e" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>compose</name></member>
      <member refid="classiDynTree_1_1Transform_1adf94fe4e7e534b90a8515d9fe2b03d9c" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>fromHomogeneousTransform</name></member>
      <member refid="classiDynTree_1_1Transform_1a63f8b8f234ecea5da3c0210ca1214f27" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>getPosition</name></member>
      <member refid="classiDynTree_1_1Transform_1ad2a5547291451dbae5c9b5ca5fe32cd1" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>getRotation</name></member>
      <member refid="classiDynTree_1_1Transform_1a706809fe4f1904e07634ed3d0c493fcd" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>Identity</name></member>
      <member refid="classiDynTree_1_1Transform_1a8a58af1e6c5d582c5765d91e5cdc1675" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>inverse</name></member>
      <member refid="classiDynTree_1_1Transform_1ae07533c65a0654bc797006083fddbd65" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>inverse2</name></member>
      <member refid="classiDynTree_1_1Transform_1a0020412b9f32230742d028960fcdc811" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>log</name></member>
      <member refid="classiDynTree_1_1Transform_1a83a88c7dbba949bfced19dac0a133f4e" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1a47a4606065be27e235712f9805b3bdc9" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1af120c9b238d9efdf947109b47c4e4fdf" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1a5ecf98714169de1a297c543305005a92" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1a9698f396afb2d422caae294fd6a8894c" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1adb61420ce0cf15da881551147ced2000" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1ac77626420790ccdf7bc8672f0f8238d4" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1ad0351792d47583c938b5dab0d678bafc" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1a1434f959c24d6047900578768e29909c" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1a909ab9d195c19ede41da8b503be868c0" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1a4b630c9130ea310c7dc05034a145557f" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1aa342f1751789eba01433f662d2b0c512" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator*</name></member>
      <member refid="classiDynTree_1_1Transform_1a5c0d49ae7be0a639762f99c31af25369" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>operator=</name></member>
      <member refid="classiDynTree_1_1Transform_1a10cda19caf39a2f170da141491e274f8" prot="protected" virt="non-virtual"><scope>iDynTree::Transform</scope><name>pos</name></member>
      <member refid="classiDynTree_1_1Transform_1a3cfe8175a9139f543034665f40743535" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>reservedToString</name></member>
      <member refid="classiDynTree_1_1Transform_1a473cab87d96deea511e558fa67b21e57" prot="protected" virt="non-virtual"><scope>iDynTree::Transform</scope><name>rot</name></member>
      <member refid="classiDynTree_1_1Transform_1ac27f7fdc364760a5e0e24b3c0abab7a4" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>setPosition</name></member>
      <member refid="classiDynTree_1_1Transform_1a2b95e05edabf49b5584efb38d105f9be" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>setRotation</name></member>
      <member refid="classiDynTree_1_1Transform_1ad58158a4351190312529596e6ee4571f" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>toString</name></member>
      <member refid="classiDynTree_1_1Transform_1a27bbf3c5f81a55f521aebccd2ef25c82" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>Transform</name></member>
      <member refid="classiDynTree_1_1Transform_1a46a45cf7fbe614298b85c4784f3518de" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>Transform</name></member>
      <member refid="classiDynTree_1_1Transform_1a51b7b01d69d3e0cf26851745a742a8a6" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>Transform</name></member>
      <member refid="classiDynTree_1_1Transform_1a813733bebe23163c27cecab9e289aeef" prot="public" virt="non-virtual"><scope>iDynTree::Transform</scope><name>Transform</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
