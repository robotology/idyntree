<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iDynTree: iDynTree::optimalcontrol::ConstraintsGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iDynTree
   </div>
   <div id="projectbrief">Free floating robots dynamics library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">iDynTree::optimalcontrol::ConstraintsGroup Class Reference<div class="ingroups"><a class="el" href="group__iDynTreeExperimental.html">Experimental classes, for which the interface is currently under active development and is not stable.</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class grouping constraints associated with a <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>.  
 <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#details">More...</a></p>

<p><code>#include &lt;ConstraintsGroup.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup_1_1ConstraintsGroupPimpl.html">ConstraintsGroupPimpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a593407e913d25676d1bb8fcff0f09b91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a593407e913d25676d1bb8fcff0f09b91">ConstraintsGroup</a> (const std::string &amp;<a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5140627adcedded7849f6714e2e64e28">name</a>, unsigned int maxConstraintSize)</td></tr>
<tr class="memdesc:a593407e913d25676d1bb8fcff0f09b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a593407e913d25676d1bb8fcff0f09b91">More...</a><br /></td></tr>
<tr class="separator:a593407e913d25676d1bb8fcff0f09b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fec76ff1d42dc7f3adcc3acc99f95b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a1fec76ff1d42dc7f3adcc3acc99f95b0">~ConstraintsGroup</a> ()</td></tr>
<tr class="separator:a1fec76ff1d42dc7f3adcc3acc99f95b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66023d93d7bb66ae77c5dc5b1b6cb40a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a66023d93d7bb66ae77c5dc5b1b6cb40a">ConstraintsGroup</a> (const <a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html">ConstraintsGroup</a> &amp;other)=delete</td></tr>
<tr class="separator:a66023d93d7bb66ae77c5dc5b1b6cb40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5140627adcedded7849f6714e2e64e28"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5140627adcedded7849f6714e2e64e28">name</a> () const</td></tr>
<tr class="memdesc:a5140627adcedded7849f6714e2e64e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the group.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5140627adcedded7849f6714e2e64e28">More...</a><br /></td></tr>
<tr class="separator:a5140627adcedded7849f6714e2e64e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d217c617b0a3f317a5fc3ae259abb35"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5d217c617b0a3f317a5fc3ae259abb35">constraintsDimension</a> () const</td></tr>
<tr class="memdesc:a5d217c617b0a3f317a5fc3ae259abb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum constraint dimension of the group.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5d217c617b0a3f317a5fc3ae259abb35">More...</a><br /></td></tr>
<tr class="separator:a5d217c617b0a3f317a5fc3ae259abb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0026ebe5c345a6df3cc6eed6ee647b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#ae0026ebe5c345a6df3cc6eed6ee647b4">addConstraint</a> (std::shared_ptr&lt; <a class="el" href="classiDynTree_1_1optimalcontrol_1_1Constraint.html">Constraint</a> &gt; constraint, const <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &amp;timeRange)</td></tr>
<tr class="memdesc:ae0026ebe5c345a6df3cc6eed6ee647b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint to the group.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#ae0026ebe5c345a6df3cc6eed6ee647b4">More...</a><br /></td></tr>
<tr class="separator:ae0026ebe5c345a6df3cc6eed6ee647b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0aa1c237e187d9c99ef55a50226a68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a7e0aa1c237e187d9c99ef55a50226a68">addConstraint</a> (std::shared_ptr&lt; <a class="el" href="classiDynTree_1_1optimalcontrol_1_1LinearConstraint.html">LinearConstraint</a> &gt; linearConstraint, const <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &amp;timeRange)</td></tr>
<tr class="memdesc:a7e0aa1c237e187d9c99ef55a50226a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a linear constraint to the group.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a7e0aa1c237e187d9c99ef55a50226a68">More...</a><br /></td></tr>
<tr class="separator:a7e0aa1c237e187d9c99ef55a50226a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc256e4ae98b36e6ad1849348b8ad5d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#acc256e4ae98b36e6ad1849348b8ad5d4">updateTimeRange</a> (const std::string &amp;<a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5140627adcedded7849f6714e2e64e28">name</a>, const <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &amp;timeRange)</td></tr>
<tr class="memdesc:acc256e4ae98b36e6ad1849348b8ad5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> of a previously added constraint.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#acc256e4ae98b36e6ad1849348b8ad5d4">More...</a><br /></td></tr>
<tr class="separator:acc256e4ae98b36e6ad1849348b8ad5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482696c38527f59f393dc0165a9b134a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a482696c38527f59f393dc0165a9b134a">removeConstraint</a> (const std::string &amp;<a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5140627adcedded7849f6714e2e64e28">name</a>)</td></tr>
<tr class="memdesc:a482696c38527f59f393dc0165a9b134a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously added constraint.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a482696c38527f59f393dc0165a9b134a">More...</a><br /></td></tr>
<tr class="separator:a482696c38527f59f393dc0165a9b134a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6140b576f1b5b0f65906fd1026ac7dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a6140b576f1b5b0f65906fd1026ac7dd4">getTimeRange</a> (const std::string &amp;<a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5140627adcedded7849f6714e2e64e28">name</a>, <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &amp;timeRange)</td></tr>
<tr class="memdesc:a6140b576f1b5b0f65906fd1026ac7dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> of the specified constraint.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a6140b576f1b5b0f65906fd1026ac7dd4">More...</a><br /></td></tr>
<tr class="separator:a6140b576f1b5b0f65906fd1026ac7dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4ab2add789a5e7bfe3ccf3d825db04"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a1a4ab2add789a5e7bfe3ccf3d825db04">getTimeRanges</a> ()</td></tr>
<tr class="memdesc:a1a4ab2add789a5e7bfe3ccf3d825db04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector containing all the TimeRanges of the added constraints.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a1a4ab2add789a5e7bfe3ccf3d825db04">More...</a><br /></td></tr>
<tr class="separator:a1a4ab2add789a5e7bfe3ccf3d825db04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5379fb2ea07fc4571706b29e53e79c67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5379fb2ea07fc4571706b29e53e79c67">isFeasibilePoint</a> (double time, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;<a class="el" href="structstate.html">state</a>, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;control)</td></tr>
<tr class="memdesc:a5379fb2ea07fc4571706b29e53e79c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether, at the specified time, the enabled constraint is satisfied.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5379fb2ea07fc4571706b29e53e79c67">More...</a><br /></td></tr>
<tr class="separator:a5379fb2ea07fc4571706b29e53e79c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81013d0cf1b4b71eff111dff2299b604"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a81013d0cf1b4b71eff111dff2299b604">evaluateConstraints</a> (double time, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;<a class="el" href="structstate.html">state</a>, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;control, <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;constraints)</td></tr>
<tr class="memdesc:a81013d0cf1b4b71eff111dff2299b604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the constraint which is enabled at the specified time.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a81013d0cf1b4b71eff111dff2299b604">More...</a><br /></td></tr>
<tr class="separator:a81013d0cf1b4b71eff111dff2299b604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2555fe639e01afdd35c920395d08d7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#ae2555fe639e01afdd35c920395d08d7e">getLowerBound</a> (double time, <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;lowerBound)</td></tr>
<tr class="memdesc:ae2555fe639e01afdd35c920395d08d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constraints lower bound.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#ae2555fe639e01afdd35c920395d08d7e">More...</a><br /></td></tr>
<tr class="separator:ae2555fe639e01afdd35c920395d08d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8532cfbf612aef484fbf70ad9d609596"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a8532cfbf612aef484fbf70ad9d609596">getUpperBound</a> (double time, <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;upperBound)</td></tr>
<tr class="memdesc:a8532cfbf612aef484fbf70ad9d609596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constraints upper bound.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a8532cfbf612aef484fbf70ad9d609596">More...</a><br /></td></tr>
<tr class="separator:a8532cfbf612aef484fbf70ad9d609596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aafbfaebcd05313d6e935749d5b88ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a8aafbfaebcd05313d6e935749d5b88ea">constraintJacobianWRTState</a> (double time, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;<a class="el" href="structstate.html">state</a>, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;control, <a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;jacobian)</td></tr>
<tr class="memdesc:a8aafbfaebcd05313d6e935749d5b88ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the constraint jacobian with respect to the state, given the specified time instant.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a8aafbfaebcd05313d6e935749d5b88ea">More...</a><br /></td></tr>
<tr class="separator:a8aafbfaebcd05313d6e935749d5b88ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d1dfd82bb37e7e1fe2005aaa730686"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a68d1dfd82bb37e7e1fe2005aaa730686">constraintJacobianWRTControl</a> (double time, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;<a class="el" href="structstate.html">state</a>, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;control, <a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;jacobian)</td></tr>
<tr class="memdesc:a68d1dfd82bb37e7e1fe2005aaa730686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the constraint jacobian with respect to the control, given the specified time instant.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a68d1dfd82bb37e7e1fe2005aaa730686">More...</a><br /></td></tr>
<tr class="separator:a68d1dfd82bb37e7e1fe2005aaa730686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e00bf25f6697f52179aaf4308291ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#ac3e00bf25f6697f52179aaf4308291ad">constraintJacobianWRTStateSparsity</a> (<a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;stateSparsity) const</td></tr>
<tr class="memdesc:ac3e00bf25f6697f52179aaf4308291ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nonzeros elements in terms of row and colun index, in the state jacobian.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#ac3e00bf25f6697f52179aaf4308291ad">More...</a><br /></td></tr>
<tr class="separator:ac3e00bf25f6697f52179aaf4308291ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a2f63df7da1a82c314f9cb9efa1533"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a33a2f63df7da1a82c314f9cb9efa1533">constraintJacobianWRTControlSparsity</a> (<a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;controlSparsity) const</td></tr>
<tr class="memdesc:a33a2f63df7da1a82c314f9cb9efa1533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nonzeros elements in terms of row and colun index, in the control jacobian.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a33a2f63df7da1a82c314f9cb9efa1533">More...</a><br /></td></tr>
<tr class="separator:a33a2f63df7da1a82c314f9cb9efa1533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0b81af7e248f4fd7b77439b0b2df22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a3e0b81af7e248f4fd7b77439b0b2df22">constraintSecondPartialDerivativeWRTState</a> (double time, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;<a class="el" href="structstate.html">state</a>, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;control, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;lambda, <a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;hessian)</td></tr>
<tr class="memdesc:a3e0b81af7e248f4fd7b77439b0b2df22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate constraint second partial derivative wrt the state variables.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a3e0b81af7e248f4fd7b77439b0b2df22">More...</a><br /></td></tr>
<tr class="separator:a3e0b81af7e248f4fd7b77439b0b2df22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6480876db7aeaf3484ad77f1ab9a8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#adc6480876db7aeaf3484ad77f1ab9a8a">constraintSecondPartialDerivativeWRTControl</a> (double time, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;<a class="el" href="structstate.html">state</a>, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;control, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;lambda, <a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;hessian)</td></tr>
<tr class="memdesc:adc6480876db7aeaf3484ad77f1ab9a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate constraint second partial derivative wrt the control.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#adc6480876db7aeaf3484ad77f1ab9a8a">More...</a><br /></td></tr>
<tr class="separator:adc6480876db7aeaf3484ad77f1ab9a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0161b4457cf802815a94a8a6eec7ce6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a0161b4457cf802815a94a8a6eec7ce6a">constraintSecondPartialDerivativeWRTStateControl</a> (double time, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;<a class="el" href="structstate.html">state</a>, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;control, const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;lambda, <a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;hessian)</td></tr>
<tr class="memdesc:a0161b4457cf802815a94a8a6eec7ce6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate constraint second partial derivative wrt the state and control.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a0161b4457cf802815a94a8a6eec7ce6a">More...</a><br /></td></tr>
<tr class="separator:a0161b4457cf802815a94a8a6eec7ce6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bd3dc34369aa9b8f313227f721a7cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a92bd3dc34369aa9b8f313227f721a7cc">constraintsSecondPartialDerivativeWRTStateSparsity</a> (<a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;stateSparsity)</td></tr>
<tr class="memdesc:a92bd3dc34369aa9b8f313227f721a7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nonzeros elements in terms of row and colun index, in the state hessian.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a92bd3dc34369aa9b8f313227f721a7cc">More...</a><br /></td></tr>
<tr class="separator:a92bd3dc34369aa9b8f313227f721a7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c04549670837f5cc2d4613289d7c80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#ae3c04549670837f5cc2d4613289d7c80">constraintsSecondPartialDerivativeWRTStateControlSparsity</a> (<a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;stateControlSparsity)</td></tr>
<tr class="memdesc:ae3c04549670837f5cc2d4613289d7c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nonzeros elements in terms of row and colun index, in the mixed hessian.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#ae3c04549670837f5cc2d4613289d7c80">More...</a><br /></td></tr>
<tr class="separator:ae3c04549670837f5cc2d4613289d7c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7829d4f018f668b295ce0e9443bed555"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a7829d4f018f668b295ce0e9443bed555">constraintsSecondPartialDerivativeWRTControlSparsity</a> (<a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;controlSparsity)</td></tr>
<tr class="memdesc:a7829d4f018f668b295ce0e9443bed555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of nonzeros elements in terms of row and colun index, in the control hessian.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a7829d4f018f668b295ce0e9443bed555">More...</a><br /></td></tr>
<tr class="separator:a7829d4f018f668b295ce0e9443bed555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116fdd0435e3dd18526eaef723d021ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a116fdd0435e3dd18526eaef723d021ca">isAnyTimeGroup</a> ()</td></tr>
<tr class="memdesc:a116fdd0435e3dd18526eaef723d021ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag returning true if the group is an "AnyTime" group.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a116fdd0435e3dd18526eaef723d021ca">More...</a><br /></td></tr>
<tr class="separator:a116fdd0435e3dd18526eaef723d021ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d7b7ac636d84e0a1859e17ef530edf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a55d7b7ac636d84e0a1859e17ef530edf">numberOfConstraints</a> () const</td></tr>
<tr class="memdesc:a55d7b7ac636d84e0a1859e17ef530edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of constraints added in the group.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a55d7b7ac636d84e0a1859e17ef530edf">More...</a><br /></td></tr>
<tr class="separator:a55d7b7ac636d84e0a1859e17ef530edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6d038d896c675f91eb03f891851b1f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5e6d038d896c675f91eb03f891851b1f">listConstraints</a> () const</td></tr>
<tr class="memdesc:a5e6d038d896c675f91eb03f891851b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the available constraints.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a5e6d038d896c675f91eb03f891851b1f">More...</a><br /></td></tr>
<tr class="separator:a5e6d038d896c675f91eb03f891851b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3570a6ba4f5c3d317b05a1afdd607afb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a3570a6ba4f5c3d317b05a1afdd607afb">isLinearGroup</a> () const</td></tr>
<tr class="memdesc:a3570a6ba4f5c3d317b05a1afdd607afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if the groups contains only linear constraints.  <a href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html#a3570a6ba4f5c3d317b05a1afdd607afb">More...</a><br /></td></tr>
<tr class="separator:a3570a6ba4f5c3d317b05a1afdd607afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class grouping constraints associated with a <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>This class is still in active development, and so API interface can change between <a class="el" href="namespaceiDynTree.html">iDynTree</a> versions.</dd></dl>
<p>This class allows to define a set of constraints which are enabled only for a particular time range. This allow to change the constraint structure depending on time. Given a specific time instant, only one constraint is enabled (the one whose <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> contains the instant and has the higher initTime). If the specified time instant does not fall into any time constraint time range, a dummy constraint wil be evaluated, i.e. \( -1 \leq 0 \leq 1 \). All the constraints that will be added to the group should have dimension at most equal to maxConstraintSize. If the constraint size is smaller than the maxConstraintSize, dummy constraints as the above will be added on the bottom. This allow to keep a constant structure even if the constraints have different dimensions. A typical example is when a constraint is enabled only for a certain period of time. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a593407e913d25676d1bb8fcff0f09b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593407e913d25676d1bb8fcff0f09b91">&#9670;&nbsp;</a></span>ConstraintsGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynTree::optimalcontrol::ConstraintsGroup::ConstraintsGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxConstraintSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Univocal name of the group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxConstraintSize</td><td>Maximum dimension allowed when adding a constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fec76ff1d42dc7f3adcc3acc99f95b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fec76ff1d42dc7f3adcc3acc99f95b0">&#9670;&nbsp;</a></span>~ConstraintsGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iDynTree::optimalcontrol::ConstraintsGroup::~ConstraintsGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66023d93d7bb66ae77c5dc5b1b6cb40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66023d93d7bb66ae77c5dc5b1b6cb40a">&#9670;&nbsp;</a></span>ConstraintsGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iDynTree::optimalcontrol::ConstraintsGroup::ConstraintsGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html">ConstraintsGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5140627adcedded7849f6714e2e64e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5140627adcedded7849f6714e2e64e28">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string iDynTree::optimalcontrol::ConstraintsGroup::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the group. </p>
<dl class="section return"><dt>Returns</dt><dd>The univocal name of the constraint group. </dd></dl>

</div>
</div>
<a id="a5d217c617b0a3f317a5fc3ae259abb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d217c617b0a3f317a5fc3ae259abb35">&#9670;&nbsp;</a></span>constraintsDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iDynTree::optimalcontrol::ConstraintsGroup::constraintsDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum constraint dimension of the group. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum constraint dimension of the group. </dd></dl>

</div>
</div>
<a id="ae0026ebe5c345a6df3cc6eed6ee647b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0026ebe5c345a6df3cc6eed6ee647b4">&#9670;&nbsp;</a></span>addConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::addConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classiDynTree_1_1optimalcontrol_1_1Constraint.html">Constraint</a> &gt;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>timeRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constraint to the group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>Shared pointer to the user defined constraint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeRange</td><td>Time range in which the constraint will be enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfull. Posible causes of failures are: empty pointer, dimension bigger than maxConstraintSize, invalid <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. </dd></dl>

</div>
</div>
<a id="a7e0aa1c237e187d9c99ef55a50226a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0aa1c237e187d9c99ef55a50226a68">&#9670;&nbsp;</a></span>addConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::addConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classiDynTree_1_1optimalcontrol_1_1LinearConstraint.html">LinearConstraint</a> &gt;&#160;</td>
          <td class="paramname"><em>linearConstraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>timeRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a linear constraint to the group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linearConstraint</td><td>Shared pointer to a linear constraint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeRange</td><td>Time range in which the constraint will be enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfull. Posible causes of failures are: empty pointer, dimension bigger than maxConstraintSize, invalid <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. </dd></dl>

</div>
</div>
<a id="acc256e4ae98b36e6ad1849348b8ad5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc256e4ae98b36e6ad1849348b8ad5d4">&#9670;&nbsp;</a></span>updateTimeRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::updateTimeRange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>timeRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> of a previously added constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the constraint whose <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> has to be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeRange</td><td>The new <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfull. Possible causes of failure: invalid <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>, a constraint does not exist with the specified name. </dd></dl>

</div>
</div>
<a id="a482696c38527f59f393dc0165a9b134a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482696c38527f59f393dc0165a9b134a">&#9670;&nbsp;</a></span>removeConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::removeConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a previously added constraint. </p>
<p>Note: the sparsity pattern is not updated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the constraint that has to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfull. Possible causes of failure: a constraint does not exist with the specified name. </dd></dl>

</div>
</div>
<a id="a6140b576f1b5b0f65906fd1026ac7dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6140b576f1b5b0f65906fd1026ac7dd4">&#9670;&nbsp;</a></span>getTimeRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::getTimeRange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &amp;&#160;</td>
          <td class="paramname"><em>timeRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> of the specified constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the constraint whose <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> you are interested in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeRange</td><td>The requested <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfull. Possible causes of failure: a constraint does not exist with the specified name. </dd></dl>

</div>
</div>
<a id="a1a4ab2add789a5e7bfe3ccf3d825db04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4ab2add789a5e7bfe3ccf3d825db04">&#9670;&nbsp;</a></span>getTimeRanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a> &gt; &amp; iDynTree::optimalcontrol::ConstraintsGroup::getTimeRanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a vector containing all the TimeRanges of the added constraints. </p>
<p>The order corresponds to the one get via the listConstraints method. </p><dl class="section warning"><dt>Warning</dt><dd>It may perform dynamic memory allocation when called the first time and when the number of constraint changes. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing all the TimeRanges of the added constraints. </dd></dl>

</div>
</div>
<a id="a5379fb2ea07fc4571706b29e53e79c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5379fb2ea07fc4571706b29e53e79c67">&#9670;&nbsp;</a></span>isFeasibilePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::isFeasibilePoint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether, at the specified time, the enabled constraint is satisfied. </p>
<p>Given the time instant, this method search for the constraint to be enabled according to the specified <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. Then calls the constraint to check the feasibility of the constraint given the specified state and control. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time at which the constraint group is evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state at which the constraint group is evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>The control at which the constraint group is evaluated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if, at the specified time, the enabled constraint is satisfied. </dd></dl>

</div>
</div>
<a id="a81013d0cf1b4b71eff111dff2299b604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81013d0cf1b4b71eff111dff2299b604">&#9670;&nbsp;</a></span>evaluateConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::evaluateConstraints </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the constraint which is enabled at the specified time. </p>
<p>Given the time instant, this method search for the constraint to be enabled according to the specified <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. Then it evaluates it given the specified state and control. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time at which the constraint group is evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state at which the constraint group is evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>The control at which the constraint group is evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">constraints</td><td>The value obtained by evaluating the enbled constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the evaluation of the enabled constraint was successfull. </dd></dl>

</div>
</div>
<a id="ae2555fe639e01afdd35c920395d08d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2555fe639e01afdd35c920395d08d7e">&#9670;&nbsp;</a></span>getLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::getLowerBound </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>lowerBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the constraints lower bound. </p>
<p>This value depends upon the chosen time instant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time at which querying the lower bound. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lowerBound</td><td>The lowerBound value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if, for the given instant, a lower bound is set. False otherwise. </dd></dl>

</div>
</div>
<a id="a8532cfbf612aef484fbf70ad9d609596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8532cfbf612aef484fbf70ad9d609596">&#9670;&nbsp;</a></span>getUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::getUpperBound </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>upperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the constraints upper bound. </p>
<p>This value depends upon the chosen time instant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time at which querying the upper bound. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upperBound</td><td>The upperBound value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if, for the given instant, a upper bound is set. False otherwise. </dd></dl>

</div>
</div>
<a id="a8aafbfaebcd05313d6e935749d5b88ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aafbfaebcd05313d6e935749d5b88ea">&#9670;&nbsp;</a></span>constraintJacobianWRTState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintJacobianWRTState </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the constraint jacobian with respect to the state, given the specified time instant. </p>
<p>Given the time instant, this method search for the constraint to be enabled according to the specified <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. Then it evaluates its jacobian given the specified state and control. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time at which the jacobian is evaluted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state at which the jacobian is evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>The control at which the jacobian is evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">jacobian</td><td>The output jacobian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the evaluation of the corresponding method of the enabled constraint return true. False otherwise. </dd></dl>

</div>
</div>
<a id="a68d1dfd82bb37e7e1fe2005aaa730686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d1dfd82bb37e7e1fe2005aaa730686">&#9670;&nbsp;</a></span>constraintJacobianWRTControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintJacobianWRTControl </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the constraint jacobian with respect to the control, given the specified time instant. </p>
<p>Given the time instant, this method search for the constraint to be enabled according to the specified <a class="el" href="classiDynTree_1_1optimalcontrol_1_1TimeRange.html">TimeRange</a>. Then it evaluates its jacobian given the specified state and control. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>Time at which the jacobian is evaluted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state at which the jacobian is evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>The control at which the jacobian is evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">jacobian</td><td>The output jacobian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the evaluation of the corresponding method of the enabled constraint return true. False otherwise. </dd></dl>

</div>
</div>
<a id="ac3e00bf25f6697f52179aaf4308291ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e00bf25f6697f52179aaf4308291ad">&#9670;&nbsp;</a></span>constraintJacobianWRTStateSparsity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintJacobianWRTStateSparsity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>stateSparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nonzeros elements in terms of row and colun index, in the state jacobian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stateSparsity</td><td>Sparsity structure of the partial derivative of the jacobian wrt state variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sparsity is available. False otherwise. </dd></dl>

</div>
</div>
<a id="a33a2f63df7da1a82c314f9cb9efa1533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a2f63df7da1a82c314f9cb9efa1533">&#9670;&nbsp;</a></span>constraintJacobianWRTControlSparsity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintJacobianWRTControlSparsity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>controlSparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nonzeros elements in terms of row and colun index, in the control jacobian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controlSparsity</td><td>Sparsity structure of the partial derivative of the jacobian wrt control variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sparsity is available. False otherwise. </dd></dl>

</div>
</div>
<a id="a3e0b81af7e248f4fd7b77439b0b2df22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0b81af7e248f4fd7b77439b0b2df22">&#9670;&nbsp;</a></span>constraintSecondPartialDerivativeWRTState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintSecondPartialDerivativeWRTState </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>hessian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate constraint second partial derivative wrt the state variables. </p>
<p>It is the result of \(\sum \lambda_i \frac{\partial^2 c(t, x, u)}{\partial x^2}\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time at which the partial derivative is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state value at which the partial derivative is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>The control value at which the partial derivative is computed.. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>The lagrange multipliers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hessian</td><td>The output partial derivative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfull, false otherwise (or if not implemented). </dd></dl>

</div>
</div>
<a id="adc6480876db7aeaf3484ad77f1ab9a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6480876db7aeaf3484ad77f1ab9a8a">&#9670;&nbsp;</a></span>constraintSecondPartialDerivativeWRTControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintSecondPartialDerivativeWRTControl </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>hessian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate constraint second partial derivative wrt the control. </p>
<p>It is the result of \(\sum \lambda_i \frac{\partial^2 c(t, x, u)}{\partial u^2}\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time at which the partial derivative is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state value at which the partial derivative is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>The control value at which the partial derivative is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>The lagrange multipliers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hessian</td><td>The output partial derivative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfull, false otherwise (or if not implemented). </dd></dl>

</div>
</div>
<a id="a0161b4457cf802815a94a8a6eec7ce6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0161b4457cf802815a94a8a6eec7ce6a">&#9670;&nbsp;</a></span>constraintSecondPartialDerivativeWRTStateControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintSecondPartialDerivativeWRTStateControl </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiDynTree_1_1VectorDynSize.html">VectorDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1MatrixDynSize.html">MatrixDynSize</a> &amp;&#160;</td>
          <td class="paramname"><em>hessian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate constraint second partial derivative wrt the state and control. </p>
<p>It is the result of \(\sum \lambda_i \frac{\partial^2 c(t, x, u)}{\partial x \partial u}\), thus it has number of rows equals to the number of states and number of cols equal to the number of control inputs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time at which the partial derivative is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>The state value at which the partial derivative is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>The control value at which the partial derivative is computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>The lagrange multipliers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hessian</td><td>The output partial derivative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfull, false otherwise (or if not implemented). </dd></dl>

</div>
</div>
<a id="a92bd3dc34369aa9b8f313227f721a7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bd3dc34369aa9b8f313227f721a7cc">&#9670;&nbsp;</a></span>constraintsSecondPartialDerivativeWRTStateSparsity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintsSecondPartialDerivativeWRTStateSparsity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>stateSparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nonzeros elements in terms of row and colun index, in the state hessian. </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed in the indeces. They need to be in the range [0, stateDimension) and [0, stateDimension) respectively. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stateSparsity</td><td>Sparsity structure of the partial derivative of the jacobian wrt state variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sparsity is available. False otherwise. </dd></dl>

</div>
</div>
<a id="ae3c04549670837f5cc2d4613289d7c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c04549670837f5cc2d4613289d7c80">&#9670;&nbsp;</a></span>constraintsSecondPartialDerivativeWRTStateControlSparsity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintsSecondPartialDerivativeWRTStateControlSparsity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>stateControlSparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nonzeros elements in terms of row and colun index, in the mixed hessian. </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed in the indeces. They need to be in the range [0, stateDimension) and [0, controlDimension) respectively. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stateControlSparsity</td><td>Sparsity structure of the partial derivative of the jacobian wrt state and control variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sparsity is available. False otherwise. </dd></dl>

</div>
</div>
<a id="a7829d4f018f668b295ce0e9443bed555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7829d4f018f668b295ce0e9443bed555">&#9670;&nbsp;</a></span>constraintsSecondPartialDerivativeWRTControlSparsity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::constraintsSecondPartialDerivativeWRTControlSparsity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1SparsityStructure.html">iDynTree::optimalcontrol::SparsityStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>controlSparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of nonzeros elements in terms of row and colun index, in the control hessian. </p>
<dl class="section warning"><dt>Warning</dt><dd>No check is performed in the indeces. They need to be in the range [0, constraintDimension) and [0, controlDimension) respectively. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">controlSparsity</td><td>Sparsity structure of the partial derivative of the jacobian wrt control variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sparsity is available. False otherwise. </dd></dl>

</div>
</div>
<a id="a116fdd0435e3dd18526eaef723d021ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116fdd0435e3dd18526eaef723d021ca">&#9670;&nbsp;</a></span>isAnyTimeGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::isAnyTimeGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag returning true if the group is an "AnyTime" group. </p>
<p>An "AnyTime" group contains only one constraint which is always enabled. It corresponds to a simple constraint. </p><dl class="section return"><dt>Returns</dt><dd>true if the group contains a single constraint always enables. False otherwise. </dd></dl>

</div>
</div>
<a id="a55d7b7ac636d84e0a1859e17ef530edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d7b7ac636d84e0a1859e17ef530edf">&#9670;&nbsp;</a></span>numberOfConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int iDynTree::optimalcontrol::ConstraintsGroup::numberOfConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of constraints added in the group. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of constraints currently loaded in the group. </dd></dl>

</div>
</div>
<a id="a5e6d038d896c675f91eb03f891851b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6d038d896c675f91eb03f891851b1f">&#9670;&nbsp;</a></span>listConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; iDynTree::optimalcontrol::ConstraintsGroup::listConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the available constraints. </p>
<dl class="section warning"><dt>Warning</dt><dd>Perform memory allocation while creating the output vector. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The list of the names of the constraints added to the group. </dd></dl>

</div>
</div>
<a id="a3570a6ba4f5c3d317b05a1afdd607afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3570a6ba4f5c3d317b05a1afdd607afb">&#9670;&nbsp;</a></span>isLinearGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool iDynTree::optimalcontrol::ConstraintsGroup::isLinearGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if the groups contains only linear constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>true if contains only linear constraints. False if at least one generic constraint is added. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ConstraintsGroup_8h.html">ConstraintsGroup.h</a></li>
<li><a class="el" href="ConstraintsGroup_8cpp.html">ConstraintsGroup.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceiDynTree.html">iDynTree</a></li><li class="navelem"><a class="el" href="namespaceiDynTree_1_1optimalcontrol.html">optimalcontrol</a></li><li class="navelem"><a class="el" href="classiDynTree_1_1optimalcontrol_1_1ConstraintsGroup.html">ConstraintsGroup</a></li>
    <li class="footer">Generated on Wed Jul 7 2021 21:56:08 for iDynTree by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
